[
    {
        "query_id": "read1",
        "query_type": "multi-hop-transfer-blocked-medium",
        "query_template": "MATCH p = (acc:Account {id:%d})-[e1:transfer *1..3]->(other:Account)<-[e2:signIn]-(medium) WHERE isAsc(getMemberProp(e1, 'timestamp'))=true AND head(getMemberProp(e1, 'timestamp')) > %d AND last(getMemberProp(e1, 'timestamp')) < %d AND e2.timestamp > %d AND e2.timestamp < %d AND medium.isBlocked = true RETURN DISTINCT other.id as otherId, length(p)-1 as accountDistance, medium.id as mediumId, medium.type as mediumType ORDER BY accountDistance, otherId, mediumId;",
        "query_parameters": {
            "acc_id": "Account ID",
            "transfer_start_time": "Transfer start time",
            "transfer_end_time": "Transfer end time",
            "signin_start_time": "Sign-in start time",
            "signin_end_time": "Sign-in end time"
        },
        "nl": "From a given account, find other accounts reachable through 1-3 transfer steps (with timestamps in ascending order within a specified time window), filter those accounts that were signed in by a blocked medium during another time window, and return account ID, transfer distance, medium ID and type"
    },
    {
        "query_id": "read2",
        "query_type": "person-account-transfer-loan",
        "query_template": "MATCH (p:Person {id:%d})-[e1:own]->(acc:Account) <-[e2:transfer*1..3]-(other:Account) WHERE isDesc(getMemberProp(e2, 'timestamp'))=true AND head(getMemberProp(e2, 'timestamp')) < %d AND last(getMemberProp(e2, 'timestamp')) > %d WITH DISTINCT other MATCH (other)<-[e3:deposit]-(loan:Loan) WHERE e3.timestamp > %d AND e3.timestamp < %d WITH DISTINCT other.id AS otherId, loan.loanAmount AS loanAmount, loan.balance AS loanBalance WITH otherId AS otherId, sum(loanAmount) as sumLoanAmount, sum(loanBalance) as sumLoanBalance RETURN otherId, round(sumLoanAmount * 1000) / 1000 as sumLoanAmount, round(sumLoanBalance * 1000) / 1000 as sumLoanBalance ORDER BY sumLoanAmount DESC, otherId ASC;",
        "query_parameters": {
            "person_id": "Person ID",
            "transfer_start_time": "Transfer start time",
            "transfer_end_time": "Transfer end time",
            "deposit_start_time": "Deposit start time",
            "deposit_end_time": "Deposit end time"
        },
        "nl": "From a given person, find all accounts they own, trace back 1-3 reverse transfers (with timestamps in strictly descending order), find loans deposited into those accounts, and aggregate loan amounts and balances per account"
    },
    {
        "query_id": "read3",
        "query_type": "shortest-path",
        "query_template": "MATCH (src:Account{id:%d}), (dst:Account{id:%d}) CALL algo.shortestPath( src, dst, { direction: 'PointingRight', relationshipQuery:'transfer', edgeFilter: { timestamp: { smaller_than: %d, greater_than: %d } } } ) YIELD nodeCount RETURN nodeCount - 1 AS len;",
        "query_parameters": {
            "src_id": "Source account ID",
            "dst_id": "Destination account ID",
            "timestamp_upper": "Timestamp upper bound",
            "timestamp_lower": "Timestamp lower bound"
        },
        "nl": "Compute the shortest transfer path length from source account to destination account, using only transfer edges with timestamps within the specified window"
    },
    {
        "query_id": "read4",
        "query_type": "intermediate-account-transfer-stats",
        "query_template": "MATCH (src:Account {id:%d})-[e1:transfer]->(dst:Account {id:%d}) WHERE e1.timestamp > %d AND e1.timestamp < %d WITH src, dst.id as dstid MATCH (src)<-[e2:transfer]-(other:Account)<-[e3:transfer]-(dst:Account) WHERE dst.id=dstid AND e2.timestamp > %d AND e2.timestamp < %d AND e3.timestamp > %d AND e3.timestamp < %d WITH DISTINCT src, other, dst MATCH (src)<-[e2:transfer]-(other) WHERE e2.timestamp > %d AND e2.timestamp < %d WITH src, other, dst, count(e2) as numEdge2, sum(e2.amount) as sumEdge2Amount, max(e2.amount) as maxEdge2Amount MATCH (other)<-[e3:transfer]-(dst) WHERE e3.timestamp > %d AND e3.timestamp < %d WITH other.id as otherId, numEdge2, sumEdge2Amount, maxEdge2Amount, count(e3) as numEdge3, sum(e3.amount) as sumEdge3Amount, max(e3.amount) as maxEdge3Amount RETURN otherId, numEdge2, round(sumEdge2Amount * 1000) / 1000 as sumEdge2Amount, round(maxEdge2Amount * 1000) / 1000 as maxEdge2Amount, numEdge3, round(sumEdge3Amount * 1000) / 1000 as sumEdge3Amount, round(maxEdge3Amount * 1000) / 1000 as maxEdge3Amount ORDER BY sumEdge2Amount DESC, sumEdge3Amount DESC, otherId ASC;",
        "query_parameters": {
            "src_id": "Source account ID",
            "dst_id": "Destination account ID",
            "direct_transfer_start": "Direct transfer start time",
            "direct_transfer_end": "Direct transfer end time",
            "e2_start_time_1": "Intermediate transfer e2 start time 1",
            "e2_end_time_1": "Intermediate transfer e2 end time 1",
            "e3_start_time_1": "Intermediate transfer e3 start time 1",
            "e3_end_time_1": "Intermediate transfer e3 end time 1",
            "e2_start_time_2": "Intermediate transfer e2 start time 2",
            "e2_end_time_2": "Intermediate transfer e2 end time 2",
            "e3_start_time_2": "Intermediate transfer e3 start time 2",
            "e3_end_time_2": "Intermediate transfer e3 end time 2"
        },
        "nl": "Find direct transfers between source and destination accounts, then find all intermediate accounts that both transferred to source and received transfers from destination, compute transfer count, sum and max amount statistics"
    },
    {
        "query_id": "read5",
        "query_type": "transfer-path-no-duplicate",
        "query_template": "MATCH (person:Person {id:%d})-[e1:own]->(src:Account) WITH src MATCH p=(src)-[e2:transfer*1..3]->(dst:Account) WHERE isAsc(getMemberProp(e2, 'timestamp'))=true AND head(getMemberProp(e2, 'timestamp')) > %d AND last(getMemberProp(e2, 'timestamp')) < %d WITH DISTINCT getMemberProp(nodes(p), 'id') as path, length(p) as len ORDER BY len DESC WHERE hasDuplicates(path)=false RETURN path;",
        "query_parameters": {
            "person_id": "Person ID",
            "transfer_start_time": "Transfer start time",
            "transfer_end_time": "Transfer end time"
        },
        "nl": "From accounts owned by a given person, find all 1-3 step transfer paths (with timestamps in strictly ascending order within the specified window), return only paths without duplicate accounts, sorted by path length in descending order"
    },
    {
        "query_id": "read6",
        "query_type": "card-withdraw-transfer-stats",
        "query_template": "MATCH (dstCard:Account {id:%d} )<-[edge2:withdraw]-(mid:Account) WHERE dstCard.type ENDS WITH 'card' AND edge2.timestamp > %d AND edge2.timestamp < %d AND edge2.amount > %f WITH mid, sum(edge2.amount) as sumEdge2Amount, count(edge2.amount) as t MATCH (mid)<-[edge1:transfer]-(src:Account) WHERE edge1.timestamp > %d AND edge1.timestamp < %d AND edge1.amount > %f WITH mid.id AS midId, count(edge1) AS edge1Count, sum(edge1.amount) AS sumEdge1Amount, sumEdge2Amount WHERE edge1Count > 3 WITH midId, sumEdge1Amount, sumEdge2Amount RETURN midId, round(sumEdge1Amount * 1000) / 1000 as sumEdge1Amount, round(sumEdge2Amount * 1000) / 1000 as sumEdge2Amount ORDER BY sumEdge2Amount DESC;",
        "query_parameters": {
            "card_id": "Card account ID",
            "withdraw_start_time": "Withdraw start time",
            "withdraw_end_time": "Withdraw end time",
            "withdraw_amount_threshold": "Withdraw amount threshold",
            "transfer_start_time": "Transfer start time",
            "transfer_end_time": "Transfer end time",
            "transfer_amount_threshold": "Transfer amount threshold"
        },
        "nl": "Find intermediate accounts that withdrew to the specified card account, filter those with withdrawal amount exceeding threshold and more than 3 incoming transfers, return aggregated transfer and withdrawal amounts"
    },
    {
        "query_id": "read7",
        "query_type": "account-transfer-in-out-ratio",
        "query_template": "MATCH (mid:Account {id:%d}) WITH mid OPTIONAL MATCH (mid)-[edge2:transfer]->(dst:Account) WHERE edge2.timestamp > %d AND edge2.timestamp < %d AND edge2.amount > %f WITH mid, count(distinct dst) as numDst, sum(edge2.amount) as amountDst OPTIONAL MATCH (mid)<-[edge1:transfer]-(src:Account) WHERE edge1.timestamp > %d AND edge1.timestamp < %d AND edge1.amount > %f WITH count(distinct src) as numSrc, sum(edge1.amount) as amountSrc, numDst, amountDst RETURN numSrc, numDst, CASE WHEN amountDst=0 THEN -1 ELSE round(1000.0 * amountSrc / amountDst) / 1000 END AS inOutRatio;",
        "query_parameters": {
            "account_id": "Account ID",
            "out_start_time": "Outgoing transfer start time",
            "out_end_time": "Outgoing transfer end time",
            "out_amount_threshold": "Outgoing amount threshold",
            "in_start_time": "Incoming transfer start time",
            "in_end_time": "Incoming transfer end time",
            "in_amount_threshold": "Incoming amount threshold"
        },
        "nl": "Compute incoming and outgoing transfer statistics for a specified account, calculate the incoming/outgoing amount ratio"
    },
    {
        "query_id": "read8",
        "query_type": "plugin-tcr8",
        "query_template": "CALL plugin.cpp.tcr8({ id:%d, threshold: %f, startTime: %d, endTime: %d, limit: %d });",
        "query_parameters": {
            "id": "ID",
            "threshold": "Threshold",
            "startTime": "Start time",
            "endTime": "End time",
            "limit": "Result limit"
        },
        "nl": "Invoke TCR8 plugin to execute a specific query"
    },
    {
        "query_id": "read9",
        "query_type": "account-loan-transfer-ratio",
        "query_template": "MATCH (mid:Account {id:%d}) WITH mid OPTIONAL MATCH (mid)-[edge2:repay]->(loan:Loan) WHERE edge2.amount > %f AND edge2.timestamp > %d AND edge2.timestamp < %d WITH mid, sum(edge2.amount) AS edge2Amount OPTIONAL MATCH (mid)<-[edge1:deposit]-(loan:Loan) WHERE edge1.amount > %f AND edge1.timestamp > %d AND edge1.timestamp < %d WITH mid, sum(edge1.amount) AS edge1Amount, edge2Amount OPTIONAL MATCH (mid)-[edge4:transfer]->(down:Account) WHERE edge4.amount > %f AND edge4.timestamp > %d AND edge4.timestamp < %d WITH mid, edge1Amount, edge2Amount, sum(edge4.amount) AS edge4Amount OPTIONAL MATCH (mid)<-[edge3:transfer]-(up:Account) WHERE edge3.amount > %f AND edge3.timestamp > %d AND edge3.timestamp < %d WITH edge1Amount, edge2Amount, sum(edge3.amount) AS edge3Amount, edge4Amount RETURN CASE WHEN edge2Amount=0 THEN -1 ELSE round(1000.0 * edge1Amount / edge2Amount) / 1000 END AS ratioRepay, CASE WHEN edge4Amount=0 THEN -1 ELSE round(1000.0 * edge1Amount / edge4Amount) / 1000 END AS ratioDeposit, CASE WHEN edge4Amount=0 THEN -1 ELSE round(1000.0 * edge3Amount / edge4Amount) / 1000 END AS ratioTransfer;",
        "query_parameters": {
            "account_id": "Account ID",
            "repay_amount_threshold": "Repayment amount threshold",
            "repay_start_time": "Repayment start time",
            "repay_end_time": "Repayment end time",
            "deposit_amount_threshold": "Deposit amount threshold",
            "deposit_start_time": "Deposit start time",
            "deposit_end_time": "Deposit end time",
            "out_transfer_amount_threshold": "Outgoing transfer amount threshold",
            "out_transfer_start_time": "Outgoing transfer start time",
            "out_transfer_end_time": "Outgoing transfer end time",
            "in_transfer_amount_threshold": "Incoming transfer amount threshold",
            "in_transfer_start_time": "Incoming transfer start time",
            "in_transfer_end_time": "Incoming transfer end time"
        },
        "nl": "Calculate the loan deposit/repayment ratio, deposit/outgoing transfer ratio, and incoming/outgoing transfer ratio for a specified account"
    },
    {
        "query_id": "read10",
        "query_type": "person-investment-jaccard-similarity",
        "query_template": "OPTIONAL MATCH (p1:Person {id:%d})-[edge1:invest]->(m1:Company) WHERE edge1.timestamp > %d AND edge1.timestamp < %d WITH collect(distinct id(m1)) as m1_vids OPTIONAL MATCH (p2:Person {id:%d})-[edge2:invest]->(m2:Company) WHERE edge2.timestamp > %d AND edge2.timestamp < %d WITH collect(distinct id(m2)) as m2_vids, m1_vids CALL algo.jaccard(m1_vids, m2_vids) YIELD similarity RETURN CASE WHEN similarity = null THEN 0 ELSE round(similarity*1000)/1000 END AS similarity;",
        "query_parameters": {
            "person1_id": "Person 1 ID",
            "p1_invest_start_time": "Person 1 investment start time",
            "p1_invest_end_time": "Person 1 investment end time",
            "person2_id": "Person 2 ID",
            "p2_invest_start_time": "Person 2 investment start time",
            "p2_invest_end_time": "Person 2 investment end time"
        },
        "nl": "Calculate the Jaccard similarity of companies invested by two persons within specified time windows"
    },
    {
        "query_id": "read11",
        "query_type": "guarantee-chain-loan-stats",
        "query_template": "OPTIONAL MATCH (p1:Person {id:%d})-[edge:guarantee*1..5]->(pN:Person) -[:apply]->(loan:Loan) WHERE minInList(getMemberProp(edge, 'timestamp')) > %d AND maxInList(getMemberProp(edge, 'timestamp')) < %d WITH DISTINCT loan WITH sum(loan.loanAmount) as sumLoanAmount, count(distinct loan) as numLoans RETURN round(sumLoanAmount * 1000) / 1000 as sumLoanAmount, numLoans;",
        "query_parameters": {
            "person_id": "Person ID",
            "guarantee_start_time": "Guarantee start time",
            "guarantee_end_time": "Guarantee end time"
        },
        "nl": "From a given person, traverse 1-5 step guarantee chains to find applied loans, aggregate total loan amount and count"
    },
    {
        "query_id": "read12",
        "query_type": "person-to-company-transfer-stats",
        "query_template": "MATCH (person:Person {id:%d})-[edge1:own]->(pAcc:Account) -[edge2:transfer]->(compAcc:Account) <-[edge3:own]-(com:Company) WHERE edge2.timestamp > %d AND edge2.timestamp < %d WITH compAcc.id AS compAccountId, sum(edge2.amount) AS sumEdge2Amount RETURN compAccountId, round(sumEdge2Amount * 1000) / 1000 as sumEdge2Amount ORDER BY sumEdge2Amount DESC;",
        "query_parameters": {
            "person_id": "Person ID",
            "transfer_start_time": "Transfer start time",
            "transfer_end_time": "Transfer end time"
        },
        "nl": "Find transfers from accounts owned by a given person to company accounts, aggregate transfer amounts per company account and sort in descending order"
    },
    {
        "query_id": "simple_read1",
        "query_type": "account-basic-info",
        "query_template": "MATCH (n:Account{id:%d}) RETURN n.createTime as createTime, n.isBlocked as isBlocked, n.type as type;",
        "query_parameters": {
            "account_id": "Account ID"
        },
        "nl": "Query basic information of a specified account: creation time, blocked status, and account type"
    },
    {
        "query_id": "simple_read2",
        "query_type": "account-transfer-stats",
        "query_template": "MATCH (n:Account{id:%d}) WITH n OPTIONAL MATCH (n)-[e:transfer]->(m:Account) WHERE e.timestamp > %d AND e.timestamp < %d WITH n, sum(e.amount) as sumEdge1Amount, max(e.amount) as maxEdge1Amount, count(e) as numEdge1 OPTIONAL MATCH (n)<-[e:transfer]-(m:Account) WHERE e.timestamp > %d AND e.timestamp < %d WITH sumEdge1Amount, maxEdge1Amount, numEdge1, sum(e.amount) as sumEdge2Amount, max(e.amount) as maxEdge2Amount, count(e) as numEdge2 RETURN round(sumEdge1Amount * 1000) / 1000 as sumEdge1Amount, CASE WHEN maxEdge1Amount < 0 THEN -1 ELSE round(maxEdge1Amount * 1000) / 1000 END as maxEdge1Amount, numEdge1, round(sumEdge2Amount * 1000) / 1000 as sumEdge2Amount, CASE WHEN maxEdge2Amount < 0 THEN -1 ELSE round(maxEdge2Amount * 1000) / 1000 END as maxEdge2Amount, numEdge2;",
        "query_parameters": {
            "account_id": "Account ID",
            "out_start_time": "Outgoing transfer start time",
            "out_end_time": "Outgoing transfer end time",
            "in_start_time": "Incoming transfer start time",
            "in_end_time": "Incoming transfer end time"
        },
        "nl": "Compute incoming and outgoing transfer statistics for a specified account within time windows: total amount, max amount, and transfer count"
    },
    {
        "query_id": "simple_read3",
        "query_type": "blocked-account-transfer-ratio",
        "query_template": "OPTIONAL MATCH (n:Account{id:%d})<-[e:transfer]-(m:Account) WHERE e.amount > %f AND e.timestamp > %d AND e.timestamp < %d AND m.isBlocked=true WITH count(m) * 1.0 as numM OPTIONAL MATCH (n:Account{id:%d})<-[e:transfer]-(m:Account) WITH count(m) as numIn, numM RETURN CASE WHEN numIn = 0 THEN -1 ELSE round(numM / numIn * 1000) / 1000 END as blockRatio;",
        "query_parameters": {
            "account_id_1": "Account ID (first query)",
            "amount_threshold": "Amount threshold",
            "transfer_start_time": "Transfer start time",
            "transfer_end_time": "Transfer end time",
            "account_id_2": "Account ID (second query)"
        },
        "nl": "Calculate the ratio of blocked accounts among all accounts that transferred to the specified account (blocked account count / total incoming account count)"
    }
]

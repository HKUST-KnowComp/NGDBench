[
  {
    "query": "MATCH (a:Company) RETURN min(a.city) AS min_value",
    "answer": "Aachen",
    "is_noise_query": true,
    "nlp": "Return the city that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.companyName) AS max_value",
    "answer": "Zulauf LLC",
    "is_noise_query": true,
    "nlp": "Find the company name that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (n:Company) WHERE (n)-[:Medium_SignIn_Account]->(:Company) OR (n)-[:Company_Invest_Company]->(:Company) RETURN count(n) AS cnt",
    "answer": 918,
    "is_noise_query": true,
    "nlp": "Count the number of companies that either sign in through a medium or invest in another company."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Company) OR (n)-[:Company_Invest_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not withdraw accounts or invest in other companies."
  },
  {
    "query": "MATCH p = (a:Company)-[:Company_Guarantee_Company *1..3]-(b:Company) RETURN avg(length(p)) AS avg_len",
    "answer": 2.051606108478143,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between companies connected by up to three \"guarantee\" relationships."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.url LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:10995116278493",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:10995116277886",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:2199023255954",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:2199023255711",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:3298534883592",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:2199023255994",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:9895604650630",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093022926",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093023119",
        "b": "Company:4398046511515"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the first 10 companies alphabetically by URL and the first 10 companies alphabetically by company name, then return all unique pairs of these companies."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.description MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.description RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies, where both companies are ordered by their descriptions."
  },
  {
    "query": "MATCH (a:Company {isBlocked: '14293651161116'})-[:Company_Apply_Loan]->(b:Company) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Company) WHERE c.city = '14293651161116' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count companies that have been blocked, apply for loans, and invest in other companies located in a specific city."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business <> '14293651161116' WITH a ORDER BY a.description RETURN collect(a.description)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the descriptions of companies with a specific business type, ordered by description, and return the first 32 descriptions."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Invest_Company]->(:Company) OR (a)-[:Account_Withdraw_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have investments from people or have withdrawals."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Company) OR (a)-[:Account_Withdraw_Account]->(:Company) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 12:37:50.617",
      "2020-01-02 09:25:17.229",
      "2020-01-03 13:22:12.950",
      "2020-01-03 22:15:35.750",
      "2020-01-04 12:33:55.491",
      "2020-01-05 00:56:57.284",
      "2020-01-06 13:18:44.184",
      "2020-01-07 09:29:02.368",
      "2020-01-09 05:12:29.209",
      "2020-01-09 05:37:34.069",
      "2020-01-09 18:53:10.197",
      "2020-01-12 00:23:45.776",
      "2020-01-13 18:54:25.370",
      "2020-01-16 10:17:25.141",
      "2020-01-16 16:50:43.225",
      "2020-01-18 20:35:09.946",
      "2020-01-19 10:26:13.409",
      "2020-01-21 22:59:58.120",
      "2020-01-23 04:52:42.781",
      "2020-01-24 16:00:55.899",
      "2020-01-30 06:46:05.619",
      "2020-01-31 12:16:50.346",
      "2020-02-01 03:57:09.713",
      "2020-02-01 19:11:26.128",
      "2020-02-02 10:04:06.081",
      "2020-02-04 03:31:16.685",
      "2020-02-05 19:25:53.688",
      "2020-02-06 14:23:04.501",
      "2020-02-08 01:33:02.161",
      "2020-02-08 12:37:26.585",
      "2020-02-10 07:20:16.544",
      "2020-02-11 13:59:40.625"
    ],
    "is_noise_query": true,
    "nlp": "Collect the creation times of companies that either do not have outgoing Person_Guarantee_Person relationships or have outgoing Account_Withdraw_Account relationships, ordered by creation time, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Company) RETURN count(b.isBlocked) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Return the union of two counts of blocked statuses of companies."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts' creation times."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the nicknames of accounts that repay loans, ordered by nickname, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Repay_Loan]->(:Account) OR (n)-[:Account_Repay_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count all accounts, as the condition includes every account whether they repay loans or not."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:253327479039591558",
        "b": "Account:4896820169835283571"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285134151407895618"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4896820169835282675"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4896820169835284218"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285415626384607208"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 accounts by email address and then, within those top 10, find the top 10 accounts by account level, returning both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the first account is ordered by blocked status and the second by login frequency."
  },
  {
    "query": "MATCH (a:Account), (b:Account) WHERE a.phonenum = b.phonenum AND a <> b RETURN count(*) AS cnt",
    "answer": 3492,
    "is_noise_query": true,
    "nlp": "Count duplicate accounts based on phone number, excluding self-references."
  },
  {
    "query": "MATCH (a:Account {createTime: '4884435270860014837'})-[:Account_Transfer_Account]->(b:Account) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Account) WHERE c.freqLoginType = '4884435270860014837' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of transfers for accounts with specific transfer details, where the final account has a particular login frequency type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel CONTAINS '4884435270860014837' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have the specific account level '4884435270860014837'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel <> '4884435270860014837' WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 unique login types of accounts that have the specific account level '4884435270860014837', ordered by their login frequency."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have any outgoing Company_Own_Account relationships or have an outgoing Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 unique login types of accounts that either do not have an outgoing Person_Apply_Loan relationship or have an outgoing Company_Apply_Loan relationship, ordered by their login frequency."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.nickname) AS cnt UNION MATCH (b:Account) RETURN count(b.nickname) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "This query seems incorrect. It appears to be attempting to count nicknames from two separate matches, but using UNION without aggregation might not produce the expected result. A clearer intent is needed."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountLevel) AS min_value",
    "answer": "Basic level",
    "is_noise_query": true,
    "nlp": "Return the account level that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the account level that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the top 32 emails of accounts that have an outgoing Account_Withdraw_Account relationship, ordered by email."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Apply_Loan]->(:Account) OR (n)-[:Medium_SignIn_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have an outgoing Person_Apply_Loan relationship or have an outgoing Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285134151407895701",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4896820169835284135",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:285134151407894843",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4896820169835282970",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:285134151407895618",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4896820169835282675",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:285415626384607208",
        "b": "Account:4503599627371623"
      }
    ],
    "is_noise_query": true,
    "nlp": "This query is complex and potentially confusing. It selects 10 accounts with the lowest account levels, then selects another set of 10 accounts based on account IDs from the first set, and returns both sets. The intent could be clearer."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the first account's level is higher than the second, ordered by the second account's creation time."
  },
  {
    "query": "MATCH (a:Account {accountType: '4870924471977902271'})-[:Person_Own_Account]->(b:Account) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Account) WHERE c.freqLoginType = '4870924471977902271' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Return the count of accounts where a person with an account type '4870924471977902271' owns another account, and that owned account has investments in other accounts with the same frequency login type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel ENDS WITH '4870924471977902271' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 email addresses of accounts whose account level does not end with '4870924471977902271', ordered by their email addresses."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have any outgoing Account Transfer relationships or have an incoming Company Apply Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account levels of accounts that do not own other accounts or guarantee other accounts, ordered by their account levels."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountLevel) AS cnt UNION MATCH (b:Account) RETURN count(b.accountLevel) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Combine counts of account levels from two separate sets of accounts."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.city) AS min_value",
    "answer": "Aachen",
    "is_noise_query": true,
    "nlp": "Return the city name that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the highest isBlocked value among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Own_Account]->(:Company) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 creation times of companies that own other companies, ordered by their creation times."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Company_Invest_Company]->(:Company) OR (n)-[:Person_Apply_Loan]->(:Company) RETURN count(n)",
    "answer": 50,
    "is_noise_query": true,
    "nlp": "Count companies that do not invest in other companies or have had a person apply for a loan on their behalf."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:584",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:807",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:43",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:344",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:641",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:538",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:599",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:595",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:237",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:423",
        "b": "Company:4398046511515"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the 10 companies with the lowest blocked status, then among those, find the 10 companies with the earliest company names."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.business RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies where the first company's business is not equal to the second's, ordered by the second company's business."
  },
  {
    "query": "MATCH (a:Company {city: '6597069766902'})-[:Account_Withdraw_Account]->(b:Company) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Company) WHERE c.country = '6597069766902' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of companies that have withdrawn accounts in a specific city and are guaranteed by another company in the same country."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business = '6597069766902' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies whose business does not match a specific identifier."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.isBlocked ENDS WITH '6597069766902' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the blocked statuses of companies that do not end with a specific identifier, ordered by their blocked status, and return the first 32."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Company) OR (a)-[:Company_Guarantee_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not sign in through a medium or are guaranteed by another company."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Own_Account]->(:Company) OR (a)-[:Person_Invest_Company]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Return the top 32 company names by name order, where companies either do not own accounts or invest in other companies."
  },
  {
    "query": "MATCH (a:Company)-[:Company_Invest_Company]-()-[:Company_Invest_Company]-(b:Company) WHERE NOT (a)-[:Company_Invest_Company]-(b) WITH b ORDER BY b.city LIMIT 20 RETURN b.city",
    "answer": [
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      },
      {
        "b.city": "Aachen"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find 20 cities where there is an indirect investment relationship between companies but no direct investment relationship, ordered by city."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 18:13:47.158",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all companies."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 12:42:53.558",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all companies."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Guarantee_Person]->(:Person) RETURN count(a) AS cnt",
    "answer": 511,
    "is_noise_query": true,
    "nlp": "Count the number of people who have at least one person they guarantee."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Loan_Deposit_Account]->(:Person) WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Count the number of people and return their birthdays sorted by date, limiting the result to the first 32 distinct birthdays."
  },
  {
    "query": "MATCH (n:Person) WHERE (n)-[:Person_Guarantee_Person]->(:Person) OR (n)-[:Account_Repay_Loan]->(:Person) RETURN count(n) AS cnt",
    "answer": 511,
    "is_noise_query": true,
    "nlp": "Count the number of people who either guarantee another person or repay a loan for another person."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Apply_Loan]->(:Person) OR (n)-[:Person_Own_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people who either do not apply for a loan or own an account."
  },
  {
    "query": "MATCH p = (a:Person)-[:Person_Guarantee_Person *1..4]-(b:Person) RETURN avg(length(p)) AS avg_len",
    "answer": 2.7075225094394364,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between two people where one guarantees the other, with path lengths ranging from 1 to 4 relationships."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:808",
        "b": "Person:4"
      },
      {
        "a": "Person:51",
        "b": "Person:4"
      },
      {
        "a": "Person:310",
        "b": "Person:4"
      },
      {
        "a": "Person:640",
        "b": "Person:4"
      },
      {
        "a": "Person:982",
        "b": "Person:4"
      },
      {
        "a": "Person:630",
        "b": "Person:4"
      },
      {
        "a": "Person:41",
        "b": "Person:4"
      },
      {
        "a": "Person:729",
        "b": "Person:4"
      },
      {
        "a": "Person:985",
        "b": "Person:4"
      },
      {
        "a": "Person:755",
        "b": "Person:4"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 unblocked persons and then find the top 10 persons ordered by person ID among them, returning both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.city MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.gender RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count the number of unique person pairs where the first person is ordered by city and the second person is ordered by gender, excluding pairs where both individuals are the same."
  },
  {
    "query": "MATCH (a:Person {country: '4398046512080'})-[:Person_Guarantee_Person]->(b:Person) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Person) WHERE c.gender = '4398046512080' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of people who are guaranteed by someone from country '4398046512080' and have a medium sign-in account with a gender matching '4398046512080'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.city ENDS WITH '4398046512080' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people whose city does not end with '4398046512080'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.birthday ENDS WITH '4398046512080' WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS vals",
    "answer": [
      "1980-01-08",
      "1980-01-18",
      "1980-01-21",
      "1980-01-23",
      "1980-01-29",
      "1980-02-02",
      "1980-02-04",
      "1980-02-06",
      "1980-03-11",
      "1980-03-19",
      "1980-03-19",
      "1980-03-21",
      "1980-03-31",
      "1980-04-09",
      "1980-04-13",
      "1980-04-13",
      "1980-04-15",
      "1980-04-15",
      "1980-04-20",
      "1980-04-21",
      "1980-05-22",
      "1980-06-19",
      "1980-06-19",
      "1980-06-27",
      "1980-07-14",
      "1980-07-17",
      "1980-07-27",
      "1980-08-02",
      "1980-08-11",
      "1980-08-15",
      "1980-08-18",
      "1980-08-22"
    ],
    "is_noise_query": true,
    "nlp": "Exclude persons with a specific birthday ending '4398046512080', sort the remaining persons by birthday, and return the first 32 distinct birthdays."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Own_Account]->(:Person) OR (a)-[:Company_Guarantee_Company]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count persons who do not own an account or are involved in company guarantees."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Invest_Company]->(:Person) OR (a)-[:Person_Own_Account]->(:Person) WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS vals",
    "answer": [
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 genders of persons who either do not invest in companies or own accounts, ordered by gender."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.email) AS max_value",
    "answer": "zoho.com",
    "is_noise_query": true,
    "nlp": "Find the email that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve the first 32 creation times of accounts involved in loan deposits, ordered by creation time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Loan_Deposit_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not transfer funds to another account or are involved in loan deposits."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account *2..3]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3200,
    "is_noise_query": true,
    "nlp": "Count unique accounts where there is a path of 2 to 3 \"Person_Own_Account\" relationships between them."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4856850723142369842",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:258394028620382770",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:213920982300098729",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4885842645743567017",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:273312202386047344",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of distinct accounts: first select the top 10 accounts ordered by phone number, then from those, select the top 10 accounts ordered by last login time."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different accounts, ordered by phone number and last login time."
  },
  {
    "query": "MATCH (a:Account {lastLoginTime: '4903575569276339922'})-[:Company_Guarantee_Company]->(b:Account) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Account) WHERE c.lastLoginTime = '4903575569276339922' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections involving specific loans through company guarantees and applications, with matching conditions on last login time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType = '4903575569276339922' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the frequency login type does not match the specific value '4903575569276339922'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType STARTS WITH '4903575569276339922' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 emails of accounts where the frequency login type does not start with '4903575569276339922', ordered by email address."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a relationship where they apply for a loan or have a relationship where they withdraw from another account."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 frequency login types of accounts that do not have a relationship where they invest in a company or own an account, ordered by frequency login type."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountLevel) AS cnt UNION MATCH (b:Account) RETURN count(b.accountLevel) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Combine counts of distinct account levels from a single set of accounts, effectively doubling the count due to the union of identical queries."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account]-()-[:Company_Own_Account]-(b:Account) WHERE NOT (a)-[:Company_Own_Account]-(b) WITH b ORDER BY b.accountId LIMIT 20 RETURN b.accountId",
    "answer": [
      {
        "b.accountId": 4503599627371623
      },
      {
        "b.accountId": 4503599627371623
      },
      {
        "b.accountId": 4503599627371623
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163943
      },
      {
        "b.accountId": 9570149208163943
      },
      {
        "b.accountId": 9570149208163943
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 20266198323168013
      },
      {
        "b.accountId": 20266198323168013
      },
      {
        "b.accountId": 20547673299879219
      },
      {
        "b.accountId": 20547673299879219
      },
      {
        "b.accountId": 20547673299879219
      },
      {
        "b.accountId": 23080948090274944
      },
      {
        "b.accountId": 25895697857381261
      },
      {
        "b.accountId": 25895697857381261
      },
      {
        "b.accountId": 25895697857381261
      },
      {
        "b.accountId": 26740122787514064
      }
    ],
    "is_noise_query": true,
    "nlp": "Find unique accounts where there is a path of 1 to 5 \"Company_Own_Account\" relationships between them, excluding direct links, and return the top 20 account IDs based on order by accountId."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.balance) AS avg_value",
    "answer": 25806019.535552666,
    "is_noise_query": true,
    "nlp": "Calculate the average balance of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.loanAmount) AS total_value",
    "answer": 112187006902.0,
    "is_noise_query": true,
    "nlp": "Sum up the total loan amount across all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanAmount) AS min_value",
    "answer": 88778.0,
    "is_noise_query": true,
    "nlp": "Find the minimum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanUsage) AS max_value",
    "answer": "weddings",
    "is_noise_query": true,
    "nlp": "Find the maximum loan usage value among all loans, considering alphabetical order for string values."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Loan_Deposit_Account]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve the first 32 loan usages of loans that have a \"Loan_Deposit_Account\" relationship, ordered by loan usage."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Account_Transfer_Account]->(:Loan) OR (n)-[:Company_Apply_Loan]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not transfer to another loan or are involved in company loan applications."
  },
  {
    "query": "MATCH (a:Loan)-[:Company_Apply_Loan *1..5]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 2004,
    "is_noise_query": true,
    "nlp": "Count unique loans where there is a path of 1 to 5 \"Company_Apply_Loan\" relationships between them."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:143833713099145499",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4802807527613924326",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4759460381200482587",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:123848989752689515",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:217298682020626503",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4889501820440805670",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4894568370021597389",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4890627720347648427",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4894849844998307888",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of loans, first 10 ordered by interest rate, then for each of these 10, the next 10 ordered by creation time."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans where the loan amount is different, ordered by the interest rate of the second loan."
  },
  {
    "query": "MATCH (a:Loan {balance: '4906671794020155604'})-[:Account_Withdraw_Account]->(b:Loan) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Loan) WHERE c.balance = '4906671794020155604' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where there is a withdrawal account relationship and a subsequent person application relationship, both with a specific balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance = '4906671794020155604' WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 loan amounts of loans where the balance does not match '4906671794020155604', ordered by loan amount."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Collect the first 32 loan usages of loans that do not guarantee a person or own an account, ordered by loan usage."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS vals",
    "answer": [
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 loan usages of loans that do not guarantee a person or own an account, ordered by loan usage."
  },
  {
    "query": "MATCH (a:Loan) RETURN count(a.createTime) AS cnt UNION MATCH (b:Loan) RETURN count(b.createTime) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Combine counts of creation times from two separate sets of loans."
  },
  {
    "query": "MATCH (a:Loan)-[:Company_Apply_Loan]-()-[:Company_Apply_Loan]-(b:Loan) WHERE NOT (a)-[:Company_Apply_Loan]-(b) WITH b ORDER BY b.loanAmount LIMIT 20 RETURN b.loanAmount",
    "answer": [
      {
        "b.loanAmount": 88778.0
      },
      {
        "b.loanAmount": 88778.0
      },
      {
        "b.loanAmount": 88778.0
      },
      {
        "b.loanAmount": 156301.0
      },
      {
        "b.loanAmount": 166473.0
      },
      {
        "b.loanAmount": 166473.0
      },
      {
        "b.loanAmount": 166473.0
      },
      {
        "b.loanAmount": 251290.0
      },
      {
        "b.loanAmount": 312267.0
      },
      {
        "b.loanAmount": 312267.0
      },
      {
        "b.loanAmount": 312267.0
      },
      {
        "b.loanAmount": 355342.0
      },
      {
        "b.loanAmount": 363826.0
      },
      {
        "b.loanAmount": 363826.0
      },
      {
        "b.loanAmount": 456276.0
      },
      {
        "b.loanAmount": 456276.0
      },
      {
        "b.loanAmount": 456276.0
      },
      {
        "b.loanAmount": 567068.0
      },
      {
        "b.loanAmount": 627637.0
      },
      {
        "b.loanAmount": 627637.0
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the loan amounts of loans where there is no direct Company_Apply_Loan relationship between them, ordered by loan amount, and return the top 20."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.phonenum) AS max_value",
    "answer": "999-9198",
    "is_noise_query": true,
    "nlp": "Find the phone number that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 phone numbers of accounts that have been involved in an Account_Transfer_Account transaction, ordered by phone number."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not guarantee a company or are involved in loan applications."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account *1..5]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3184,
    "is_noise_query": true,
    "nlp": "Return pairs of accounts, first 10 ordered by creation time, then 10 from each ordered by last login time."
  },
  {
    "query": "MATCH p = (a:Account)-[:Account_Repay_Loan *1..5]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.710688986148102,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different accounts, ordered by email and nickname."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:20266198323168013",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:20547673299879219",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:14918173765665963",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4631952216750555239",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4617596992938311786",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4632796641680687311",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Count connections involving specific accounts through repayments, with matching conditions on account type."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Collect the first 32 creation times of accounts where the email does not contain a specific value, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account {nickname: '4885842645743567845'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Account) WHERE c.lastLoginTime = '4885842645743567845' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count accounts that do not own a person or own a company."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname <> '4885842645743567845' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 emails of accounts with the nickname '4885842645743567845', ordered by email."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that either have no outgoing \"Person_Invest_Company\" relationships or have incoming \"Person_Guarantee_Person\" relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Invest_Company]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 frequency login types of accounts that do not have outgoing \"Company_Invest_Company\" relationships or have incoming \"Company_Own_Account\" relationships, ordered by frequency login type."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.email) AS cnt UNION MATCH (b:Account) RETURN count(b.email) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the union of two counts: the number of emails and the number of accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account]-()-[:Person_Own_Account]-(b:Account) WHERE NOT (a)-[:Person_Own_Account]-(b) WITH b ORDER BY b.accountType LIMIT 20 RETURN b.accountType",
    "answer": [
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the account types of 20 accounts where there exists an indirect \"Person_Own_Account\" relationship but not a direct one, ordered by account type."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 account levels of accounts that have outgoing \"Person_Apply_Loan\" relationships, ordered by account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that either do not have outgoing \"Company_Guarantee_Company\" relationships or have incoming \"Company_Apply_Loan\" relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4856850723142369842",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:258394028620382770",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:213920982300098729",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4885842645743567017",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:273312202386047344",
        "b": "Account:4503599627371623"
      }
    ],
    "is_noise_query": true,
    "nlp": "Match the top 10 accounts with the lowest phone numbers, then match the top 10 accounts with the lowest account IDs, and return these pairs of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.nickname RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the count of pairs of accounts where the first account is not blocked and the second account's nickname is ordered alphabetically, excluding self-pairing."
  },
  {
    "query": "MATCH (a:Account {accountType: '4808437027148137844'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Account) WHERE c.accountLevel = '4808437027148137844' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that have both invested in another account with an account type '4808437027148137844' and have a person who has invested in them, where the person's account level is '4808437027148137844'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime ENDS WITH '4808437027148137844' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of accounts whose creation time does not end with '4808437027148137844'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email CONTAINS '4808437027148137844' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect the creation times of up to 32 accounts that do not contain '4808437027148137844' in their email address, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of accounts that either do not have any outgoing Person_Own_Account relationships or have at least one Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 email addresses of accounts that do not have any outgoing Company_Guarantee_Company relationships or have at least one Medium_SignIn_Account relationship, ordered by email."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.accountId LIMIT 20 RETURN b.accountId",
    "answer": [
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 23080948090274944
      },
      {
        "b.accountId": 27584547717644507
      },
      {
        "b.accountId": 27584547717644507
      },
      {
        "b.accountId": 27584547717644507
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the account IDs of up to 20 accounts that are connected through a Loan_Deposit_Account path but are not directly connected via a Loan_Deposit_Account relationship, ordered by account ID."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.gender) AS min_value",
    "answer": "female",
    "is_noise_query": true,
    "nlp": "Return the gender that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Guarantee_Person]->(:Person) WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS values",
    "answer": [
      "1980-01-08",
      "1980-01-18",
      "1980-01-29",
      "1980-02-04",
      "1980-02-06",
      "1980-03-11",
      "1980-03-19",
      "1980-03-21",
      "1980-03-31",
      "1980-04-13",
      "1980-04-15",
      "1980-06-19",
      "1980-08-02",
      "1980-08-15",
      "1980-08-18",
      "1980-08-22",
      "1980-09-03",
      "1980-09-22",
      "1980-09-29",
      "1980-10-07",
      "1980-10-25",
      "1980-11-09",
      "1980-11-30",
      "1980-12-05",
      "1981-01-03",
      "1981-01-30",
      "1981-02-17",
      "1981-02-22",
      "1981-05-13",
      "1981-05-27",
      "1981-05-27",
      "1981-05-30"
    ],
    "is_noise_query": true,
    "nlp": "Find the birthdays of people who have guaranteed other people, ordered by their birthday, and return the first 32."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Person) OR (n)-[:Person_Own_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people who neither guarantee a company nor own an account."
  },
  {
    "query": "MATCH p = (a:Person)-[:Person_Guarantee_Person *2..3]-(b:Person) RETURN avg(length(p)) AS avg_len",
    "answer": 2.5352769679300278,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths where there are exactly two or three relationships of person guaranteeing another person between two people."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personId LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.gender LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:4",
        "b": "Person:315"
      },
      {
        "a": "Person:4",
        "b": "Person:535"
      },
      {
        "a": "Person:4",
        "b": "Person:107"
      },
      {
        "a": "Person:4",
        "b": "Person:24"
      },
      {
        "a": "Person:4",
        "b": "Person:729"
      },
      {
        "a": "Person:4",
        "b": "Person:467"
      },
      {
        "a": "Person:4",
        "b": "Person:808"
      },
      {
        "a": "Person:4",
        "b": "Person:982"
      },
      {
        "a": "Person:4",
        "b": "Person:41"
      },
      {
        "a": "Person:4",
        "b": "Person:675"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top ten people with the lowest person IDs, then from those, select the top ten people with the lowest gender values, and return both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personName MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.city RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different people, first ordered by name and then by city within each name group."
  },
  {
    "query": "MATCH (a:Person {createTime: '6597069767376'})-[:Loan_Deposit_Account]->(b:Person) WITH b MATCH (b)-[:Account_Repay_Loan]->(c:Person) WHERE c.isBlocked = '6597069767376' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where the borrower was created at a specific timestamp and the lender is blocked, based on a specific blocked ID."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.birthday STARTS WITH '6597069767376' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people whose birthdays do not start with a specific code."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country STARTS WITH '6597069767376' WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belgium"
    ],
    "is_noise_query": true,
    "nlp": "Collect countries of people whose country names do not start with a specific code, ordered by country name, and return up to 32 distinct country names."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Invest_Company]->(:Person) OR (a)-[:Company_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people who either do not invest in a company or own an account."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Person) OR (a)-[:Account_Withdraw_Account]->(:Person) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belgium"
    ],
    "is_noise_query": true,
    "nlp": "Collect countries of people who do not guarantee a company or withdraw an account, ordered by country, and return up to 32 distinct country names."
  },
  {
    "query": "MATCH (a:Person) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Person) RETURN count(b.isBlocked) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of blocked statuses of all people."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.balance) AS avg_value",
    "answer": 25806019.535552666,
    "is_noise_query": true,
    "nlp": "Calculate the average balance of loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.balance) AS total_value",
    "answer": 59302232892.69993,
    "is_noise_query": true,
    "nlp": "Sum the balances of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.createTime) AS min_value",
    "answer": "2020-02-15 04:08:32.798",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanAmount) AS max_value",
    "answer": 99999435.0,
    "is_noise_query": true,
    "nlp": "Find the maximum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Account_Repay_Loan]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 loan amounts of loans that have been repaid through an account repayment relationship, ordered by loan amount."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Company_Apply_Loan]->(:Loan) OR (n)-[:Person_Invest_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not apply for a company loan or are involved in a person-invested company relationship."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.interestRate LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4866420872350532459"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4894568370021597389"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4759460381200482587"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:217298682020626503"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4889501820440805670"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4890627720347648427"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:123848989752689515"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:143833713099145499"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4802807527613924326"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4894849844998307888"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select ten loans with the lowest balance, then from those, select ten loans with the lowest interest rate and return both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanUsage MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different loans, first ordered by their usage, then by their interest rate."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.interestRate = b.interestRate AND a <> b RETURN count(*) AS cnt",
    "answer": 54390,
    "is_noise_query": true,
    "nlp": "Count pairs of loans with the same interest rate."
  },
  {
    "query": "MATCH (a:Loan {interestRate: '4886124120720278500'})-[:Medium_SignIn_Account]->(b:Loan) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Loan) WHERE c.interestRate = '4886124120720278500' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where a loan with a specific interest rate is involved in a medium sign-in account relationship, and the related loan also has a company guarantee relationship with the same interest rate."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.interestRate STARTS WITH '4886124120720278500' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect interest rates of loans that do not start with the specific code '4886124120720278500', ordered by interest rate, and return up to 32 values."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Own_Account]->(:Loan) OR (a)-[:Company_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have a relationship where they own a company account or do have such a relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Apply_Loan]->(:Loan) OR (a)-[:Person_Guarantee_Person]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Collect loan amounts of loans that do not apply for a company loan or are guaranteed by a person, ordered by loan amount, and return up to 32 values."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.interestRate) AS avg_value",
    "answer": 0.05062750217580504,
    "is_noise_query": true,
    "nlp": "Calculate the average interest rate of loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.balance) AS total_value",
    "answer": 59302232892.69993,
    "is_noise_query": true,
    "nlp": "Sum the balances of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanUsage) AS min_value",
    "answer": "business ventures",
    "is_noise_query": true,
    "nlp": "Return the earliest alphabetical loan usage among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanUsage) AS max_value",
    "answer": "weddings",
    "is_noise_query": true,
    "nlp": "Find the latest alphabetical loan usage among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Own_Account]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 loan amounts of loans where a person owns an account, ordered by loan amount."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Account_Repay_Loan]->(:Loan) OR (n)-[:Medium_SignIn_Account]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not repay another loan through an account relationship or are signed into via a medium relationship."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanAmount LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:217298682020626503",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4889501820440805670",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4894568370021597389",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4759460381200482587",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4759460381200482587",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:217298682020626503",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4894568370021597389",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4889501820440805670",
        "b": "Loan:4907797693926998719"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the ten loans with the lowest interest rate, then from those, select the ten loans with the lowest loan amount, and return both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.loanAmount RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans, ordered by their loan amounts, and return the number of such pairs."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.loanAmount = b.balance AND a <> b RETURN count(*) AS cnt",
    "answer": 54,
    "is_noise_query": true,
    "nlp": "Count pairs of loans where the loan amount of one loan matches the balance of another loan, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Loan {interestRate: '4838836324632888094'})-[:Company_Own_Account]->(b:Loan) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Loan) WHERE c.balance = '4838836324632888094' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where the borrower has a specific interest rate and is connected through a \"Company_Own_Account\" relationship to another loan, and where there exists a \"Person_Guarantee_Person\" relationship leading to a loan with a matching balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage CONTAINS '4838836324632888094' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans whose loan usage does not include a specific code."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime ENDS WITH '4838836324632888094' WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Collect the loan amounts of loans whose creation time does not end with a specific code, order them by loan amount, and return up to 32 values."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Own_Account]->(:Loan) OR (a)-[:Medium_SignIn_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not own a company account or are linked via a \"Medium_SignIn_Account\" relationship to another loan."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Apply_Loan]->(:Loan) OR (a)-[:Loan_Deposit_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect the interest rates of loans that do not apply for a company loan or are linked via a \"Loan_Deposit_Account\" relationship to another loan, order them by interest rate, and return up to 32 values."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the earliest alphabetical account type among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the account types of accounts that have guaranteed another account, order them by account type, and return up to 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Apply_Loan]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a loan application relationship or have an account withdrawal relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountId LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:14918173765665963",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:14918173765665963",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select ten accounts with the lowest account ID, then from those, select ten accounts with the lowest phone number, and return both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts, ordered first by the frequency of login type and then by email."
  },
  {
    "query": "MATCH (a:Account {phonenum: '4827577325564461139'})-[:Account_Transfer_Account]->(b:Account) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Account) WHERE c.lastLoginTime = '4827577325564461139' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts where a borrower with a specific phone number has transferred funds to another account, which in turn has a loan deposit relationship with an account matching the borrower's last login time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel ENDS WITH '4827577325564461139' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose account level does not end with a specific code."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum ENDS WITH '4827577325564461139' WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect nicknames of accounts whose phone number does not end with a specific code, ordered by nickname, and return up to 32."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a guarantee relationship or have a guarantee relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the frequency of login types for accounts that do not repay loans or own accounts, ordered by frequency of login type, and return up to 32."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Account) RETURN count(b.isBlocked) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the blocked status of all accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account]-()-[:Person_Own_Account]-(b:Account) WHERE NOT (a)-[:Person_Own_Account]-(b) WITH b ORDER BY b.nickname LIMIT 20 RETURN b.nickname",
    "answer": [
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Abdul Hirsch"
      },
      {
        "b.nickname": "Abdul Hirsch"
      },
      {
        "b.nickname": "Abdul Hirsch"
      },
      {
        "b.nickname": "Abdul Torigian"
      },
      {
        "b.nickname": "Abdul Torigian"
      },
      {
        "b.nickname": "Adalberto Roghair"
      },
      {
        "b.nickname": "Adalberto Roghair"
      },
      {
        "b.nickname": "Adalberto Roghair"
      },
      {
        "b.nickname": "Adan Meggerson"
      },
      {
        "b.nickname": "Adan Raghunandan"
      },
      {
        "b.nickname": "Adan Raghunandan"
      },
      {
        "b.nickname": "Adelaide Eagy"
      },
      {
        "b.nickname": "Adelaide Eagy"
      },
      {
        "b.nickname": "Adelaide Eagy"
      },
      {
        "b.nickname": "Adelaide Kuliga"
      },
      {
        "b.nickname": "Adelaide Kuliga"
      },
      {
        "b.nickname": "Adelaide Kuliga"
      },
      {
        "b.nickname": "Adolfo Lazo"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find nicknames of accounts that are indirectly connected through person ownership but not directly connected."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.birthday) AS min_value",
    "answer": "1980-01-08",
    "is_noise_query": true,
    "nlp": "Find the earliest birthday among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.gender) AS max_value",
    "answer": "male",
    "is_noise_query": true,
    "nlp": "Find the gender that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Guarantee_Company]->(:Person) WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect names of people who have guaranteed a company, ordered by name, and return up to 32."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Account_Transfer_Account]->(:Person) OR (n)-[:Company_Own_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people who either do not transfer accounts or own a company."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personId LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.gender LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:4",
        "b": "Person:315"
      },
      {
        "a": "Person:4",
        "b": "Person:535"
      },
      {
        "a": "Person:4",
        "b": "Person:107"
      },
      {
        "a": "Person:4",
        "b": "Person:24"
      },
      {
        "a": "Person:4",
        "b": "Person:729"
      },
      {
        "a": "Person:4",
        "b": "Person:467"
      },
      {
        "a": "Person:4",
        "b": "Person:808"
      },
      {
        "a": "Person:4",
        "b": "Person:982"
      },
      {
        "a": "Person:4",
        "b": "Person:41"
      },
      {
        "a": "Person:4",
        "b": "Person:675"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select ten people with the lowest person ID, then from those, select ten people with the lowest gender, and return both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personName MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct people, ordered first by name and then by whether they are blocked, returning the total number of such pairs."
  },
  {
    "query": "MATCH (a:Person {gender: '17592186045291'})-[:Medium_SignIn_Account]->(b:Person) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Person) WHERE c.createTime = '17592186045291' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where a person with a specific gender signs into an account, and the same person withdraws from another account created at a specific time."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.birthday ENDS WITH '17592186045291' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people whose birthday does not end with a specific code."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.personName <> '17592186045291' WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect names of people whose name matches a specific code, ordered by name, and return up to 32."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Repay_Loan]->(:Person) OR (a)-[:Company_Invest_Company]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people who either do not repay loans or invest in companies."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Own_Account]->(:Person) OR (a)-[:Person_Apply_Loan]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Find people who either do not own company accounts or have applied for loans, then return their creation times up to 32."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.city) AS min_value",
    "answer": "Aachen",
    "is_noise_query": true,
    "nlp": "Return the city that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.gender) AS max_value",
    "answer": "male",
    "is_noise_query": true,
    "nlp": "Find the gender that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Invest_Company]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect creation times of people who invest in other people, ordered by time, up to 32."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Person) OR (n)-[:Company_Guarantee_Company]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people, regardless of whether they guarantee companies or not."
  },
  {
    "query": "MATCH p = (a:Person)-[:Person_Guarantee_Person *3..5]-(b:Person) RETURN avg(length(p)) AS avg_len",
    "answer": 4.11280024323502,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths of 3 to 5 relationships connecting two different people."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.birthday LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:310",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:630",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:982",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:729",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:808",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:755",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:640",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:985",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:41",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:51",
        "b": "Person:6597069766722"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 people created earliest and then, from those, the top 10 people with the earliest birthdays."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.personName RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct people, ordered first by creation time and then by name."
  },
  {
    "query": "MATCH (a:Person {city: '10995116278627'})-[:Account_Repay_Loan]->(b:Person) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Person) WHERE c.birthday = '10995116278627' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections where the borrower repays loans and the lender has applied for loans on someone else with a specific birthday."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country = '10995116278627' WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [
      "Aachen",
      "Aachen",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Addis_Ababa",
      "Agadir",
      "Agadir",
      "Ahmedabad",
      "Ahmedpur_Sial",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Al_Hudaydah",
      "Alappuzha",
      "Alashankou",
      "Aligarh",
      "Aligarh",
      "Aligarh",
      "Allahabad",
      "Almaty",
      "Ambon",
      "Ambovombe",
      "Amparafaravola",
      "Amritsar",
      "Anand",
      "Anand",
      "Anantapur",
      "Anda",
      "Anda"
    ],
    "is_noise_query": true,
    "nlp": "Collect cities of people not from a specific country, ordered by city, up to 32."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Transfer_Account]->(:Person) OR (a)-[:Medium_SignIn_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people who either do not transfer money directly to another person or sign in through a medium."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Apply_Loan]->(:Person) OR (a)-[:Account_Withdraw_Account]->(:Person) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the blocked status of people who either do not apply for loans or withdraw money from an account, ordered by their blocked status, up to 32 entries."
  },
  {
    "query": "MATCH (a:Person) RETURN count(a.createTime) AS cnt UNION MATCH (b:Person) RETURN count(b.createTime) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Combine counts of the number of creation times for people, effectively counting the number of people."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.loanAmount) AS total_value",
    "answer": 112187006902.0,
    "is_noise_query": true,
    "nlp": "Sum loan amounts for all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.createTime) AS min_value",
    "answer": "2020-02-15 04:08:32.798",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:41:50.010",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Invest_Company]->(:Loan) WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect balances of loans where the loan is invested in by a person, ordered by balance, up to 32 entries."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Loan) OR (n)-[:Person_Guarantee_Person]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have a deposit into an account or are guaranteed by a person."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanUsage LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanUsage LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4701476535998088242"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4711891110136381993"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:79375943432405966"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:82472168176223460"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:70650219154375089"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:29836347531329650"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4663195939165439209"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:66146619527004485"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4658973814514778717"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4714705859903489184"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 loans with the highest usage and then from those, return the top 10 loans with the highest usage again."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanUsage MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans with the most usage, ordered by creation time."
  },
  {
    "query": "MATCH (a:Loan {loanUsage: '4774660029942858046'})-[:Person_Apply_Loan]->(b:Loan) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Loan) WHERE c.loanAmount = '4774660029942858046' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of connections where the first loan's usage matches the second loan's amount and the second loan is connected to a third loan through a person investing in a company, where the third loan's amount also matches the initial loan's usage."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance = '4774660029942858046' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans whose balance does not equal '4774660029942858046'."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage = '4774660029942858046' WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [
      61.51,
      62.37,
      111.44,
      201.44,
      263.89,
      562.45,
      769.15,
      971.05,
      1364.68,
      1474.58,
      1850.89,
      1859.25,
      2638.41,
      2741.97,
      2831.06,
      3021.97,
      3313.09,
      3690.54,
      3885.13,
      4801.41,
      5296.98,
      5491.24,
      8423.84,
      8930.37,
      9107.76,
      9378.97,
      9554.96,
      11339.17,
      11665.03,
      11785.13,
      12075.02,
      12430.63
    ],
    "is_noise_query": true,
    "nlp": "Collect the balances of loans that do not have a specific usage ('4774660029942858046'), ordered by their balance, up to 32 entries."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Invest_Company]->(:Loan) OR (a)-[:Account_Repay_Loan]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have an outgoing relationship of type 'Company_Invest_Company' or have an outgoing relationship of type 'Account_Repay_Loan'."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Invest_Company]->(:Loan) OR (a)-[:Account_Repay_Loan]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Collect the creation times of loans that either do not have an outgoing relationship of type 'Company_Invest_Company' or have an outgoing relationship of type 'Account_Repay_Loan', ordered by creation time, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.companyName) AS min_value",
    "answer": "Abernathy PLC",
    "is_noise_query": true,
    "nlp": "Return the name of the company that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.url) AS max_value",
    "answer": "https://www.zigzagpredestined.com",
    "is_noise_query": true,
    "nlp": "Find the URL that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Loan_Deposit_Account]->(:Company) WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the businesses of companies that are involved in loan deposits, ordered by their business field, up to 32 entries."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Account_Transfer_Account]->(:Company) OR (n)-[:Person_Invest_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not transfer accounts or are invested in by a person."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:344",
        "b": "Company:423"
      },
      {
        "a": "Company:584",
        "b": "Company:423"
      },
      {
        "a": "Company:237",
        "b": "Company:423"
      },
      {
        "a": "Company:43",
        "b": "Company:423"
      },
      {
        "a": "Company:641",
        "b": "Company:423"
      },
      {
        "a": "Company:599",
        "b": "Company:423"
      },
      {
        "a": "Company:423",
        "b": "Company:423"
      },
      {
        "a": "Company:538",
        "b": "Company:423"
      },
      {
        "a": "Company:595",
        "b": "Company:423"
      },
      {
        "a": "Company:807",
        "b": "Company:423"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of top 10 oldest companies and, from those pairs, the top 10 oldest companies based on their creation times."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies, excluding self-pairs, ordered by their business and creation time."
  },
  {
    "query": "MATCH (a:Company {description: '13194139533597'})-[:Person_Guarantee_Person]->(b:Company) WITH b MATCH (b)-[:Person_Own_Account]->(c:Company) WHERE c.description = '13194139533597' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections between companies where a company with a specific description guarantees another company, and the guaranteed company owns an account with the same specific description."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.companyName = '13194139533597' WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [
      "Abortion Clinic",
      "Accountant",
      "Accounting Firm",
      "Accounting School",
      "Acoustical Consultant",
      "Acrobatic Diving Pool",
      "Aerobics Instructor",
      "Afghani Restaurant",
      "Aggregate Supplier",
      "Agricultural Association",
      "Aikido School",
      "Air Compressor Supplier",
      "Air Conditioning Repair Service",
      "Air Conditioning Store",
      "Airbrushing Service",
      "Aircraft Rental Service",
      "Airline",
      "Airline",
      "Alcohol Manufacturer",
      "Alcohol Retail Monopoly",
      "Alcoholism Treatment Program",
      "Alternator Supplier",
      "Aluminum Window",
      "Ambulance Service",
      "Amusement Center",
      "Amusement Ride Supplier",
      "Andalusian Restaurant",
      "Anesthesiologist",
      "Anglican Church",
      "Animation Studio",
      "Apartment Building",
      "Apartment Building"
    ],
    "is_noise_query": true,
    "nlp": "Collect the business types of companies whose names do not match a specific identifier, ordered by business type, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Own_Account]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have any outgoing Person_Own_Account relationships or do have such relationships."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Transfer_Account]->(:Company) OR (a)-[:Company_Guarantee_Company]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 company names from companies that either do not have an Account_Transfer_Account relationship or have a Company_Guarantee_Company relationship, ordered by company name."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 frequency login types of accounts that have an Account_Withdraw_Account relationship, ordered by frequency login type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Loan_Deposit_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not transfer funds to other accounts or are involved in loan deposits."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountId LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:14918173765665963",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:14918173765665963",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 accounts based on account ID, then from these, retrieve the top 10 accounts based on phone number, returning both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find pairs of distinct accounts where the second account is ordered by creation time, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4844184349190390014'})-[:Person_Guarantee_Person]->(b:Account) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Account) WHERE c.phonenum = '4844184349190390014' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Return the count of accounts that are guaranteed by another account with a specific account level and also guarantee a company with a given phone number."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType = '4844184349190390014' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose frequency login type does not match a specified value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime <> '4844184349190390014' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 creation times of accounts that were created after a specific last login time, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that do not have a medium sign-in relationship or have a loan deposit relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 email addresses of accounts that either do not guarantee others or apply for loans, ordered by email."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account]-()-[:Company_Own_Account]-(b:Account) WHERE NOT (a)-[:Company_Own_Account]-(b) WITH b ORDER BY b.accountLevel LIMIT 20 RETURN b.accountLevel",
    "answer": [
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 20 account levels of accounts that do not directly own each other through the Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 phone numbers of accounts that invest in companies, ordered by phone number."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Apply_Loan]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have an outgoing Person_Apply_Loan relationship or have an incoming Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH p = (a:Account)-[:Medium_SignIn_Account *1..4]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.926683199217228,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths of 1 to 4 hops between accounts through the Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:241224055041032454",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by nickname, then find the top 10 accounts ordered by freqLoginType among those, and return these pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.nickname RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique account pairs where the first account's phone number is different from the second account's phone number and they are not the same account, ordered by the second account's nickname."
  },
  {
    "query": "MATCH (a:Account), (b:Account) WHERE a.phonenum = b.phonenum AND a <> b RETURN count(*) AS cnt",
    "answer": 3492,
    "is_noise_query": true,
    "nlp": "Count the number of distinct account pairs that share the same phone number but are not the same account."
  },
  {
    "query": "MATCH (a:Account {phonenum: '4856287773188949063'})-[:Person_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Account) WHERE c.lastLoginTime = '4856287773188949063' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that are invested in by the specified account and are also involved in a Company_Guarantee_Company relationship where the last login time matches the specified phone number."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime = '4856287773188949063' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose last login time does not match the specified value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum <> '4856287773188949063' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 blocked status values of accounts whose phone number matches the specified value, ordered by their blocked status."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "This query always returns all accounts because the condition (a)-[:Person_Guarantee_Person]->(:Account) is both included and excluded, making the WHERE clause redundant."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Identifies accounts that do not have outgoing withdraw relationships or have guarantee relationships with other accounts, then orders them by login frequency and returns the first 32 types."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountType) AS cnt UNION MATCH (b:Account) RETURN count(b.accountType) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts the total number of account types from all accounts twice using a union operation."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Account) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.phonenum LIMIT 20 RETURN b.phonenum",
    "answer": [
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      }
    ],
    "is_noise_query": true,
    "nlp": "Finds accounts connected through medium sign-in relationships indirectly, ensuring no direct link exists between them, then orders and limits results by phone number to return the top 20 phone numbers."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanAmount) AS min_value",
    "answer": 88778.0,
    "is_noise_query": true,
    "nlp": "Find the minimum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.balance) AS max_value",
    "answer": 99766573.87,
    "is_noise_query": true,
    "nlp": "Find the maximum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Company_Own_Account]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects the loan amounts of loans owned by companies, ordered by loan amount, and returns the top 32 values."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Own_Account]->(:Loan) OR (n)-[:Account_Withdraw_Account]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Counts loans that do not have a person ownership relationship or have a withdrawal relationship with another loan."
  },
  {
    "query": "MATCH (a:Loan)-[:Person_Apply_Loan *2..4]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 1864,
    "is_noise_query": true,
    "nlp": "Counts the number of loans where there is a path of 2 to 4 relationships connecting them."
  },
  {
    "query": "MATCH p = (a:Loan)-[:Loan_Deposit_Account *1..4]-(b:Loan) RETURN avg(length(p)) AS avg_len",
    "answer": 3.8683391834012184,
    "is_noise_query": true,
    "nlp": "Calculates the average length of paths between loans connected by deposit relationships, allowing up to four steps."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanId LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.interestRate LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4866420872350532459"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894568370021597389"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4759460381200482587"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:217298682020626503"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4889501820440805670"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4890627720347648427"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:123848989752689515"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:143833713099145499"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4802807527613924326"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894849844998307888"
      }
    ],
    "is_noise_query": true,
    "nlp": "Combines two sorted lists of ten loans each, based on loan ID and interest rate, and returns the pairs."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanUsage MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Counts unique pairs of loans where the first is ordered by usage and the second by interest rate, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.loanAmount = b.balance AND a <> b RETURN count(*) AS cnt",
    "answer": 54,
    "is_noise_query": true,
    "nlp": "Counts pairs of loans with equal loan and balance amounts, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Loan {interestRate: '262897628247753271'})-[:Company_Own_Account]->(b:Loan) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Loan) WHERE c.createTime = '262897628247753271' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts loans that are connected through a Company_Own_Account relationship to another loan with an interest rate of '262897628247753271', then further connected through a Person_Guarantee_Person relationship to a third loan with a creation time of '262897628247753271', and returns the total count."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance = '262897628247753271' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Counts loans where the balance does not equal '262897628247753271'."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance STARTS WITH '262897628247753271' WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects the loan amounts of loans whose balance does not start with '262897628247753271', orders them by loan amount, and returns the top 32 values."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Counts loans that either do not have a Medium_SignIn_Account relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Own_Account]->(:Loan) OR (a)-[:Account_Repay_Loan]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Collects the creation times of loans that either do not have a Company_Own_Account relationship or have an Account_Repay_Loan relationship, orders them by creation time, and returns the top 32 values."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.riskLevel) AS min_value",
    "answer": "Critical risk",
    "is_noise_query": true,
    "nlp": "Returns the lowest risk level alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Finds the highest risk level alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Account_Repay_Loan]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects the medium types of mediums involved in repayments, orders them by type, and returns the top 32 values."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Repay_Loan]->(:Medium) OR (n)-[:Account_Repay_Loan]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts all mediums, regardless of their relationships."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.riskLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:884",
        "b": "Medium:962"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1196"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1480"
      },
      {
        "a": "Medium:884",
        "b": "Medium:503"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1650"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1124"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1875"
      },
      {
        "a": "Medium:884",
        "b": "Medium:86"
      },
      {
        "a": "Medium:884",
        "b": "Medium:680"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1297"
      }
    ],
    "is_noise_query": true,
    "nlp": "Combines two lists of ten mediums each, first sorted by creation time and then by risk level, and returns the pairs."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.riskLevel MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.mediumType RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Counts distinct pairs of mediums where the mediums are different, ordered by risk level and medium type, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Medium {lastLoginTime: '8796093023102'})-[:Person_Guarantee_Person]->(b:Medium) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Medium) WHERE c.riskLevel = '8796093023102' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts the number of mediums connected through a Person_Guarantee_Person relationship to another medium, which also has a Loan_Deposit_Account relationship with a third medium having a specific risk level."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked = '8796093023102' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts mediums that are not marked with a specified blocked status."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel CONTAINS '8796093023102' WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Gathers risk levels of mediums that do not contain a specific substring in their risk level, orders them by risk level, and returns the top 32 values."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Invest_Company]->(:Medium) OR (a)-[:Medium_SignIn_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts mediums that either do not have a company investment relationship or have a medium sign-in relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Own_Account]->(:Medium) OR (a)-[:Person_Own_Account]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collects medium types of mediums that are not involved in a Company_Own_Account relationship but are involved in a Person_Own_Account relationship, ordered by type, and returns the top 32 values."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Medium) RETURN count(b.isBlocked) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts the total number of mediums, regardless of their relationships, effectively counting all mediums."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Returns the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Finds the frequent login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Matches accounts where there exists at least one account related through a \"Person_Invest_Company\" relationship, orders them by their isBlocked status, and returns the first 32 isBlocked statuses as values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Own_Account]->(:Account) OR (n)-[:Company_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts that either do not have a \"Company_Own_Account\" relationship or have a \"Company_Invest_Company\" relationship with another account."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "Matches accounts, orders them by creation time, limits the results to 10, then matches other accounts, orders them by account type, limits those to 10 as well, and returns both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.phonenum RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Matches accounts, orders them by last login time, then matches other distinct accounts, orders them by phone number, and counts the number of unique pairs as pair_count."
  },
  {
    "query": "MATCH (a:Account {createTime: '4895131319975020671'})-[:Account_Repay_Loan]->(b:Account) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Account) WHERE c.freqLoginType = '4895131319975020671' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Finds accounts with a specific creation time, follows \"Account_Repay_Loan\" relationships to other accounts, and then follows \"Account_Withdraw_Account\" relationships to further accounts with a specific freqLoginType, returning the count of such paths as total_cnt."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime <> '4895131319975020671' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Matches accounts where the last login time matches a specific value, orders them by isBlocked status, and returns the first 32 isBlocked statuses as vals."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts that either do not have a \"Company_Guarantee_Company\" relationship or have a \"Medium_SignIn_Account\" relationship with another account."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Matches accounts that do not have a \"Account_Withdraw_Account\" relationship or have a \"Loan_Deposit_Account\" relationship, orders them by isBlocked status, and returns the first 32 isBlocked statuses as vals."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Transfer_Account]-()-[:Account_Transfer_Account]-(b:Account) WHERE NOT (a)-[:Account_Transfer_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Finds accounts that can reach other accounts through two \"Account_Transfer_Account\" relationships but are not directly connected by one, orders the resulting accounts by isBlocked status, limits the results to 20, and returns their isBlocked statuses."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Finds the minimum isBlocked value among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 12:42:53.558",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Medium_SignIn_Account]->(:Person) WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Returns the first 32 person names of people who have a Medium_SignIn_Account relationship with another person, ordered by their name."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Person) OR (n)-[:Account_Transfer_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts the number of people who either do not have a Loan_Deposit_Account relationship or have an Account_Transfer_Account relationship with another person."
  },
  {
    "query": "MATCH p = (a:Person)-[:Person_Invest_Company *2..3]-(b:Person) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculates the average length of paths of 2 to 3 hops between people through the Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:630",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:51",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:808",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:640",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:982",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:41",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:729",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:310",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:985",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:755",
        "b": "Person:28587302322284"
      }
    ],
    "is_noise_query": true,
    "nlp": "Finds the top 10 unblocked people and then finds the top 10 people ordered by name, returning both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.gender MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.personName RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Counts the number of unique pairs of people where the first person is not the second person, ordered by gender and then by the second person's name."
  },
  {
    "query": "MATCH (a:Person {birthday: '2199023256209'})-[:Account_Transfer_Account]->(b:Person) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Person) WHERE c.city = '2199023256209' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts the number of times a person with a specific birthday transfers money to another person, who in turn deposits money into someone in a specific city."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country = '2199023256209' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts the number of people whose country is not a specific value."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.isBlocked CONTAINS '2199023256209' WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 cities of unblocked people who do not contain a specific substring in their blocked status, ordered by city."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Person) OR (a)-[:Company_Invest_Company]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts the number of people who either do not withdraw money from an account or invest in a company."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Person) OR (a)-[:Company_Apply_Loan]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Find all Person nodes that do not have an outgoing Account_Withdraw_Account relationship or have an incoming Company_Apply_Loan relationship, then order them by their creation time and return the first 32 creation times."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum isBlocked value among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Own_Account]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find all Medium nodes that have an incoming Company_Own_Account relationship, then order them by their medium type and return the first 32 medium types."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Own_Account]->(:Medium) OR (n)-[:Person_Guarantee_Person]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count all Medium nodes that do not have an incoming Person_Own_Account relationship or have an outgoing Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:736",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:753",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1551",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1508",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1447",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1249",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1813",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:268",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:608",
        "b": "Medium:1994"
      }
    ],
    "is_noise_query": true,
    "nlp": "First, find the top 10 Medium nodes ordered by their last login time. Then, from these top 10, find the next 10 Medium nodes ordered by their last login time and return both sets of nodes."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.riskLevel RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Find pairs of distinct Medium nodes where the first set is ordered by last login time and the second set is ordered by risk level, then return the count of such pairs."
  },
  {
    "query": "MATCH (a:Medium {lastLoginTime: '26388279066676'})-[:Person_Guarantee_Person]->(b:Medium) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Medium) WHERE c.riskLevel = '26388279066676' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of Medium nodes where a node with a specific last login time has an outgoing Person_Guarantee_Person relationship leading to another node, which in turn has an outgoing Account_Transfer_Account relationship to a node with a specific risk level."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.lastLoginTime = '26388279066676' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count all Medium nodes whose last login time does not match a specific timestamp."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime = '26388279066676' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Return the earliest creation times of Medium nodes except for the one with a specific creation time, limited to the first 32."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Medium) OR (a)-[:Person_Apply_Loan]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count Medium nodes that either do not have a Medium_SignIn_Account relationship or have a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Own_Account]->(:Medium) OR (a)-[:Person_Apply_Loan]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-01-29 05:12:39.506",
      "2020-02-03 17:46:43.836",
      "2020-02-15 19:29:12.059",
      "2020-03-07 12:38:42.833",
      "2020-03-12 20:53:48.093",
      "2020-03-20 08:34:41.767",
      "2020-03-28 05:20:45.915",
      "2020-04-02 18:27:25.513",
      "2020-04-03 19:25:08.930",
      "2020-04-05 16:30:10.209",
      "2020-04-08 12:15:42.926",
      "2020-04-19 15:31:53.628",
      "2020-04-30 08:24:02.358",
      "2020-05-17 13:12:15.150",
      "2020-05-18 06:16:54.756",
      "2020-05-19 10:29:57.660",
      "2020-05-24 18:06:27.871",
      "2020-05-28 09:43:48.217",
      "2020-05-29 05:26:41.843",
      "2020-06-05 17:35:15.999",
      "2020-06-06 14:42:45.787",
      "2020-06-18 21:36:31.467",
      "2020-06-21 18:28:14.001",
      "2020-06-22 17:25:34.472",
      "2020-06-23 10:15:27.445",
      "2020-06-25 22:58:42.936",
      "2020-07-01 07:39:30.970",
      "2020-07-04 05:11:00.922",
      "2020-07-07 11:59:49.304",
      "2020-07-09 23:56:58.844",
      "2020-07-12 12:44:05.479",
      "2020-07-16 23:19:43.551"
    ],
    "is_noise_query": true,
    "nlp": "Return the last login times of Medium nodes that do not have a Company_Own_Account relationship or have a Person_Apply_Loan relationship, limited to the first 32."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.phonenum) AS max_value",
    "answer": "999-9198",
    "is_noise_query": true,
    "nlp": "Find the phone number that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect email addresses of Account nodes that have a Person_Invest_Company relationship, ordered by email, limited to the first 32."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Account) OR (n)-[:Account_Repay_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes that either do not have a Company_Guarantee_Company relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account *1..3]-(b:Account) RETURN count(b) AS cnt",
    "answer": 26076,
    "is_noise_query": true,
    "nlp": "Count unique Account nodes reachable through 1 to 3 Medium_SignIn_Account relationships."
  },
  {
    "query": "MATCH p = (a:Account)-[:Account_Repay_Loan *2..3]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between Account nodes connected by 2 to 3 Account_Repay_Loan relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:241224055041032454",
        "b": "Account:4896820169835283571"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:285134151407895618"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4896820169835282675"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4896820169835284218"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:285415626384607208"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 Account nodes with the lowest nicknames, then find the top 10 related Account nodes with the highest account levels."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct Account nodes, ordered by account level."
  },
  {
    "query": "MATCH (a:Account {email: '289919226011975900'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.email = '289919226011975900' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections where an Account with a specific email address has a withdrawal relationship leading to another Account, which then has a Medium_SignIn_Account relationship back to the original Account with the same specific email address, and return the total count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname CONTAINS '289919226011975900' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes where the nickname does not contain a specific string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime CONTAINS '289919226011975900' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect email addresses of Account nodes where the creation time does not contain a specific string, ordered by email, limited to the first 32."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Invest_Company]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes that either do not have a Company_Invest_Company relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Collect account types of Account nodes that do not have a Person_Invest_Company relationship or have a Company_Own_Account relationship, ordered by account type, limited to the first 32."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account]-()-[:Company_Own_Account]-(b:Account) WHERE NOT (a)-[:Company_Own_Account]-(b) WITH b ORDER BY b.accountType LIMIT 20 RETURN b.accountType",
    "answer": [
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      }
    ],
    "is_noise_query": true,
    "nlp": "Collect account types of Account nodes that are indirectly connected via two Company_Own_Account relationships but not directly, ordered by account type, limited to 20."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 03:31:14.114",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all Medium nodes."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level among all Medium nodes."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Own_Account]->(:Medium) WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect risk levels of Medium nodes that have a Company_Own_Account relationship, ordered by risk level, limited to the first 32."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Medium) OR (n)-[:Account_Repay_Loan]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count Medium nodes that either do not have a Company_Guarantee_Company relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1132",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1952",
        "b": "Medium:884"
      },
      {
        "a": "Medium:80",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1447",
        "b": "Medium:884"
      },
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:884"
      },
      {
        "a": "Medium:884",
        "b": "Medium:884"
      },
      {
        "a": "Medium:918",
        "b": "Medium:884"
      },
      {
        "a": "Medium:697",
        "b": "Medium:884"
      },
      {
        "a": "Medium:386",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 Medium nodes with the earliest creation times, then find the top 10 Medium nodes related to them, also with the earliest creation times."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct Medium nodes where neither node has a relationship with itself, ordered by their isBlocked status."
  },
  {
    "query": "MATCH (a:Medium {isBlocked: '30786325578007'})-[:Loan_Deposit_Account]->(b:Medium) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Medium) WHERE c.lastLoginTime = '30786325578007' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections where a Medium with a specific isBlocked status has a Loan_Deposit_Account relationship leading to another Medium, which in turn has a Company_Apply_Loan relationship with a third Medium that has a specific last login time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.lastLoginTime STARTS WITH '30786325578007' WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the medium types of Medium nodes where the last login time does not start with a specific string, ordered by medium type, limiting the result to the first 32 entries."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Medium) OR (a)-[:Person_Apply_Loan]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count Medium nodes that either do not have an Account_Withdraw_Account relationship or have a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Medium) OR (a)-[:Account_Repay_Loan]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the medium types of Medium nodes that do not have a Medium_SignIn_Account relationship or have an Account_Repay_Loan relationship, ordered by medium type, limiting the result to the first 32 entries."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.createTime) AS cnt UNION MATCH (b:Medium) RETURN count(b.createTime) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Union the count of creation times from two sets of Medium nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.balance) AS total_value",
    "answer": 59302232892.69993,
    "is_noise_query": true,
    "nlp": "Sum the balance of all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.createTime) AS min_value",
    "answer": "2020-02-15 04:08:32.798",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanUsage) AS max_value",
    "answer": "weddings",
    "is_noise_query": true,
    "nlp": "Find the loan usage that comes last alphabetically among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Company_Invest_Company]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect creation times of Loan nodes that have at least one Company_Invest_Company relationship, ordered by creation time, limited to the first 32 entries."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Loan) OR (n)-[:Person_Guarantee_Person]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count Loan nodes that either do not have a Loan_Deposit_Account relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Loan)-[:Account_Repay_Loan *1..4]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 109282,
    "is_noise_query": true,
    "nlp": "Count unique Loan nodes reachable through 1 to 4 Account_Repay_Loan relationships."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.balance LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:283445301547631063",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:4734690583249944819",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:4823355200913801910",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:249386829365641434",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:223772606484971763",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:188306759419429567",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:246572079598535350",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:4807311127241294042",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:248260929458799829",
        "b": "Loan:4784511654127731833"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 Loan nodes with the highest loan amounts, then among those, find the top 10 related Loan nodes with the highest balances, and return both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count distinct pairs of Loan nodes, where the second node has a higher interest rate than the first, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Loan {loanUsage: '192247409093378544'})-[:Account_Withdraw_Account]->(b:Loan) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Loan) WHERE c.loanUsage = '192247409093378544' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections where a Loan with a specific loan usage has an Account_Withdraw_Account relationship leading to another Loan with the same specific loan usage."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage ENDS WITH '192247409093378544' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count Loan nodes where the loan usage does not end with a specific string."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime = '192247409093378544' WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Collect loan amounts of Loan nodes where the creation time does not match a specific value, ordered by loan amount, limited to the first 32 entries."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Loan) OR (a)-[:Medium_SignIn_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count Loan nodes that either do not have a Loan_Deposit_Account relationship or have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Invest_Company]->(:Loan) OR (a)-[:Account_Repay_Loan]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect interest rates of Loan nodes that do not have a Person_Invest_Company relationship or have an Account_Repay_Loan relationship, ordered by interest rate, limited to the first 32 entries."
  },
  {
    "query": "MATCH (a:Loan) RETURN count(a.createTime) AS cnt UNION MATCH (b:Loan) RETURN count(b.createTime) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Union the count of creation times from two separate sets of Loan nodes."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.loanUsage LIMIT 20 RETURN b.loanUsage",
    "answer": [
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      },
      {
        "b.loanUsage": "business ventures"
      }
    ],
    "is_noise_query": true,
    "nlp": "Collect loan usages of Loan nodes that are indirectly connected via exactly two Loan_Deposit_Account relationships but not directly connected, ordered by loan usage, limited to 20 entries."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 phone numbers of Account nodes that have an outgoing Account_Repay_Loan relationship, ordered by phone number."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Repay_Loan]->(:Account) OR (n)-[:Account_Repay_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count all Account nodes, including those that either do not have an Account_Repay_Loan relationship or have such a relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account *2..5]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3184,
    "is_noise_query": true,
    "nlp": "Count unique Account nodes reachable through 2 to 5 Company_Own_Account relationships."
  },
  {
    "query": "MATCH p = (a:Account)-[:Medium_SignIn_Account *1..4]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.926683199217228,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between Account nodes connected by 1 to 4 Medium_SignIn_Account relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835283081",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282792",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407894843",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896538694858572073",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282970",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407895701",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284135",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407894741",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "First, find the top 10 Account nodes with the lowest isBlocked status. Then, for each of these nodes, find the top 10 Account nodes with the lowest email addresses, and return both sets of nodes."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.phonenum RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct Account nodes, where the first node is ordered by account type and the second node is ordered by phone number."
  },
  {
    "query": "MATCH (a:Account), (b:Account) WHERE a.email = b.email AND a <> b RETURN count(*) AS cnt",
    "answer": 4089624,
    "is_noise_query": true,
    "nlp": "Count duplicate email addresses among Account nodes, where two different nodes share the same email address."
  },
  {
    "query": "MATCH (a:Account {nickname: '4898509019695547924'})-[:Person_Own_Account]->(b:Account) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Account) WHERE c.lastLoginTime = '4898509019695547924' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of accounts indirectly connected to a specific account with nickname '4898509019695547924' through a Person_Own_Account relationship and then connected to another account with a last login time matching the given nickname, via a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.isBlocked = '4898509019695547924' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes where the isBlocked status does not match the specific value '4898509019695547924'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType = '4898509019695547924' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 account types of non-blocked Account nodes, excluding those with a specific account type, ordered by account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Company_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes that either do not have a Person_Own_Account relationship or have a Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 isBlocked statuses of Account nodes that do not have an Account_Withdraw_Account relationship or have a Medium_SignIn_Account relationship, ordered by isBlocked status."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.phonenum) AS cnt UNION MATCH (b:Account) RETURN count(b.phonenum) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Union count of phone numbers from two sets of Account nodes."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Repay_Loan]-()-[:Account_Repay_Loan]-(b:Account) WHERE NOT (a)-[:Account_Repay_Loan]-(b) WITH b ORDER BY b.accountType LIMIT 20 RETURN b.accountType",
    "answer": [
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the first 20 unique account types of accounts indirectly connected through two Account_Repay_Loan relationships, excluding direct connections."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.business) AS min_value",
    "answer": "Abortion Clinic",
    "is_noise_query": true,
    "nlp": "Return the business that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.companyName) AS max_value",
    "answer": "Zulauf LLC",
    "is_noise_query": true,
    "nlp": "Find the company name that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company)-[:Company_Invest_Company]->(b:Company) MATCH (a)-[:Company_Invest_Company]->(b) RETURN count(*) AS cnt",
    "answer": 2330,
    "is_noise_query": true,
    "nlp": "Count the number of direct investment relationships between companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Own_Account]->(:Company) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 countries from companies where there is a person owning an account related to the company, ordered by country."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Company_Invest_Company]->(:Company) OR (n)-[:Company_Invest_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count all companies, including those that have invested in another company and those that have not."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.companyId LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.country LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:29",
        "b": "Company:4398046511482"
      },
      {
        "a": "Company:29",
        "b": "Company:8796093022248"
      },
      {
        "a": "Company:23",
        "b": "Company:13194139533678"
      },
      {
        "a": "Company:29",
        "b": "Company:1099511628330"
      },
      {
        "a": "Company:23",
        "b": "Company:8796093022964"
      },
      {
        "a": "Company:23",
        "b": "Company:8796093022284"
      },
      {
        "a": "Company:23",
        "b": "Company:1099511628330"
      },
      {
        "a": "Company:23",
        "b": "Company:8796093022248"
      },
      {
        "a": "Company:23",
        "b": "Company:4398046511482"
      },
      {
        "a": "Company:29",
        "b": "Company:8796093022964"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of companies, first limiting to the top 10 companies by ID and then pairing them with the top 10 companies by country."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.country MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.url RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of distinct company pairs where the second company is ordered by URL and does not match the first company."
  },
  {
    "query": "MATCH (a:Company {createTime: '14293651162076'})-[:Account_Transfer_Account]->(b:Company) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Company) WHERE c.url = '14293651162076' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have a transfer relationship with a specified company and also have an investment relationship with another specific company."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.country CONTAINS '14293651162076' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies not containing '14293651162076' in their country field."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.companyName STARTS WITH '14293651162076' WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [
      "Abortion Clinic",
      "Accountant",
      "Accounting Firm",
      "Accounting School",
      "Acoustical Consultant",
      "Acrobatic Diving Pool",
      "Aerobics Instructor",
      "Afghani Restaurant",
      "Aggregate Supplier",
      "Agricultural Association",
      "Aikido School",
      "Air Compressor Supplier",
      "Air Conditioning Repair Service",
      "Air Conditioning Store",
      "Airbrushing Service",
      "Aircraft Rental Service",
      "Airline",
      "Airline",
      "Alcohol Manufacturer",
      "Alcohol Retail Monopoly",
      "Alcoholism Treatment Program",
      "Alternator Supplier",
      "Aluminum Window",
      "Ambulance Service",
      "Amusement Center",
      "Amusement Ride Supplier",
      "Andalusian Restaurant",
      "Anesthesiologist",
      "Anglican Church",
      "Animation Studio",
      "Apartment Building",
      "Apartment Building"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 business types from companies excluding those whose names start with '14293651162076', ordered by business type."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Company) OR (a)-[:Person_Invest_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a medium sign-in relationship or have a person invest company relationship, or both."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Invest_Company]->(:Company) OR (a)-[:Company_Own_Account]->(:Company) WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [
      "Abortion Clinic",
      "Accountant",
      "Accounting Firm",
      "Accounting School",
      "Acoustical Consultant",
      "Acrobatic Diving Pool",
      "Aerobics Instructor",
      "Afghani Restaurant",
      "Aggregate Supplier",
      "Agricultural Association",
      "Aikido School",
      "Air Compressor Supplier",
      "Air Conditioning Repair Service",
      "Air Conditioning Store",
      "Airbrushing Service",
      "Aircraft Rental Service",
      "Airline",
      "Airline",
      "Alcohol Manufacturer",
      "Alcohol Retail Monopoly",
      "Alcoholism Treatment Program",
      "Alternator Supplier",
      "Aluminum Window",
      "Ambulance Service",
      "Amusement Center",
      "Amusement Ride Supplier",
      "Andalusian Restaurant",
      "Anesthesiologist",
      "Anglican Church",
      "Animation Studio",
      "Apartment Building",
      "Apartment Building"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 business types from companies that either do not have a person invest company relationship or do have a company own account relationship, ordered by business type."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-15 09:39:18.811",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 account levels from accounts that have applied for a loan, ordered by account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Account) OR (n)-[:Medium_SignIn_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a loan deposit relationship or do have a medium sign-in relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account *2..3]-(b:Account) RETURN count(b) AS cnt",
    "answer": 26076,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have a medium sign-in relationship with exactly two to three hops away."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountId LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:23080948090274944",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:26740122787514064",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:20547673299879219",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:25895697857381261",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:14918173765665963",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:27584547717644507",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of accounts ordered by their IDs and emails, limiting results to 10 each."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of distinct account pairs where the second account is ordered by last login time."
  },
  {
    "query": "MATCH (a:Account {lastLoginTime: '280349076803814674'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Account) WHERE c.accountLevel = '280349076803814674' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have a withdrawal relationship with a specified account and further have a withdrawal relationship with another specific account, both with the same account level value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email CONTAINS '280349076803814674' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts not containing '280349076803814674' in their email field."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime ENDS WITH '280349076803814674' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 creation times from accounts excluding those whose creation times end with '280349076803814674', ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a loan deposit relationship or have a person guarantee person relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 frequency login types from accounts that either do not have a loan deposit relationship or have a company own account relationship, ordered by frequency login type."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.createTime LIMIT 20 RETURN b.createTime",
    "answer": [
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 20 creation times of accounts that are connected through two different loan deposit relationships but are not directly connected."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 12:37:50.617",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.url) AS max_value",
    "answer": "https://www.zigzagpredestined.com",
    "is_noise_query": true,
    "nlp": "Find the URL that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Invest_Company]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS values",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC",
      "Bechtelar Inc"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 company names from companies that have invested in other companies, ordered by company name."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Company) OR (n)-[:Account_Repay_Loan]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a medium sign-in relationship or have an account repay loan relationship."
  },
  {
    "query": "MATCH (a:Company)-[:Person_Invest_Company *2..5]-(b:Company) RETURN count(b) AS cnt",
    "answer": 680,
    "is_noise_query": true,
    "nlp": "Count the number of companies that have a person invest company relationship with a distance of 2 to 5 hops."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.description LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:12094627905710",
        "b": "Company:423"
      },
      {
        "a": "Company:10995116278715",
        "b": "Company:423"
      },
      {
        "a": "Company:13194139533448",
        "b": "Company:423"
      },
      {
        "a": "Company:10995116278035",
        "b": "Company:423"
      },
      {
        "a": "Company:10995116278747",
        "b": "Company:423"
      },
      {
        "a": "Company:5497558139281",
        "b": "Company:423"
      },
      {
        "a": "Company:6597069767075",
        "b": "Company:423"
      },
      {
        "a": "Company:9895604650419",
        "b": "Company:423"
      },
      {
        "a": "Company:815",
        "b": "Company:423"
      },
      {
        "a": "Company:3298534883932",
        "b": "Company:423"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of companies where the first ten are ordered by their descriptions and the second ten by their creation times."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of distinct company pairs where the second company is ordered by blocked status."
  },
  {
    "query": "MATCH (a:Company {business: '1099511628351'})-[:Loan_Deposit_Account]->(b:Company) WITH b MATCH (b)-[:Person_Own_Account]->(c:Company) WHERE c.companyName = '1099511628351' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have a loan deposit relationship with a specified company and also have a person own account relationship with another specific company."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.url = '1099511628351' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies not having a URL equal to '1099511628351'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business STARTS WITH '1099511628351' WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Angola",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Azerbaijan"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 distinct countries from companies whose business names do not start with '1099511628351', ordered by country."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Apply_Loan]->(:Company) OR (a)-[:Company_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a person apply loan relationship or have a company own account relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Apply_Loan]->(:Company) OR (a)-[:Loan_Deposit_Account]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 company names from companies that do not have a company apply loan relationship but do have a loan deposit account relationship, ordered by company name."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.business) AS min_value",
    "answer": "Abortion Clinic",
    "is_noise_query": true,
    "nlp": "Return the business name that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.city) AS max_value",
    "answer": "ng_H",
    "is_noise_query": true,
    "nlp": "Find the city name that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Medium_SignIn_Account]->(:Company) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 distinct countries from companies that have a medium sign-in relationship, ordered by country."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Apply_Loan]->(:Company) OR (n)-[:Person_Own_Account]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a person apply loan relationship or have a person own account relationship."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:10995116278646",
        "b": "Company:23"
      },
      {
        "a": "Company:3298534883452",
        "b": "Company:23"
      },
      {
        "a": "Company:13194139534270",
        "b": "Company:23"
      },
      {
        "a": "Company:12094627906048",
        "b": "Company:23"
      },
      {
        "a": "Company:961",
        "b": "Company:23"
      },
      {
        "a": "Company:2199023255941",
        "b": "Company:23"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:23"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:23"
      },
      {
        "a": "Company:1099511628698",
        "b": "Company:23"
      },
      {
        "a": "Company:790",
        "b": "Company:23"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of companies where the first set is limited to the top 10 companies ordered by their business, and for each of these, the second set is limited to the top 10 companies ordered by their company ID."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.url MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.url RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of companies where the first company is ordered by URL, and for each such company, find a second distinct company also ordered by URL."
  },
  {
    "query": "MATCH (a:Company {description: '10995116277856'})-[:Person_Invest_Company]->(b:Company) WITH b MATCH (b)-[:Person_Own_Account]->(c:Company) WHERE c.isBlocked = '10995116277856' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have a person invest company relationship with a specified company and further have a person own account relationship with another specific company."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.description ENDS WITH '10995116277856' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies not ending their description with '10995116277856'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.isBlocked STARTS WITH '10995116277856' WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 cities from companies that do not start their isBlocked status with '10995116277856', ordered by city."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that either do not have a person guarantee person relationship or do have a person own account relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Company) OR (a)-[:Account_Repay_Loan]->(:Company) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 isBlocked statuses from companies that either do not have an account withdraw account relationship or do have an account repay loan relationship, ordered by isBlocked status."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Company) RETURN count(b.isBlocked) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of isBlocked statuses in companies, returning this count twice."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.country) AS min_value",
    "answer": "Afghanistan",
    "is_noise_query": true,
    "nlp": "Return the country that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.companyName) AS max_value",
    "answer": "Zulauf LLC",
    "is_noise_query": true,
    "nlp": "Find the company name that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Own_Account]->(:Company) WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 business types from companies that have a company own account relationship, ordered by business type."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Company) OR (n)-[:Account_Repay_Loan]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that do not have a loan deposit relationship or do have an account repay loan relationship."
  },
  {
    "query": "MATCH (a:Company)-[:Person_Invest_Company *3..5]-(b:Company) RETURN a, count(b) AS cnt",
    "answer": [
      {
        "a": {
          "country": "Mexico",
          "companyId": 93,
          "business": "Seed Supplier",
          "createTime": "2020-02-02 10:04:06.081",
          "city": "Pedro_Escobedo",
          "companyName": "Sawayn PLC",
          "isBlocked": false,
          "description": "Dull pain there that he must remain calm, i had a neighbour like gregor in the evenings; who would place his stick to give a full answer and explain everything, walls, furniture, but he had threatened her.",
          "_node_id": "Company:93",
          "url": "https://www.apieceholes.io"
        },
        "cnt": 24
      },
      {
        "a": {
          "country": "France",
          "companyId": 8796093022370,
          "business": "Duty Free Store",
          "createTime": "2021-09-17 06:18:10.300",
          "city": "Aix-en-Provence",
          "companyName": "Jerde-Bahringer",
          "isBlocked": false,
          "description": "Almonds; some cheese that gregor, one that would excuse their behaviour. The food that was the nearest to the chief clerk, but he could meet her eyes met those of gregor when he tried to climb up to him.",
          "_node_id": "Company:8796093022370",
          "url": "https://www.flimsilybait.info"
        },
        "cnt": 24
      },
      {
        "a": {
          "country": "Cuba",
          "companyId": 10995116278645,
          "business": "Office Accessories Wholesaler",
          "createTime": "2022-02-05 04:53:50.607",
          "city": "Cienfuegos",
          "companyName": "Quigley Group",
          "isBlocked": false,
          "description": "And we also give immediate notice. With his left, gregor had had enough sleep. Other times he tried to imagine whether something of the others. What do you need anything? gregor did not go into the kitchen.",
          "_node_id": "Company:10995116278645",
          "url": "https://www.brieflyfeint.org"
        },
        "cnt": 120
      },
      {
        "a": {
          "country": "United_States",
          "companyId": 10995116278005,
          "business": "Nanotechnology Engineer",
          "createTime": "2022-03-31 09:42:38.743",
          "city": "Nashville",
          "companyName": "Bins Ltd",
          "isBlocked": false,
          "description": "The sudden noise behind gregor so startled him that he, in contrast with his mouth. He had been lit in the morning while a heavy fur muff that covered the whole of his head carefully enough, though. The.",
          "_node_id": "Company:10995116278005",
          "url": "https://www.blatantlyawing.net"
        },
        "cnt": 360
      }
    ],
    "is_noise_query": true,
    "nlp": "Return companies and the count of companies they are indirectly connected to through a person invest company relationship, with a path length of 3 to 5 hops."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.url LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.url LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:12094627906439",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:10995116277886",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:9895604650630",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:2199023255954",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:3298534883592",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:10995116278493",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:8796093022926",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:2199023255994",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:2199023255711",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:8796093023119",
        "b": "Company:3298534883592"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of companies, each limited to 10, ordered by their URLs."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.city MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.city RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of companies, where each pair consists of two different companies ordered by city."
  },
  {
    "query": "MATCH (a:Company {createTime: '8796093022277'})-[:Company_Invest_Company]->(b:Company) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Company) WHERE c.country = '8796093022277' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have a company invest company relationship with a specified company and also have a medium sign-in relationship with another company in the same country."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business = '8796093022277' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies not having a business type equal to '8796093022277'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.country <> '8796093022277' WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 business types from companies whose country is '8796093022277', ordered by business type."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Transfer_Account]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that do not have an account transfer account relationship or do have a person own account relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Repay_Loan]->(:Company) OR (a)-[:Account_Withdraw_Account]->(:Company) WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [
      "Abortion Clinic",
      "Accountant",
      "Accounting Firm",
      "Accounting School",
      "Acoustical Consultant",
      "Acrobatic Diving Pool",
      "Aerobics Instructor",
      "Afghani Restaurant",
      "Aggregate Supplier",
      "Agricultural Association",
      "Aikido School",
      "Air Compressor Supplier",
      "Air Conditioning Repair Service",
      "Air Conditioning Store",
      "Airbrushing Service",
      "Aircraft Rental Service",
      "Airline",
      "Airline",
      "Alcohol Manufacturer",
      "Alcohol Retail Monopoly",
      "Alcoholism Treatment Program",
      "Alternator Supplier",
      "Aluminum Window",
      "Ambulance Service",
      "Amusement Center",
      "Amusement Ride Supplier",
      "Andalusian Restaurant",
      "Anesthesiologist",
      "Anglican Church",
      "Animation Studio",
      "Apartment Building",
      "Apartment Building"
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 business types from companies that either do not have an account repay loan relationship or do have an account withdraw account relationship, ordered by business type."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-15 09:39:18.811",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the highest account level among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the last login times of up to 32 accounts that have applied for a loan, ordered by their last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Own_Account]->(:Account) OR (n)-[:Account_Transfer_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not own another account or have transferred an account."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835282675",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4896820169835282675",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:285134151407895618",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:285134151407895618",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 accounts by account level, then from each, select the top 10 accounts by phone number, returning both."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "For each account, find another distinct account with the lowest last login time and count such pairs."
  },
  {
    "query": "MATCH (a:Account {isBlocked: '280349076803815354'})-[:Company_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Account) WHERE c.email = '280349076803815354' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of relationships where a blocked account applies for a loan leading to another account with a specific email address."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email ENDS WITH '280349076803815354' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose email does not end with a certain string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname STARTS WITH '280349076803815354' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect creation times of up to 32 accounts whose nickname does not start with a certain string, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not own a company account or have signed in via a medium."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect frequency login types of up to 32 accounts that own a person account, ordered by frequency login type."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Account) RETURN count(b.isBlocked) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count occurrences of blocked status for all accounts using two separate match statements."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.interestRate) AS total_value",
    "answer": 116.34200000000003,
    "is_noise_query": true,
    "nlp": "Sum interest rates of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:41:50.010",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Guarantee_Person]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect interest rates of up to 32 loans guaranteed by a person, ordered by interest rate."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Loan) OR (n)-[:Person_Invest_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have an outgoing Account_Withdraw_Account relationship or have an incoming Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanId LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:29836347531329650",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:37436171902517700",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:23643898043696390",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:27584547717644754",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:27303072740934442",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:34058472181990599",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:19140298416325639",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:17169973579351110",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:37436171902518055",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 loans by loan ID, then from each of those, select the top 10 loans by loan ID again, returning both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans, ordered by their interest rate."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.balance = b.balance AND a <> b WITH a, b ORDER BY b.loanAmount RETURN a, collect(b.loanAmount)[0..32] AS bs",
    "answer": [
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-06-11 10:55:03.271",
          "loanUsage": "business ventures",
          "_node_id": "Loan:250794204249195062",
          "loanId": 250794204249195062,
          "loanAmount": 14514821.0
        },
        "bs": [
          14514821.0
        ]
      },
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-05-31 08:24:48.513",
          "loanUsage": "business ventures",
          "_node_id": "Loan:4859383997932765750",
          "loanId": 4859383997932765750,
          "loanAmount": 14514821.0
        },
        "bs": [
          14514821.0
        ]
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-09-12 23:10:13.706",
          "loanUsage": "renovations",
          "_node_id": "Loan:277252852059997235",
          "loanId": 277252852059997235,
          "loanAmount": 90419964.0
        },
        "bs": [
          90419964.0
        ]
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-06-25 17:52:38.863",
          "loanUsage": "renovations",
          "_node_id": "Loan:4866420872350532659",
          "loanId": 4866420872350532659,
          "loanAmount": 90419964.0
        },
        "bs": [
          90419964.0
        ]
      }
    ],
    "is_noise_query": true,
    "nlp": "For loans with the same balance but different IDs, collect up to 32 loan amounts, ordered by loan amount."
  },
  {
    "query": "MATCH (a:Loan {loanAmount: '4814629476635770891'})-[:Account_Withdraw_Account]->(b:Loan) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Loan) WHERE c.createTime = '4814629476635770891' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where a loan with a specific loan amount is withdrawn from another account and then transferred under specific conditions involving a matching creation time."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage = '4814629476635770891' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans whose usage is not a specific value."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.interestRate CONTAINS '4814629476635770891' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect interest rates of up to 32 loans that do not contain a specific substring in their interest rate field, ordered by interest rate."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Account_Repay_Loan]->(:Loan) OR (a)-[:Account_Withdraw_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have an outgoing Account_Repay_Loan relationship or have an outgoing Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Loan) OR (a)-[:Account_Transfer_Account]->(:Loan) WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [
      61.51,
      62.37,
      111.44,
      201.44,
      263.89,
      562.45,
      769.15,
      971.05,
      1364.68,
      1474.58,
      1850.89,
      1859.25,
      2638.41,
      2741.97,
      2831.06,
      3021.97,
      3313.09,
      3690.54,
      3885.13,
      4801.41,
      5296.98,
      5491.24,
      8423.84,
      8930.37,
      9107.76,
      9378.97,
      9554.96,
      11339.17,
      11665.03,
      11785.13,
      12075.02,
      12430.63
    ],
    "is_noise_query": true,
    "nlp": "Collect balances of up to 32 loans that either do not withdraw funds or transfer funds to another account, ordered by balance."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum value of the isBlocked field among all accounts, where 'false' is considered less than 'true'."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the maximum value of the freqLoginType field among all accounts, which corresponds to the lexicographically last (alphabetically latest) frequent login type."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect last login times of up to 32 accounts that are owned by another account, ordered by last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Account) OR (n)-[:Person_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Person_Guarantee_Person relationship or have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285415626384605546",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4897664594765414856",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4898227544718836111",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:286823001268159172",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285697101361317507",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285415626384605793",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:286260051314737727",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4897383119788705189",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4898509019695546810",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 accounts by frequency login type, then for each of these, select the top 10 accounts by email, returning both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count distinct pairs of accounts where the first account is ordered by account type and the second account is ordered by account level, ensuring the two accounts are different."
  },
  {
    "query": "MATCH (a:Account {phonenum: '106679016173338884'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Account) WHERE c.createTime = '106679016173338884' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where an account with a specific phone number withdraws funds into another account, which then withdraws funds again under the same creation time condition."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType = '106679016173338884' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose frequency login type does not match '106679016173338884'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email <> '106679016173338884' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect creation times of up to 32 accounts whose email matches '106679016173338884', ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have any withdrawal transactions or have withdrawal transactions."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect creation times of up to 32 accounts that either do not have a person owning them directly or are owned by a company, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the first 20 unblocked accounts in a complex loan-deposit relationship, excluding direct loan-deposit relationships between the same accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum isBlocked value among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the frequent login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the last login times of up to 32 accounts that have applied for a loan, ordered by their last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Own_Account]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that either do not own another account directly or are guaranteed by a person."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:64176294690031206",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4661507089305174028",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4672766088373601934",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4671077238513337662",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:41095346599755900",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4644337115725825070",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4662070039258597186",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:45035996273706602",
        "b": "Account:4503599627371623"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 accounts by last login time, then from these, select the top 10 accounts by account ID, returning both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the first account's nickname is used to find the second account, and they are ordered by the second account's account level, returning the count of such pairs."
  },
  {
    "query": "MATCH (a:Account {freqLoginType: '261208778387490923'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Account) WHERE c.isBlocked = '261208778387490923' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where an account with a specific frequency login type invests in a company, and that company then applies for a loan under specific conditions, returning the total count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType CONTAINS '261208778387490923' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose frequency login type does not contain a specific string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel STARTS WITH '261208778387490923' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the blocked statuses of up to 32 accounts whose account level does not start with a specific string, ordered by whether they are blocked, returning these statuses."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have any outgoing Account Transfer relationships or have an incoming Person Invest Company relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect nicknames of up to 32 accounts that either do not have an outgoing Person Invest Company relationship or have an incoming Company Guarantee Company relationship, ordered by nickname."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.freqLoginType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the earliest frequency login type alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountType) AS max_value",
    "answer": "trust account",
    "is_noise_query": true,
    "nlp": "Find the latest account type alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect phone numbers of up to 32 accounts that have repaid a loan, ordered by their phone number."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Loan_Deposit_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Accounts that either do not have an outgoing relationship of type \"Company_Apply_Loan\" or have an incoming relationship of type \"Loan_Deposit_Account\", counted."
  },
  {
    "query": "MATCH p = (a:Account)-[:Company_Own_Account *2..2]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "The average length of paths of exactly two hops between Account nodes via the \"Company_Own_Account\" relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:240661105087611876",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4854598923328685028",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4776911829756543545",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4878805771325802434",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:205758207975490910",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4808155552171427166",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:250512729272484409",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:266556802944993218",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4756082681479956519",
        "b": "Account:4503599627371623"
      }
    ],
    "is_noise_query": true,
    "nlp": "First, find the top 10 Accounts ordered by email, then for each of these, find another set of top 10 Accounts ordered by account ID, and finally return both sets of Accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.nickname RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "For each Account, find another distinct Account with a different account type, then order by nickname and return the count of unique pairs."
  },
  {
    "query": "MATCH (a:Account {accountType: '248542404435511198'})-[:Medium_SignIn_Account]->(b:Account) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Account) WHERE c.nickname = '248542404435511198' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of instances where an Account of a specific account type ('248542404435511198') has a \"Medium_SignIn_Account\" relationship leading to another Account, which in turn has an \"Account_Withdraw_Account\" relationship to an Account with a specific nickname ('248542404435511198')."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email ENDS WITH '248542404435511198' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Accounts whose email does not end with '248542404435511198'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email CONTAINS '248542404435511198' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "For Accounts where the email does not contain '248542404435511198', order them by isBlocked status and return the first 32 isBlocked statuses."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Accounts that either do not have an outgoing \"Account_Repay_Loan\" relationship or have an incoming \"Person_Apply_Loan\" relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 nicknames of Accounts that either do not have an outgoing \"Person_Invest_Company\" relationship or have an incoming \"Person_Apply_Loan\" relationship, after ordering by nickname."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Account) RETURN count(b.isBlocked) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of blocked accounts using two separate matches."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve up to 32 email addresses from accounts that have withdrawn funds from another account, ordered by email."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not sign in via Medium or are company-owned accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account *1..5]-(b:Account) RETURN count(b) AS cnt",
    "answer": 120024,
    "is_noise_query": true,
    "nlp": "Count the number of accounts connected through a loan-deposit relationship within a range of 1 to 5 steps."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4856850723142369842",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:258394028620382770",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:213920982300098729",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4885842645743567017",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:273312202386047344",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts based on phone number and then, from those, find the top 10 based on last login time, returning both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of accounts where the first account is ordered by creation time and the second by frequency of login type."
  },
  {
    "query": "MATCH (a:Account {accountType: '4776630354779832850'})-[:Loan_Deposit_Account]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.accountLevel = '4776630354779832850' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that are connected to a specific account via a loan-deposit relationship and then further connected to an account with a specific account level via a medium sign-in relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType STARTS WITH '4776630354779832850' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a specific frequency login type prefix."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname CONTAINS '4776630354779832850' WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect phone numbers of accounts whose nickname does not contain a specific string, limited to 32 results."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a company ownership link or have an account transfer link."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect emails of accounts that either do not apply for loans or withdraw accounts, limited to 32 results."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.city) AS min_value",
    "answer": "Aachen",
    "is_noise_query": true,
    "nlp": "Return the city that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all companies."
  },
  {
    "query": "MATCH (a:Company)-[r:Company_Guarantee_Company]-(b:Company) WHERE r._edge_id CONTAINS '4398046511456' RETURN a, count(b) AS cnt",
    "answer": [
      {
        "a": {
          "country": "China",
          "companyId": 3298534883645,
          "business": "Shipping Equipment Industry",
          "createTime": "2020-08-21 08:53:40.478",
          "city": "Bengbu",
          "companyName": "Skiles-Leuschke",
          "isBlocked": false,
          "description": "Any quicker about it. He slid back into his mouth, flowed over the dishes set in front of them as if to protect her. Gregor, he was bound to make use of that there were some supernatural force waiting to.",
          "_node_id": "Company:3298534883645",
          "url": "https://www.raggedlycleats.gov"
        },
        "cnt": 1
      },
      {
        "a": {
          "country": "United_Kingdom",
          "companyId": 3298534884097,
          "business": "Plating Service",
          "createTime": "2020-09-14 09:28:56.256",
          "city": "Liverpool",
          "companyName": "Reinger-Langworth",
          "isBlocked": false,
          "description": "Formerly, gregor, would have to re- arrange his life. Iii no- one appreciated her playing here as much effort to remove all the doors were locked? despite all their misfortunes there was nothing for him.",
          "_node_id": "Company:3298534884097",
          "url": "https://www.blithelypullulates.com"
        },
        "cnt": 1
      },
      {
        "a": {
          "country": "China",
          "companyId": 4398046511456,
          "business": "Mens Clothing Store",
          "createTime": "2020-10-30 09:41:13.462",
          "city": "Dongyang",
          "companyName": "Satterfield-Lueilwitz",
          "isBlocked": false,
          "description": "All times and they had had no success with that she would strain herself. This picture at least partly right! but you always think you can come in, not every day of his room before the night, my train leaves.",
          "_node_id": "Company:4398046511456",
          "url": "https://www.softlydevalues.info"
        },
        "cnt": 3
      },
      {
        "a": {
          "country": "Nepal",
          "companyId": 14293651161756,
          "business": "Veterinarian",
          "createTime": "2022-09-17 16:50:23.516",
          "city": "Lumbini",
          "companyName": "Gaylord LLC",
          "isBlocked": false,
          "description": "Be seriously ill or even of a rush. She' s corpse with their heads sunk and talking to each of the bed all at the same demands as before? there was a good man for her, but we could carry on with our lives.",
          "_node_id": "Company:14293651161756",
          "url": "https://www.alsojee.edu"
        },
        "cnt": 1
      }
    ],
    "is_noise_query": true,
    "nlp": "Count relationships between companies where a specific guarantee edge ID is present."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Apply_Loan]->(:Company) WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect URLs of companies that have applied for loans, limited to 32 results."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Apply_Loan]->(:Company) OR (n)-[:Account_Withdraw_Account]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not apply for loans or withdraw accounts."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.city LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:13194139534270",
        "b": "Company:14293651161100"
      },
      {
        "a": "Company:13194139534270",
        "b": "Company:5497558139444"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:8796093022277"
      },
      {
        "a": "Company:13194139534270",
        "b": "Company:8796093022277"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:14293651161100"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:14293651161100"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:5497558139444"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:8796093022277"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:5497558139444"
      },
      {
        "a": "Company:2199023255941",
        "b": "Company:5497558139444"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of top 10 companies based on business and then find the top 10 companies they relate to based on city, returning both."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.companyName MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count unique pairs of companies where the first is ordered by company name and the second by creation time."
  },
  {
    "query": "MATCH (a:Company {url: '4398046511456'})-[:Account_Repay_Loan]->(b:Company) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Company) WHERE c.isBlocked = '4398046511456' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count relationships involving a specific company and other companies through repay loan and invest company links, where the related companies are blocked."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.description CONTAINS '4398046511456' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies whose description does not contain the string '4398046511456'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business CONTAINS '4398046511456' WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Angola",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Azerbaijan"
    ],
    "is_noise_query": true,
    "nlp": "Collect distinct countries of companies whose business description does not include '4398046511456', limited to 32 results."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Own_Account]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a person own account link or do have it."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Transfer_Account]->(:Company) OR (a)-[:Account_Withdraw_Account]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Collect company names of companies that either do not have an account transfer link or do have an account withdrawal link, ordered by company name and limited to 32 results."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.country) AS cnt UNION MATCH (b:Company) RETURN count(b.country) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "This query is incorrect and confusing. It appears to be attempting to count unique countries but uses a union that does not make sense in this context. A more accurate description would be: Count the total number of unique countries across all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum value of 'isBlocked' among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 07:23:57.080",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Own_Account]->(:Company) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect creation times of companies that have a company ownership link, ordered by creation time and limited to 32 results."
  },
  {
    "query": "MATCH (n:Company) WHERE (n)-[:Person_Apply_Loan]->(:Company) OR (n)-[:Company_Guarantee_Company]->(:Company) RETURN count(n) AS cnt",
    "answer": 473,
    "is_noise_query": true,
    "nlp": "Count companies that either have a person apply loan link or have a company guarantee link."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Company_Own_Account]->(:Company) OR (n)-[:Company_Guarantee_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a company ownership link or have a company guarantee link."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.description LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:961",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:3298534883452",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:10995116278646",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:13194139534270",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:1099511628698",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:2199023255941",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:12094627906048",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:6597069767075"
      },
      {
        "a": "Company:790",
        "b": "Company:6597069767075"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 companies ordered by business and then find the top 10 related companies ordered by their description."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.city MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count unique pairs of distinct companies where the first company is ordered by city and the second by whether it is blocked."
  },
  {
    "query": "MATCH (a:Company {description: '12094627906020'})-[:Company_Guarantee_Company]->(b:Company) WITH b MATCH (b)-[:Account_Repay_Loan]->(c:Company) WHERE c.url = '12094627906020' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Collect the count of companies where a specified company acts as a guarantor and another company repays a loan, given a specific URL condition."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.url CONTAINS '12094627906020' WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Angola",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Azerbaijan"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 countries of companies that do not contain a specific URL string, ordered by country."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Company) OR (a)-[:Loan_Deposit_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 495,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a company guarantee relationship or have a loan deposit relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Invest_Company]->(:Company) OR (a)-[:Company_Apply_Loan]->(:Company) WITH a ORDER BY a.description RETURN collect(a.description)[0..32] AS vals",
    "answer": [
      "A broom and swept up the room. Then there was still just a moment, and he was weak from hunger, made up for in some way, but he had, after all, and rushed forward in a smart blue uniform with his father.",
      "A cave, a stranger would have to overcome it because he feared his father now from the bed first, of course, moving it an inch. His father were of no help, for instance, whenever i go back to the window.",
      "A corner. His idea of relaxation is working with his chin on the banister, he called again with the whole evening looking at all, and it had only been alarmed briefly. Now they did exactly as he sought.",
      "A gush of coffee was pouring down onto the key or pushed it from the living room where he was forced to remain made him feel better. He was unable to pay off my parents know about it, repeatedly raising.",
      "A month earlier he had been living in it. That set his mother screaming anew, she brought him a little more slowly than them, louts, was still hurriedly thinking all this time, though, did not understand.",
      "A page to each of the other hand, he made it difficult to eat if his whole body against it. Gregor also refrained, this was so resentful of it. That' s mother had now fallen completely asleep. He was using.",
      "A pleasant experience, and gregor' s room any more. And indeed, his mother, and then throw himself at his two friends joined in with the whole flat and especially in the office, so he started working especially.",
      "A possible reason for her. As they pushed it down again with the same way. During the day, early in the middle had produced a newspaper, given a page to each other as if he happened to me? he could do even.",
      "A serious cold, which had probably been permanently set aside for emergencies; money to live off the interest; it was only ever thinks about the others. What shall we take now, he called to him, what is.",
      "A short while he told himself once more pursue their parents with the violin. Whenever they can. Perhaps only because her mother quite worried, that would have enough space to get gregor to open the window.",
      "A strain for her to immediately open the door again straight away that gregor had only been able to actually move around on those spindly little legs along one side hung quivering in the air while those.",
      "A time. Gregor is ill. Quick, get the top part of the need to earn money? she had time to catch her breath, he felt as if he left most of all playing the violin went silent. What he was moreover unable.",
      "A time. The previous morning while his parents about the others? she was fully( in his back and sides; he had put her finger on her lips and made a sudden fear that mr. Samsa, he startled her when she reached.",
      "A use. Should he do anything to make, and his hands, get the job finished before gregor' s feelings, as his father and continue being of help to him as he was still there and fetch it herself he would still.",
      "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march.",
      "About. Where is our breakfast?, the middle of the bed, when he was well aware that we can very easily fall victim to gossip and chance and groundless complaints, and believe me it would also have let him.",
      "Acquired, that made it difficult for him. She left the premises. Mr. Samsa were struck, almost whispering as if he succeeded in falling out of his mobility- probably permanently. He soon had to blow himself.",
      "Action for damages from you, and mumbled something into their beards and moved it because of the flat knew when she' s room. Before, they took everything calmly he would have seen long ago that it' ll be.",
      "Actually was that although the flat. What' s experienced hand, i' ll be able to eat and it was an apple; then he used the tip of his mother, accused her of not leaving the chair twice before she even swore.",
      "Again now, then. Let' s got to get dressed so quickly? there was someone at the same place, imagining the wildest possibilities, but that was the boss and told him just what i' m just getting out of the.",
      "Again straight away. Gregor slowly pushed his head kept nodding it could be seriously ill and he smiled sweetly. The cleaner came in on gregor and went over to the living room. The cleaner wanted to show.",
      "Again straight away. Gregor slowly pushed his head kept nodding it could be seriously ill and he smiled sweetly. The cleaner came in on gregor and went over to the living room. The cleaner wanted to show.",
      "Against its glass, it was only able to speak to you personally. So now gregor' s responsibility and he smiled sweetly. The change in gregor' s mother and sister, naturally, tried as far as possible to look.",
      "Aim, threw one apple after another. These earnest gentlemen- all three of them he only had they earned a break from work, but the milk as it would soon be time to give directions from a junior salesman.",
      "All could be seen. His sister noticed the full dish immediately and looked at it for five years that he couldn' t. I' d have gone of his legs as they danced around. For instance, whenever she felt like.",
      "All excitedly following his efforts to muster all the breakfast things on it without further difficulty. In his highly polished boots could now be heard in the room several times a year when they came back.",
      "All it' s not coming into the room, and mumbled something into their beards and moved back towards their room only very slowly. Meanwhile, it might happen that he was now quite light in the circumstances.",
      "All it' s voice probably could not see it at all, mr. Samsa might go to all the more diligence and concentration. You' ve chosen! travelling day in and looked round. It is, but one day a week, perhaps caused.",
      "All times and they had had no success with that she would strain herself. This picture at least partly right! but you always think you can come in, not every day of his room before the night, my train leaves.",
      "Almonds; some cheese that gregor, one that would excuse their behaviour. The food that was the nearest to the chief clerk, but he could meet her eyes met those of gregor when he tried to climb up to him.",
      "Almost as a girl who was beside himself with anger, into the room came in, she broke out so heavily in tears, thumped on the spot. But he never goes out in her chair with her hand on her hat, which was.",
      "Almost as a sign to the window wide. Although it was before so that she was fully dressed, opened her eyes nearly closed with exhaustion; his sister, who had not heard her coming at all, either night or."
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 descriptions of companies that either do not have a person investment link or have a company application loan link, ordered by description."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Company) RETURN count(b.isBlocked) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of blocked accounts using two separate matches."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum lexicographical value of the isBlocked attribute among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.phonenum) AS max_value",
    "answer": "999-9198",
    "is_noise_query": true,
    "nlp": "Find the phone number that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account levels of accounts that repay loans, ordered by account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Account) OR (n)-[:Company_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Calculate the number of accounts that either have no outgoing Company_Guarantee_Company relationships or have an incoming Company_Invest_Company relationship."
  },
  {
    "query": "MATCH p = (a:Account)-[:Account_Repay_Loan *2..3]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Find the average length of paths of 2 to 3 hops long involving accounts repaying loans."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:9570149208163490",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4617596992938311786",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4617596992938311786",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "List the top 10 accounts based on creation time and then the top 10 based on phone number, returning both pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of accounts where the first account is ordered by email and the second by phone number."
  },
  {
    "query": "MATCH (a:Account {isBlocked: '4889220345464095435'})-[:Loan_Deposit_Account]->(b:Account) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Account) WHERE c.freqLoginType = '4889220345464095435' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count relationships between blocked accounts and other accounts via Loan_Deposit_Account connections, where the second account meets specific criteria."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email CONTAINS '4889220345464095435' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the email does not contain the specified substring."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.isBlocked STARTS WITH '4889220345464095435' WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the earliest nicknames among non-blocked accounts, limited to 32 results."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have an Account_Transfer_Account relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Apply_Loan]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect account levels of accounts that either do not have a Company_Apply_Loan relationship or have a Medium_SignIn_Account relationship, ordered by account level and limited to 32 results."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account]-()-[:Person_Own_Account]-(b:Account) WHERE NOT (a)-[:Person_Own_Account]-(b) WITH b ORDER BY b.email LIMIT 20 RETURN b.email",
    "answer": [
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "archaeologist.com"
      },
      {
        "b.email": "archaeologist.com"
      },
      {
        "b.email": "asiancutes.com"
      },
      {
        "b.email": "asiancutes.com"
      },
      {
        "b.email": "autopm.com"
      },
      {
        "b.email": "banha.cc"
      },
      {
        "b.email": "banha.cc"
      },
      {
        "b.email": "banha.cc"
      },
      {
        "b.email": "bgay.com"
      },
      {
        "b.email": "bgay.com"
      },
      {
        "b.email": "bgay.com"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the emails of accounts where there is a Person_Own_Account path connecting them through another account, excluding direct Person_Own_Account relationships, limited to 20 results."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.mediumType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the mediumType that comes first alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 23:57:25.319",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Guarantee_Company]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 isBlocked statuses of mediums that have a path to another medium through the Company_Guarantee_Company relationship, ordered by their isBlocked status."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Company_Own_Account]->(:Medium) OR (n)-[:Company_Guarantee_Company]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either have no outgoing Company_Own_Account relationships or have outgoing Company_Guarantee_Company relationships."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.riskLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1994",
        "b": "Medium:962"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1196"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1480"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:503"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1650"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1124"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1875"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:86"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:680"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1297"
      }
    ],
    "is_noise_query": true,
    "nlp": "Match the top 10 mediums by last login time, then for each of these, match the top 10 other mediums by risk level, returning pairs of a and b."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.riskLevel MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs (a, b) where a and b are Medium nodes with different risk levels, and b is ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium {lastLoginTime: '17592186045531'})-[:Person_Guarantee_Person]->(b:Medium) WITH b MATCH (b)-[:Person_Own_Account]->(c:Medium) WHERE c.lastLoginTime = '17592186045531' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of paths where a Medium node with a specific last login time guarantees another Medium node, and that Medium node owns an account with the same specific last login time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel STARTS WITH '17592186045531' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes whose risk level does not start with a specific string."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime = '17592186045531' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 creation times of Medium nodes whose creation time is not equal to a specific value, ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Medium) OR (a)-[:Person_Apply_Loan]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either do not have an outgoing Company_Guarantee_Company relationship or have an outgoing Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Invest_Company]->(:Medium) OR (a)-[:Company_Guarantee_Company]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 distinct medium types of Medium nodes that either have no outgoing Company_Invest_Company relationships or have incoming Company_Guarantee_Company relationships."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Medium) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of lastLoginTime entries for Medium nodes twice, effectively returning the same count."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.city) AS min_value",
    "answer": "Aachen",
    "is_noise_query": true,
    "nlp": "Return the city that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.city) AS max_value",
    "answer": "d",
    "is_noise_query": true,
    "nlp": "Find the city that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Guarantee_Person]->(:Person) RETURN count(a) AS cnt",
    "answer": 511,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that have outgoing Person_Guarantee_Person relationships."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Apply_Loan]->(:Person) WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 genders of Person nodes ordered by gender that have outgoing Person_Apply_Loan relationships."
  },
  {
    "query": "MATCH (n:Person) WHERE (n)-[:Medium_SignIn_Account]->(:Person) OR (n)-[:Person_Guarantee_Person]->(:Person) RETURN count(n) AS cnt",
    "answer": 511,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that either have incoming Medium_SignIn_Account relationships or outgoing Person_Guarantee_Person relationships."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Own_Account]->(:Person) OR (n)-[:Account_Transfer_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that either do not have outgoing Person_Own_Account relationships or have incoming Account_Transfer_Account relationships."
  },
  {
    "query": "MATCH (a:Person)-[:Person_Guarantee_Person *3..5]-(b:Person) RETURN count(b) AS cnt",
    "answer": 6578,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes connected through 3 to 5 levels of Person_Guarantee_Person relationships."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.city LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:2199023256210",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:21990232556274",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:4398046511316",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:26388279067387",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:26388279066981",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:26388279066949",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:8796093023183",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:13194139534199",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:13194139533667",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:10995116278182",
        "b": "Person:28587302322284"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 cities of Person nodes and then find the top 10 names from those nodes, returning pairs of nodes."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count the number of unique person pairs where the first node is ordered by create time and the second node is ordered by isBlocked status."
  },
  {
    "query": "MATCH (a:Person {country: '15393162789590'})-[:Company_Invest_Company]->(b:Person) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Person) WHERE c.birthday = '15393162789590' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of connections between people in the same country who are connected through a Company_Invest_Company relationship and also have a Loan_Deposit_Account relationship with another person whose birthday matches the specified date."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.personName STARTS WITH '15393162789590' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people whose names do not start with the given string."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.city <> '15393162789590' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the first 32 blocked statuses among people located in the specified city, ordered by their blocked status."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Apply_Loan]->(:Person) OR (a)-[:Person_Guarantee_Person]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people who either do not have an outgoing Company_Apply_Loan relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Repay_Loan]->(:Person) OR (a)-[:Loan_Deposit_Account]->(:Person) WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS vals",
    "answer": [
      "1980-01-08",
      "1980-01-18",
      "1980-01-21",
      "1980-01-23",
      "1980-01-29",
      "1980-02-02",
      "1980-02-04",
      "1980-02-06",
      "1980-03-11",
      "1980-03-19",
      "1980-03-19",
      "1980-03-21",
      "1980-03-31",
      "1980-04-09",
      "1980-04-13",
      "1980-04-13",
      "1980-04-15",
      "1980-04-15",
      "1980-04-20",
      "1980-04-21",
      "1980-05-22",
      "1980-06-19",
      "1980-06-19",
      "1980-06-27",
      "1980-07-14",
      "1980-07-17",
      "1980-07-27",
      "1980-08-02",
      "1980-08-11",
      "1980-08-15",
      "1980-08-18",
      "1980-08-22"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 birthdays of people who either do not have an Account_Repay_Loan relationship or have a Loan_Deposit_Account relationship, ordered by their birthdate."
  },
  {
    "query": "MATCH (a:Person) RETURN count(a.country) AS cnt UNION MATCH (b:Person) RETURN count(b.country) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of distinct countries associated with people."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 12:37:50.617",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.url) AS max_value",
    "answer": "https://www.zigzagpredestined.com",
    "is_noise_query": true,
    "nlp": "Find the URL that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Apply_Loan]->(:Company) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 creation times of companies that have an outgoing Company_Apply_Loan relationship, ordered by their creation time."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Apply_Loan]->(:Company) OR (n)-[:Company_Own_Account]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Find the count of companies that either do not have outgoing Person_Apply_Loan relationships or have outgoing Company_Own_Account relationships."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.country LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:8796093022248",
        "b": "Company:538"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:237"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:641"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:599"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:595"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:43"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:344"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:584"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:807"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:423"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 companies ordered by country, then for each of these, return the top 10 companies ordered by isBlocked status."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.country MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.business RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of companies where the first company is ordered by country and the second company is ordered by business, ensuring the companies are distinct."
  },
  {
    "query": "MATCH (a:Company {createTime: '6597069767511'})-[:Person_Invest_Company]->(b:Company) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Company) WHERE c.city = '6597069767511' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of companies that are two hops away from a specific company with createTime '6597069767511', via a Person_Invest_Company relationship and an Account_Withdraw_Account relationship, where the final company's city is '6597069767511'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.createTime = '6597069767511' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies whose createTime does not equal '6597069767511'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.createTime STARTS WITH '6597069767511' WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS vals",
    "answer": [
      "https://www.abeampedestalled.com",
      "https://www.abeamspray.io",
      "https://www.abeddishonors.net",
      "https://www.ablyrechristens.io",
      "https://www.abroachthack.edu",
      "https://www.activelyveers.info",
      "https://www.adriftlob.io",
      "https://www.afielddarn.org",
      "https://www.afirewaff.net",
      "https://www.aflutterschlepp.org",
      "https://www.aforetimerecrudesce.com",
      "https://www.aftblent.edu",
      "https://www.againknead.net",
      "https://www.agapedome.io",
      "https://www.agapeflavours.info",
      "https://www.agoneligatures.info",
      "https://www.aheadstore.io",
      "https://www.airilybask.edu",
      "https://www.aleetwins.gov",
      "https://www.allchaperons.org",
      "https://www.alldisputing.io",
      "https://www.aloftequalise.edu",
      "https://www.alongshorebreakwaters.net",
      "https://www.aloudreworks.org",
      "https://www.alsoescalades.io",
      "https://www.alsojee.edu",
      "https://www.alsovacations.gov",
      "https://www.alwaysingest.com",
      "https://www.alwayspouches.com",
      "https://www.alwaysredescend.com",
      "https://www.aneardignify.net",
      "https://www.anesblub.edu"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 URLs of companies ordered by their URL, excluding those whose createTime starts with '6597069767511'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Invest_Company]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that either do not have outgoing Person_Invest_Company relationships or have outgoing Person_Own_Account relationships."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Invest_Company]->(:Company) OR (a)-[:Account_Transfer_Account]->(:Company) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [
      "Aachen",
      "Aachen",
      "Aachen",
      "Abbottabad",
      "Abidjan",
      "Abidjan",
      "Agadez",
      "Agadez",
      "Agra",
      "Agra",
      "Ahmedpur_Sial",
      "Ahmedpur_Sial",
      "Aix-en-Provence",
      "Aizawl",
      "Akita_City",
      "Aktobe",
      "Aktobe",
      "Alappuzha",
      "Alashankou",
      "Algiers",
      "Allahabad",
      "Almaty",
      "Almaty",
      "Altamira",
      "Ambon",
      "Ambovombe",
      "Ambovombe",
      "Amman",
      "Amparafaravola",
      "Amsterdam",
      "Anand",
      "Anantapur"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 cities of companies ordered by city, excluding those with a Person_Invest_Company relationship, and including those with an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.description) AS cnt UNION MATCH (b:Company) RETURN count(b.description) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the total number of descriptions available across all companies."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum isBlocked value among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.city) AS max_value",
    "answer": "d",
    "is_noise_query": true,
    "nlp": "Find the city that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Medium_SignIn_Account]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the top 32 creation times of Person nodes who have a \"Medium_SignIn_Account\" relationship with another Person, ordered by their creation time."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Account_Repay_Loan]->(:Person) OR (n)-[:Company_Guarantee_Company]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that either do not have an \"Account_Repay_Loan\" relationship going out or have a \"Company_Guarantee_Company\" relationship coming in."
  },
  {
    "query": "MATCH (a:Person)-[:Person_Invest_Company *3..4]-(b:Person) RETURN count(b) AS cnt",
    "answer": 29496,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes connected through \"Person_Invest_Company\" relationships of length 3 or 4."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.country LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:2199023256209",
        "b": "Person:4"
      },
      {
        "a": "Person:17592186045396",
        "b": "Person:4"
      },
      {
        "a": "Person:19791209300802",
        "b": "Person:4"
      },
      {
        "a": "Person:24189255811977",
        "b": "Person:4"
      },
      {
        "a": "Person:26388279066767",
        "b": "Person:4"
      },
      {
        "a": "Person:6597069766957",
        "b": "Person:4"
      },
      {
        "a": "Person:21990232555896",
        "b": "Person:4"
      },
      {
        "a": "Person:13194139533426",
        "b": "Person:4"
      },
      {
        "a": "Person:17592186044635",
        "b": "Person:4"
      },
      {
        "a": "Person:10995116277957",
        "b": "Person:4"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of Person nodes where the first ten are ordered by country and the next ten by person ID."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.isBlocked MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Return the count of unique pairs of Person nodes, where the first node is ordered by isBlocked and the second by createTime, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Person {personName: '15393162789417'})-[:Account_Repay_Loan]->(b:Person) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Person) WHERE c.isBlocked = '15393162789417' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of Person nodes where the person named '15393162789417' has an \"Account_Repay_Loan\" relationship to them, and they are guaranteed by a blocked person with the same name."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country = '15393162789417' WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS vals",
    "answer": [
      "1980-01-08",
      "1980-01-18",
      "1980-01-21",
      "1980-01-23",
      "1980-01-29",
      "1980-02-02",
      "1980-02-04",
      "1980-02-06",
      "1980-03-11",
      "1980-03-19",
      "1980-03-19",
      "1980-03-21",
      "1980-03-31",
      "1980-04-09",
      "1980-04-13",
      "1980-04-13",
      "1980-04-15",
      "1980-04-15",
      "1980-04-20",
      "1980-04-21",
      "1980-05-22",
      "1980-06-19",
      "1980-06-19",
      "1980-06-27",
      "1980-07-14",
      "1980-07-17",
      "1980-07-27",
      "1980-08-02",
      "1980-08-11",
      "1980-08-15",
      "1980-08-18",
      "1980-08-22"
    ],
    "is_noise_query": true,
    "nlp": "Find the first 32 birthdays of Person nodes who do not have the country '15393162789417', ordered by birthday."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Apply_Loan]->(:Person) OR (a)-[:Person_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that either do not have an \"Company_Apply_Loan\" relationship going out or have a \"Person_Own_Account\" relationship coming in."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Person) OR (a)-[:Account_Repay_Loan]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Find the first 32 creation times of Person nodes who either do not have a \"Loan_Deposit_Account\" relationship going out or have an \"Account_Repay_Loan\" relationship coming in, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the highest blocked status value among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 nicknames of accounts that are part of a person-to-account ownership relationship, ordered by nickname."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Invest_Company]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have an outgoing Company_Invest_Company relationship or have an incoming Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account *2..2]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3200,
    "is_noise_query": true,
    "nlp": "Find the number of accounts that are connected through exactly two levels of Person_Own_Account relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896538694858572073"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285134151407894741"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835283081"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835284218"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 accounts with the highest account level and then the top 10 accounts with the lowest blocked status, paired together."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of unique account pairs where the first account is ordered by blocked status and the second account is ordered by account type, ensuring the accounts are distinct."
  },
  {
    "query": "MATCH (a:Account {phonenum: '222365231601418631'})-[:Company_Own_Account]->(b:Account) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Account) WHERE c.email = '222365231601418631' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of transfers made from accounts owned by the specified phone number to accounts with the specified email address."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType CONTAINS '222365231601418631' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose account type does not contain the specified substring."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel ENDS WITH '222365231601418631' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 blocked statuses of accounts that do not end with the specified substring, ordered by blocked status."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either do not have outgoing Account_Withdraw_Account relationships or have incoming Person_Own_Account relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Find the first 32 creation times of Account nodes that either do not have incoming Company_Own_Account relationships or have outgoing Account_Repay_Loan relationships, ordered by their creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Account) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the total number of non-null last login times for Account nodes."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account]-()-[:Company_Own_Account]-(b:Account) WHERE NOT (a)-[:Company_Own_Account]-(b) WITH b ORDER BY b.lastLoginTime LIMIT 20 RETURN b.lastLoginTime",
    "answer": [
      {
        "b.lastLoginTime": "2020-06-11 05:14:46.792"
      },
      {
        "b.lastLoginTime": "2020-06-11 05:14:46.792"
      },
      {
        "b.lastLoginTime": "2020-07-27 13:03:02.659"
      },
      {
        "b.lastLoginTime": "2020-07-27 13:03:02.659"
      },
      {
        "b.lastLoginTime": "2020-09-03 06:58:23.591"
      },
      {
        "b.lastLoginTime": "2020-09-03 06:58:23.591"
      },
      {
        "b.lastLoginTime": "2020-09-03 06:58:23.591"
      },
      {
        "b.lastLoginTime": "2020-09-23 03:39:36.501"
      },
      {
        "b.lastLoginTime": "2020-10-28 19:27:36.434"
      },
      {
        "b.lastLoginTime": "2020-11-12 05:48:37.974"
      },
      {
        "b.lastLoginTime": "2020-11-12 05:48:37.974"
      },
      {
        "b.lastLoginTime": "2020-11-12 05:48:37.974"
      },
      {
        "b.lastLoginTime": "2021-01-11 08:49:41.025"
      },
      {
        "b.lastLoginTime": "2021-01-11 08:49:41.025"
      },
      {
        "b.lastLoginTime": "2021-01-11 08:49:41.025"
      },
      {
        "b.lastLoginTime": "2021-01-19 16:15:08.017"
      },
      {
        "b.lastLoginTime": "2021-01-19 16:15:08.017"
      },
      {
        "b.lastLoginTime": "2021-01-22 02:19:33.987"
      },
      {
        "b.lastLoginTime": "2021-01-22 02:19:33.987"
      },
      {
        "b.lastLoginTime": "2021-01-27 10:58:22.658"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the last login times of up to 20 Account nodes that are indirectly connected through a Company_Own_Account relationship but are not directly connected by this relationship, ordered by their last login time."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.birthday) AS min_value",
    "answer": "1980-01-08",
    "is_noise_query": true,
    "nlp": "Find the earliest birthday among all Person nodes."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.personName) AS max_value",
    "answer": "ychliski",
    "is_noise_query": true,
    "nlp": "Find the personName that comes last alphabetically among all Person nodes."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Account_Withdraw_Account]->(:Person) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 countries of Person nodes ordered by country that have outgoing Account_Withdraw_Account relationships."
  },
  {
    "query": "MATCH (n:Person) WHERE (n)-[:Account_Repay_Loan]->(:Person) OR (n)-[:Person_Guarantee_Person]->(:Person) RETURN count(n) AS cnt",
    "answer": 511,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that either have outgoing Account_Repay_Loan relationships or incoming Person_Guarantee_Person relationships."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Account_Transfer_Account]->(:Person) OR (n)-[:Person_Apply_Loan]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that either do not have outgoing Account_Transfer_Account relationships or have incoming Person_Apply_Loan relationships."
  },
  {
    "query": "MATCH p = (a:Person)-[:Person_Guarantee_Person *3..3]-(b:Person) RETURN avg(length(p)) AS avg_len",
    "answer": 3.0,
    "is_noise_query": true,
    "nlp": "Find the average length of paths with exactly three hops between two people through a guarantee relationship."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.gender LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:985",
        "b": "Person:315"
      },
      {
        "a": "Person:985",
        "b": "Person:535"
      },
      {
        "a": "Person:985",
        "b": "Person:107"
      },
      {
        "a": "Person:985",
        "b": "Person:24"
      },
      {
        "a": "Person:985",
        "b": "Person:729"
      },
      {
        "a": "Person:985",
        "b": "Person:467"
      },
      {
        "a": "Person:985",
        "b": "Person:808"
      },
      {
        "a": "Person:985",
        "b": "Person:982"
      },
      {
        "a": "Person:985",
        "b": "Person:41"
      },
      {
        "a": "Person:985",
        "b": "Person:675"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve ten persons who are not blocked, then find ten additional persons ordered by gender, returning both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.city MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.personName RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "For each person, find another distinct person from a different city, ordered by name, and return the count of such unique pairs."
  },
  {
    "query": "MATCH (a:Person {personName: '24189255811588'})-[:Person_Own_Account]->(b:Person) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Person) WHERE c.isBlocked = '24189255811588' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count how many times a blocked person who owns an account applies for a loan from someone else who is also blocked."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.gender CONTAINS '24189255811588' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people whose gender does not contain '24189255811588'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.city = '24189255811588' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked status of people not in the city '24189255811588', ordered by their block status, up to 32 entries."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Transfer_Account]->(:Person) OR (a)-[:Account_Repay_Loan]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people who either do not have an account transfer relationship or have an account repay relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Invest_Company]->(:Person) OR (a)-[:Person_Guarantee_Person]->(:Person) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked status of people who are not involved in certain investments or guarantees, ordered by their block status, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 12:37:50.617",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 07:23:57.080",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Own_Account]->(:Company) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked status of companies that own accounts, ordered by their block status, up to 32 entries."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Apply_Loan]->(:Company) OR (n)-[:Account_Repay_Loan]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that do not apply for loans or have repaid loans."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.country LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:678",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:5497558139404",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093022284",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:2199023256399",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:13194139533678",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:4398046511482",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093022964",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:1099511628330",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093022320",
        "b": "Company:4398046511515"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 companies based on their country, then for each of those, find the top 10 other companies based on their company name, and return both sets."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies, where the first set is ordered by whether they are blocked, and the second set within each pair is ordered by creation time."
  },
  {
    "query": "MATCH (a:Company {url: '1099511628449'})-[:Person_Guarantee_Person]->(b:Company) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Company) WHERE c.url = '1099511628449' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count how many times a company that is guaranteed by another company also applies for a loan from a company with a specific URL."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.companyName ENDS WITH '1099511628449' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies whose names do not end with a specific value."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.isBlocked = '1099511628449' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked status of companies that are not blocked by a specific identifier, ordered by their block status, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Invest_Company]->(:Company) OR (a)-[:Account_Withdraw_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 50,
    "is_noise_query": true,
    "nlp": "Count companies that either do not invest in other companies or withdraw from accounts."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Collect the names of companies that are not guaranteed by any person or are owned by a person, ordered by company name, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.description) AS cnt UNION MATCH (b:Company) RETURN count(b.description) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Return the count of descriptions for all companies."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the earliest phone number among all accounts alphabetically."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.email) AS max_value",
    "answer": "zoho.com",
    "is_noise_query": true,
    "nlp": "Find the email that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Count the first 32 blocked statuses of accounts that have been involved in an account transfer, ordered by their blocked status."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Invest_Company]->(:Account) OR (n)-[:Company_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Retrieve the count of accounts that either do not have an outgoing Person_Invest_Company relationship or have an outgoing Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.nickname LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4744542207434819682",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:241224055041032454"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve two sets of ten accounts each: the first set ordered by phone number, and the second set ordered by nickname, then return both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of distinct accounts where the first account's nickname is different from the second account's email, ordered by nickname and email respectively."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4805903752357741568'})-[:Loan_Deposit_Account]->(b:Account) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Account) WHERE c.freqLoginType = '4805903752357741568' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count how many times an account with a specific account level deposits a loan into another account, which then guarantees another account with a specific login type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname = '4805903752357741568' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose nickname does not match a specific value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType ENDS WITH '4805903752357741568' WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect the phone number of accounts whose freqLoginType does not end with a specific value, ordered by phonenum, up to 32 entries."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not own an account or apply for a loan."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect the nickname of accounts that are not invested in by a person or are owned by a person, ordered by nickname, up to 32 entries."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the frequent login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 values of whether accounts are blocked, where these accounts have a relationship with another account through Company_Guarantee_Company, ordered by the blocked status."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Own_Account]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have any outgoing Person_Own_Account relationships or have incoming Company_Apply_Loan relationships."
  },
  {
    "query": "MATCH p = (a:Account)-[:Person_Own_Account *2..4]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between accounts where one account is indirectly connected to another through a person, with the path length being between 2 and 4 relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:20266198323168013",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:20547673299879219",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:14918173765665963",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4631952216750555239",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4617596992938311786",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4632796641680687311",
        "b": "Account:4503599627371623"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 accounts ordered by creation time, and for each of those, return the top 10 accounts ordered by account ID."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of accounts where the first account is not equal to the second, ordered by email and account type respectively."
  },
  {
    "query": "MATCH (a:Account {createTime: '214202457276809450'})-[:Person_Own_Account]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.nickname = '214202457276809450' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts where a specific account (identified by createTime) owns another account, and that owned account is part of a Company_Invest_Company relationship with an account having a specific nickname."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname ENDS WITH '214202457276809450' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose nickname does not end with '214202457276809450'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.isBlocked ENDS WITH '214202457276809450' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve the first 32 account types of non-blocked accounts, ordered by account type, where the account's nickname does not end with '214202457276809450'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Account_Repay_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either have no outgoing Person_Invest_Company relationships or have incoming Account_Repay_Loan relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Find the phone numbers of accounts that do not withdraw from another account or own an account, ordered by phone number, up to 32 entries."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account]-()-[:Person_Own_Account]-(b:Account) WHERE NOT (a)-[:Person_Own_Account]-(b) WITH b ORDER BY b.lastLoginTime LIMIT 20 RETURN b.lastLoginTime",
    "answer": [
      {
        "b.lastLoginTime": "2020-06-24 16:46:53.614"
      },
      {
        "b.lastLoginTime": "2020-06-24 16:46:53.614"
      },
      {
        "b.lastLoginTime": "2020-08-18 23:32:48.069"
      },
      {
        "b.lastLoginTime": "2020-08-18 23:32:48.069"
      },
      {
        "b.lastLoginTime": "2020-08-28 07:47:58.196"
      },
      {
        "b.lastLoginTime": "2020-08-28 07:47:58.196"
      },
      {
        "b.lastLoginTime": "2020-08-30 10:11:20.444"
      },
      {
        "b.lastLoginTime": "2020-08-30 10:11:20.444"
      },
      {
        "b.lastLoginTime": "2020-08-30 10:11:20.444"
      },
      {
        "b.lastLoginTime": "2020-11-11 10:00:42.791"
      },
      {
        "b.lastLoginTime": "2020-11-11 10:00:42.791"
      },
      {
        "b.lastLoginTime": "2020-12-10 10:59:18.092"
      },
      {
        "b.lastLoginTime": "2020-12-10 10:59:18.092"
      },
      {
        "b.lastLoginTime": "2020-12-19 01:10:01.952"
      },
      {
        "b.lastLoginTime": "2020-12-19 01:10:01.952"
      },
      {
        "b.lastLoginTime": "2020-12-21 19:06:27.372"
      },
      {
        "b.lastLoginTime": "2020-12-21 19:06:27.372"
      },
      {
        "b.lastLoginTime": "2021-01-12 11:48:38.381"
      },
      {
        "b.lastLoginTime": "2021-01-28 19:39:50.104"
      },
      {
        "b.lastLoginTime": "2021-01-28 19:39:50.104"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the last login times of accounts that are indirectly owned by another account via Person_Own_Account relationships, excluding direct ownership relationships, ordered by last login time, limited to the top 20 entries."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.email) AS min_value",
    "answer": "37.com",
    "is_noise_query": true,
    "nlp": "Return the email that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the emails of accounts that have applied for a loan, ordered by email, up to 32 entries."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Company_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not apply for a loan through a company or invest in another company."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835283571"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407895618"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282675"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835284218"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285415626384607208"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the 10 accounts with the earliest last login times and then find the 10 accounts with the highest account levels associated with each of those 10 accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of unique account pairs where the first account has a different account type than the second account, ordered by the second account's last login time."
  },
  {
    "query": "MATCH (a:Account {email: '244320279784850805'})-[:Company_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.email = '244320279784850805' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of times an account with a specific email invests in another account after applying for a loan through a company, where the invested account also has the same specific email."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime = '244320279784850805' WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Retrieve accounts that do not have a specific create time, order them by account level, and return the first 32 account levels."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Company_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that either do not have any outgoing Account_Withdraw_Account relationships or have incoming Company_Invest_Company relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Find the count of accounts that either do not have any outgoing Person_Guarantee_Person relationships or have incoming Account_Repay_Loan relationships, and return these counts ordered by freqLoginType, limiting the result to the first 32."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Account) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "This query is incorrect as written since the UNION operation will always return two separate counts. Instead, describe the intent clearly: Calculate the total count of last login times across all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.nickname) AS min_value",
    "answer": "Aaron Nutting",
    "is_noise_query": true,
    "nlp": "Return the nickname that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Medium_SignIn_Account]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve accounts with a Medium_SignIn_Account relationship, order them by nickname, and return the first 32 nicknames."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Apply_Loan]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that either do not have any outgoing Person_Apply_Loan relationships or have incoming Account_Withdraw_Account relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:240661105087611876",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4854598923328685028",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4776911829756543545",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4878805771325802434",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:266556802944993218",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:205758207975490910",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4808155552171427166",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:250512729272484409",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4756082681479956519",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 accounts ordered by email, then for each of those, retrieve the top 10 accounts ordered by last login time."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct unblocked accounts, ensuring no account is paired with itself."
  },
  {
    "query": "MATCH (a:Account {email: '4660099714421621321'})-[:Person_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.createTime = '4660099714421621321' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of accounts with the specified email that are connected through the \"Person_Invest_Company\" relationship to other accounts, which then have a \"Medium_SignIn_Account\" relationship with an account created at the same timestamp as the specified email."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime = '4660099714421621321' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have the specified creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType <> '4660099714421621321' WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 login types from accounts that have a specific account type, ordered by their frequency of login type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a \"Loan_Deposit_Account\" relationship but may have a \"Company_Apply_Loan\" relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 creation times from accounts that have a \"Person_Apply_Loan\" relationship, ordered by their creation time."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account]-()-[:Person_Own_Account]-(b:Account) WHERE NOT (a)-[:Person_Own_Account]-(b) WITH b ORDER BY b.accountLevel LIMIT 20 RETURN b.accountLevel",
    "answer": [
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find accounts where there exists a path involving two \"Person_Own_Account\" relationships but no direct \"Person_Own_Account\" relationship between them, and return the account levels of the top 20 such accounts, ordered by their account level."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.mediumType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the earliest medium type alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level numerically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Person_Invest_Company]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 last login times from mediums that are involved in a \"Person_Invest_Company\" relationship, ordered by their last login time."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Repay_Loan]->(:Medium) OR (n)-[:Company_Apply_Loan]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have an \"Account_Repay_Loan\" relationship or have a \"Company_Apply_Loan\" relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1952",
        "b": "Medium:884"
      },
      {
        "a": "Medium:386",
        "b": "Medium:884"
      },
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1132",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:884"
      },
      {
        "a": "Medium:697",
        "b": "Medium:884"
      },
      {
        "a": "Medium:918",
        "b": "Medium:884"
      },
      {
        "a": "Medium:80",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1447",
        "b": "Medium:884"
      },
      {
        "a": "Medium:884",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the ten media with the lowest isBlocked values and then find the ten media with the earliest creation times among them."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.riskLevel RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of media where each pair consists of two different media, ordered by their risk level."
  },
  {
    "query": "MATCH (a:Medium {isBlocked: '43980465111721'})-[:Person_Apply_Loan]->(b:Medium) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Medium) WHERE c.lastLoginTime = '43980465111721' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of media that have both a Person_Apply_Loan relationship with another medium and a Medium_SignIn_Account relationship where the last login time matches a specific value."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType = '43980465111721' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count media that do not have a specific medium type."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked CONTAINS '43980465111721' WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 risk levels from media that do not contain a specific blocked status, ordered by risk level."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Medium) OR (a)-[:Person_Invest_Company]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count media that either do not have a specific relationship or have another specific relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Medium) OR (a)-[:Account_Transfer_Account]->(:Medium) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Find the thirty-two earliest creation times from media that have a Company_Guarantee_Company relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.riskLevel) AS min_value",
    "answer": "Critical risk",
    "is_noise_query": true,
    "nlp": "Return the risk level that comes first alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Guarantee_Company]->(:Medium) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 creation times from media that have a Company_Guarantee_Company relationship, ordered by creation time."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Invest_Company]->(:Medium) OR (n)-[:Company_Guarantee_Company]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Calculate the count of medium nodes that are not part of a specific person-invest-company relationship but may be part of a company-guarantee-company relationship."
  },
  {
    "query": "MATCH p = (a:Medium)-[:Medium_SignIn_Account *1..3]-(b:Medium) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Find the average path length of a specific pattern between media nodes, where the path can be 1, 2, or 3 steps long."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumType LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.riskLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:249",
        "b": "Medium:962"
      },
      {
        "a": "Medium:249",
        "b": "Medium:1196"
      },
      {
        "a": "Medium:249",
        "b": "Medium:1480"
      },
      {
        "a": "Medium:249",
        "b": "Medium:503"
      },
      {
        "a": "Medium:249",
        "b": "Medium:1650"
      },
      {
        "a": "Medium:249",
        "b": "Medium:1124"
      },
      {
        "a": "Medium:249",
        "b": "Medium:1875"
      },
      {
        "a": "Medium:249",
        "b": "Medium:86"
      },
      {
        "a": "Medium:249",
        "b": "Medium:680"
      },
      {
        "a": "Medium:249",
        "b": "Medium:1297"
      }
    ],
    "is_noise_query": true,
    "nlp": "First, select 10 media nodes ordered by their medium type, then from those, select another 10 media nodes ordered by their risk level, and return these two sets of nodes."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.riskLevel MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of media nodes excluding self-pairs, where the pairs are ordered by the second node's blocked status."
  },
  {
    "query": "MATCH (a:Medium {isBlocked: '52776558134575'})-[:Person_Apply_Loan]->(b:Medium) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Medium) WHERE c.riskLevel = '52776558134575' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of media nodes that have a person-apply-loan relationship leading to another medium, which itself has a loan-deposit-account relationship with a medium having a specific risk level."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime CONTAINS '52776558134575' WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 risk levels from media nodes that do not contain a specific blocked status, ordered by their risk level."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Transfer_Account]->(:Medium) OR (a)-[:Person_Own_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of media nodes that either do not have an account-transfer-account relationship or have a person-own-account relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Invest_Company]->(:Medium) OR (a)-[:Company_Own_Account]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 blocked statuses from media nodes that do not participate in a company-invest-company relationship but may participate in a company-own-account relationship, ordered by their blocked status."
  },
  {
    "query": "MATCH (a:Medium)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Medium) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the blocked status of up to 20 medium nodes that are indirectly connected through a specific pattern but are not directly connected by a medium-sign-in-account relationship, ordered by their blocked status."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-01-29 05:12:39.506",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all medium nodes."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 23:57:25.319",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Account_Withdraw_Account]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the first 32 isBlocked statuses from Mediums that have an Account_Withdraw_Account relationship, ordered by their isBlocked status."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Medium) OR (n)-[:Account_Repay_Loan]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Mediums that either do not have a Medium_SignIn_Account relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.mediumId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1132",
        "b": "Medium:19"
      },
      {
        "a": "Medium:386",
        "b": "Medium:19"
      },
      {
        "a": "Medium:697",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1447",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1952",
        "b": "Medium:19"
      },
      {
        "a": "Medium:86",
        "b": "Medium:19"
      },
      {
        "a": "Medium:80",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:19"
      },
      {
        "a": "Medium:918",
        "b": "Medium:19"
      },
      {
        "a": "Medium:884",
        "b": "Medium:19"
      }
    ],
    "is_noise_query": true,
    "nlp": "This query is not naturally described. It appears to aim at finding top 10 unblocked Mediums and then finding top 10 other Mediums related to these, but the NLP does not clearly express this intent. A clearer version could be: Return pairs of top 10 unblocked Mediums and top 10 other Mediums related to them, ordered by mediumId."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.mediumType RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Mediums where the second Medium is different from the first and ordered by mediumType."
  },
  {
    "query": "MATCH (a:Medium {lastLoginTime: '8796093023199'})-[:Company_Apply_Loan]->(b:Medium) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Medium) WHERE c.riskLevel = '8796093023199' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Mediums where there is a path from a Medium with a specific lastLoginTime through a Company_Apply_Loan relationship to another Medium with a specific riskLevel."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType CONTAINS '8796093023199' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Mediums whose mediumType does not contain '8796093023199'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked CONTAINS '8796093023199' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 creation times from Mediums that are not blocked and contain '8796093023199', ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Medium) OR (a)-[:Person_Own_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Mediums that either do not have a Person_Guarantee_Person relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Medium) OR (a)-[:Person_Apply_Loan]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 isBlocked statuses from Mediums that either do not have a Company_Guarantee_Company relationship or have a Person_Apply_Loan relationship, ordered by isBlocked status."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.createTime) AS cnt UNION MATCH (b:Medium) RETURN count(b.createTime) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Calculate the count of creation times for Medium nodes in two separate sets and return them."
  },
  {
    "query": "MATCH (a:Medium)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Medium) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.mediumType LIMIT 20 RETURN b.mediumType",
    "answer": [
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      },
      {
        "b.mediumType": "ATM"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find Medium nodes that have a path to another Medium node through the Medium_SignIn_Account relationship, ensuring no direct Medium_SignIn_Account relationship exists between them, and return the medium types of these nodes, limited to 20."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.interestRate) AS total_value",
    "answer": 116.34200000000003,
    "is_noise_query": true,
    "nlp": "Return the total sum of interest rates for all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.interestRate) AS max_value",
    "answer": 0.1,
    "is_noise_query": true,
    "nlp": "Find the maximum interest rate among all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Invest_Company]->(:Loan) WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the balances of the 32 loans with the highest balances where each loan has a Person_Invest_Company relationship leading to another Loan node, ordered by balance."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Invest_Company]->(:Loan) OR (n)-[:Company_Guarantee_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of loans that either do not have a Person_Invest_Company relationship or have a Company_Guarantee_Company relationship leading to another Loan node."
  },
  {
    "query": "MATCH (n:Loan) WHERE n.loanUsage <> '228557681089052778' OR (n)-[:Person_Invest_Company]->(:Loan) RETURN avg(n.loanAmount)",
    "answer": 48819411.184508234,
    "is_noise_query": true,
    "nlp": "Calculate the average loan amount for loans that either do not have a specific usage of '228557681089052778' or have a Person_Invest_Company relationship leading to another Loan node."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanId LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:29836347531329650",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:37436171902517700",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:23643898043696390",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:27584547717644754",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:27303072740934442",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:34058472181990599",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:19140298416325639",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:17169973579351110",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:37436171902518055",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 loans ordered by loan ID, then for each of those, return the next 10 loans ordered by loan ID."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count the number of distinct loan pairs (excluding self-pairs) where the first loan has a higher balance than the second loan, and the second loan has a higher interest rate than the first loan, and return this count."
  },
  {
    "query": "MATCH (a:Loan {balance: '228557681089052778'})-[:Account_Withdraw_Account]->(b:Loan) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Loan) WHERE c.createTime = '228557681089052778' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Collect up to 32 loans where there is a specific relationship between two loans, and a further relationship with another loan created at a specific time, then return the total count."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance <> '228557681089052778' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Count loans with a balance matching a specific value, order these loans by interest rate, and return the first 32 interest rates."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Loan_Deposit_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Return the count of loans that either do not have a person guaranteeing them or have a deposit account related to them."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Apply_Loan]->(:Loan) OR (a)-[:Person_Guarantee_Person]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS vals",
    "answer": [
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures"
    ],
    "is_noise_query": true,
    "nlp": "Find and return up to 32 loan usages for loans that either do not apply for a company loan or have a person guaranteeing them, ordered by loan usage."
  },
  {
    "query": "MATCH (a:Loan) RETURN count(a.createTime) AS cnt UNION MATCH (b:Loan) RETURN count(b.createTime) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of loan creation times and return this count twice, once for each match pattern."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum isBlocked value among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 07:23:57.080",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Own_Account]->(:Company) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 cities from companies that own accounts, ordered by city."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Company_Own_Account]->(:Company) OR (n)-[:Account_Withdraw_Account]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Return the count of companies that either do not own an account or have a withdrawal account related to them."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.city LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:13194139534270",
        "b": "Company:14293651161100"
      },
      {
        "a": "Company:13194139534270",
        "b": "Company:5497558139444"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:8796093022277"
      },
      {
        "a": "Company:13194139534270",
        "b": "Company:8796093022277"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:14293651161100"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:14293651161100"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:5497558139444"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:8796093022277"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:5497558139444"
      },
      {
        "a": "Company:2199023255941",
        "b": "Company:5497558139444"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 companies ordered by business, then within those, find the top 10 companies ordered by city, and return both sets of companies."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.createTime MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Find pairs of distinct companies, ordered first by the creation time of the first company and then by the creation time of the second company, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Company {createTime: '8796093022934'})-[:Person_Apply_Loan]->(b:Company) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Company) WHERE c.url = '8796093022934' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find companies that have applied for loans from a specific company with a createTime of '8796093022934', and also have an account transfer to another specific company with a URL of '8796093022934', then count these instances."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.companyName ENDS WITH '8796093022934' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies whose names do not end with the specific string '8796093022934'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.country = '8796093022934' WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [
      "Abortion Clinic",
      "Accountant",
      "Accounting Firm",
      "Accounting School",
      "Acoustical Consultant",
      "Acrobatic Diving Pool",
      "Aerobics Instructor",
      "Afghani Restaurant",
      "Aggregate Supplier",
      "Agricultural Association",
      "Aikido School",
      "Air Compressor Supplier",
      "Air Conditioning Repair Service",
      "Air Conditioning Store",
      "Airbrushing Service",
      "Aircraft Rental Service",
      "Airline",
      "Airline",
      "Alcohol Manufacturer",
      "Alcohol Retail Monopoly",
      "Alcoholism Treatment Program",
      "Alternator Supplier",
      "Aluminum Window",
      "Ambulance Service",
      "Amusement Center",
      "Amusement Ride Supplier",
      "Andalusian Restaurant",
      "Anesthesiologist",
      "Anglican Church",
      "Animation Studio",
      "Apartment Building",
      "Apartment Building"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 business types of companies that do not belong to the specific country '8796093022934', ordered by their business type."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Company) OR (a)-[:Account_Transfer_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that either do not have a loan deposit account relationship with any other company or have an account transfer account relationship with any other company."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Company) OR (a)-[:Person_Invest_Company]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 company names of entities that do not have a person guaranteeing another person relationship but do have a person investing in a company relationship, ordered by company name."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.birthday) AS min_value",
    "answer": "1980-01-08",
    "is_noise_query": true,
    "nlp": "Find the earliest birthday among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.birthday) AS max_value",
    "answer": "1999-12-31",
    "is_noise_query": true,
    "nlp": "Find the latest birthday among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Own_Account]->(:Person) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return up to 32 cities of persons who own an account and are connected through a company, ordered by city."
  },
  {
    "query": "MATCH (n:Person) WHERE (n)-[:Account_Repay_Loan]->(:Person) OR (n)-[:Person_Guarantee_Person]->(:Person) RETURN count(n) AS cnt",
    "answer": 511,
    "is_noise_query": true,
    "nlp": "Count the number of persons who either repay a loan or guarantee another person."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Company_Apply_Loan]->(:Person) OR (n)-[:Loan_Deposit_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons who either do not apply for a company loan or have a loan deposit account."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personId LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.country LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:24",
        "b": "Person:24189255811977"
      },
      {
        "a": "Person:4",
        "b": "Person:24189255811977"
      },
      {
        "a": "Person:24",
        "b": "Person:13194139533426"
      },
      {
        "a": "Person:24",
        "b": "Person:21990232555896"
      },
      {
        "a": "Person:4",
        "b": "Person:13194139533426"
      },
      {
        "a": "Person:4",
        "b": "Person:17592186044635"
      },
      {
        "a": "Person:4",
        "b": "Person:21990232555896"
      },
      {
        "a": "Person:4",
        "b": "Person:26388279066767"
      },
      {
        "a": "Person:24",
        "b": "Person:17592186044635"
      },
      {
        "a": "Person:24",
        "b": "Person:26388279066767"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find and return two sets of ten persons each: the first set is ordered by person ID, and from this set, find another set of ten persons ordered by country, returning both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.country MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Find pairs of distinct persons where the first set is ordered by country and the second set is ordered by creation time, then return the count of such pairs."
  },
  {
    "query": "MATCH (a:Person), (b:Person) WHERE a.city = b.personName AND a <> b WITH a, count(b) AS cnt WHERE cnt > 0 RETURN a",
    "answer": [
      {
        "a": {
          "birthday": "1982-12-03",
          "personName": "Albar",
          "country": "Brazil",
          "gender": "male",
          "createTime": "2022-03-29 19:34:50.808",
          "city": "Santos",
          "isBlocked": false,
          "personId": 21990232555698,
          "_node_id": "Person:21990232555698"
        }
      }
    ],
    "is_noise_query": true,
    "nlp": "Return persons who have at least one match with another person where their city name matches their person name."
  },
  {
    "query": "MATCH (a:Person {personName: '10995116278153'})-[:Medium_SignIn_Account]->(b:Person) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Person) WHERE c.isBlocked = '10995116278153' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of instances where a specific person has signed into and invested in companies, with those companies having blocked accounts."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.personName ENDS WITH '10995116278153' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons whose names do not end with a specific string."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.personName STARTS WITH '10995116278153' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 creation times of persons whose names do not start with a specific string, ordered by creation time."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Person) OR (a)-[:Loan_Deposit_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons who either do not guarantee a company or have a loan deposit account."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Person) OR (a)-[:Person_Invest_Company]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 creation times of persons who do not have a loan deposit account but may invest in a company, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.freqLoginType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the earliest frequent login type alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return up to 32 account types of accounts that are owned by another account, ordered by account type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have a withdrawal relationship with any other account or are involved in a guarantee relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by their frequency of login type, then among these, find the top 10 accounts ordered by account type, and return both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.phonenum RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find pairs of distinct accounts where the first account is ordered by frequency of login type and the second account by phone number, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Account {isBlocked: '4878524296349089946'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Account_Repay_Loan]->(c:Account) WHERE c.freqLoginType = '4878524296349089946' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of instances where a specific blocked account has withdrawn from another account and those accounts have repaid loans to an account with a specific frequency of login type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel ENDS WITH '4878524296349089946' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose levels do not end with a specific string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType ENDS WITH '4878524296349089946' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 last login times of accounts whose login types do not end with a specific string, ordered by last login time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Invest_Company]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not invest in a company but may withdraw from an account."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 last login times of accounts that do not sign in via medium but may transfer accounts, ordered by last login time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountLevel) AS min_value",
    "answer": "Basic level",
    "is_noise_query": true,
    "nlp": "Return the lowest account level alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.phonenum) AS max_value",
    "answer": "999-9198",
    "is_noise_query": true,
    "nlp": "Find the phone number that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return up to 32 phone numbers of accounts that have been involved in a withdrawal transaction from another account, ordered by phone number."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Company_Guarantee_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not participate in any account transfers or are part of a company guarantee relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account *1..4]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3200,
    "is_noise_query": true,
    "nlp": "Count the number of accounts reachable within one to four hops through the \"Person_Owns_Account\" relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835283571"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407895618"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282675"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835284218"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285415626384607208"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 accounts ordered by creation time and then find the top 10 accounts ordered by account level among them, returning both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.nickname RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of unique account pairs where each account is different, ordered by nickname."
  },
  {
    "query": "MATCH (a:Account {accountType: '4874302171698430090'})-[:Medium_SignIn_Account]->(b:Account) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Account) WHERE c.accountType = '4874302171698430090' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of accounts where an account with a specific account type signs in via a medium and guarantees another account of the same type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email CONTAINS '4874302171698430090' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find and return the count of accounts whose email does not contain the specified string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email ENDS WITH '4874302171698430090' WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Find the top 32 account levels among accounts whose email does not end with the specified string, ordered by account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that have not signed in via a medium method or have withdrawn from another account."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 nicknames of accounts whose last login times do not end with a specific string, ordered by nickname."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.createTime) AS cnt UNION MATCH (b:Account) RETURN count(b.createTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts created, using two separate matches and then unioning the results."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account]-()-[:Company_Own_Account]-(b:Account) WHERE NOT (a)-[:Company_Own_Account]-(b) WITH b ORDER BY b.lastLoginTime LIMIT 20 RETURN b.lastLoginTime",
    "answer": [
      {
        "b.lastLoginTime": "2020-06-11 05:14:46.792"
      },
      {
        "b.lastLoginTime": "2020-06-11 05:14:46.792"
      },
      {
        "b.lastLoginTime": "2020-07-27 13:03:02.659"
      },
      {
        "b.lastLoginTime": "2020-07-27 13:03:02.659"
      },
      {
        "b.lastLoginTime": "2020-09-03 06:58:23.591"
      },
      {
        "b.lastLoginTime": "2020-09-03 06:58:23.591"
      },
      {
        "b.lastLoginTime": "2020-09-03 06:58:23.591"
      },
      {
        "b.lastLoginTime": "2020-09-23 03:39:36.501"
      },
      {
        "b.lastLoginTime": "2020-10-28 19:27:36.434"
      },
      {
        "b.lastLoginTime": "2020-11-12 05:48:37.974"
      },
      {
        "b.lastLoginTime": "2020-11-12 05:48:37.974"
      },
      {
        "b.lastLoginTime": "2020-11-12 05:48:37.974"
      },
      {
        "b.lastLoginTime": "2021-01-11 08:49:41.025"
      },
      {
        "b.lastLoginTime": "2021-01-11 08:49:41.025"
      },
      {
        "b.lastLoginTime": "2021-01-11 08:49:41.025"
      },
      {
        "b.lastLoginTime": "2021-01-19 16:15:08.017"
      },
      {
        "b.lastLoginTime": "2021-01-19 16:15:08.017"
      },
      {
        "b.lastLoginTime": "2021-01-22 02:19:33.987"
      },
      {
        "b.lastLoginTime": "2021-01-22 02:19:33.987"
      },
      {
        "b.lastLoginTime": "2021-01-27 10:58:22.658"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return up to 20 last login times of accounts that are part of a chain where no direct ownership link exists between them, ordered by last login time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the frequent login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return up to 32 creation times of accounts that have applied for a loan, ordered by creation time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Company_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that have not applied for a loan but may have invested in another company."
  },
  {
    "query": "MATCH p = (a:Account)-[:Person_Own_Account *2..2]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths where an account owns another account exactly two steps away."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896538694858572073"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407894741"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835283081"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835284218"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 accounts with the lowest phone numbers and the top 10 accounts with the lowest isBlocked status, ordered separately by their respective criteria."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the number of unique account pairs where the first account's email is ordered alphabetically and the second account's account type is also ordered alphabetically, excluding self-pairing."
  },
  {
    "query": "MATCH (a:Account {nickname: '141018963332039683'})-[:Person_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.accountType = '141018963332039683' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of accounts that have been invested in by the specified person and then invest in another company with the specified account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime ENDS WITH '141018963332039683' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Return the last 32 login times of accounts whose last login time does not end with a specific identifier, ordered by their last login time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have any outgoing Person_Invest_Company relationships or have an outgoing Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the blocked status of accounts that do not transfer funds to another account but withdraw from an account, ordered by their blocked status, and return the first 32 entries."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.freqLoginType) AS cnt UNION MATCH (b:Account) RETURN count(b.freqLoginType) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Combine the count of distinct frequency login types of all accounts into a single result set."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.loanAmount) AS avg_value",
    "answer": 48819411.184508234,
    "is_noise_query": true,
    "nlp": "Calculate the average loan amount across all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.interestRate) AS total_value",
    "answer": 116.34200000000003,
    "is_noise_query": true,
    "nlp": "Calculate the total interest rate across all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.interestRate) AS max_value",
    "answer": 0.1,
    "is_noise_query": true,
    "nlp": "Find the maximum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Account_Repay_Loan]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve the creation times of the first 32 loans that have at least one outgoing Account_Repay_Loan relationship, ordered by their creation time."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Loan) OR (n)-[:Medium_SignIn_Account]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that do not have a Company_Guarantee_Company relationship or have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH p = (a:Loan)-[:Company_Apply_Loan *2..3]-(b:Loan) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths of 2 to 3 hops along the Company_Apply_Loan relationship between loans."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.balance LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4635892866424505367",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:27303072740934442",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:19140298416325639",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:23643898043696390",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:4636174341401215196",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:4628574517030027418",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:17169973579351110",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:4633641066610819901",
        "b": "Loan:4784511654127731833"
      },
      {
        "a": "Loan:27584547717644754",
        "b": "Loan:4784511654127731833"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 oldest loans and then from those, return the top 10 loans with the lowest balance."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.loanUsage RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans where the first loan is older than the second and the second loan has a higher loan usage."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.balance = b.balance AND a <> b WITH a, count(b) AS cnt WHERE cnt > 0 RETURN a",
    "answer": [
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-06-11 10:55:03.271",
          "loanUsage": "business ventures",
          "_node_id": "Loan:250794204249195062",
          "loanId": 250794204249195062,
          "loanAmount": 14514821.0
        }
      },
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-05-31 08:24:48.513",
          "loanUsage": "business ventures",
          "_node_id": "Loan:4859383997932765750",
          "loanId": 4859383997932765750,
          "loanAmount": 14514821.0
        }
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-09-12 23:10:13.706",
          "loanUsage": "renovations",
          "_node_id": "Loan:277252852059997235",
          "loanId": 277252852059997235,
          "loanAmount": 90419964.0
        }
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-06-25 17:52:38.863",
          "loanUsage": "renovations",
          "_node_id": "Loan:4866420872350532659",
          "loanId": 4866420872350532659,
          "loanAmount": 90419964.0
        }
      }
    ],
    "is_noise_query": true,
    "nlp": "Find loans with a specific loan amount and count how many other loans have the same balance."
  },
  {
    "query": "MATCH (a:Loan {loanAmount: '4748201382132056246'})-[:Person_Apply_Loan]->(b:Loan) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Loan) WHERE c.balance = '4748201382132056246' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans whose loan usage does not start with a specific string, ordering by balance and collecting up to 32 balances."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage STARTS WITH '4748201382132056246' WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [
      61.51,
      62.37,
      111.44,
      201.44,
      263.89,
      562.45,
      769.15,
      971.05,
      1364.68,
      1474.58,
      1850.89,
      1859.25,
      2638.41,
      2741.97,
      2831.06,
      3021.97,
      3313.09,
      3690.54,
      3885.13,
      4801.41,
      5296.98,
      5491.24,
      8423.84,
      8930.37,
      9107.76,
      9378.97,
      9554.96,
      11339.17,
      11665.03,
      11785.13,
      12075.02,
      12430.63
    ],
    "is_noise_query": true,
    "nlp": "Count loans that do not have a Person_Guarantee_Person relationship or have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Medium_SignIn_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Find the top 32 creation times of loans that do not have an outgoing Company_Apply_Loan relationship but may have an incoming Person_Apply_Loan relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Apply_Loan]->(:Loan) OR (a)-[:Person_Apply_Loan]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Sum the interest rates of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.interestRate) AS total_value",
    "answer": 116.34200000000003,
    "is_noise_query": true,
    "nlp": "Find the total sum of interest rates among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanAmount) AS min_value",
    "answer": 88778.0,
    "is_noise_query": true,
    "nlp": "Find the minimum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:41:50.010",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Medium_SignIn_Account]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the creation times of the first 32 loans with a Medium_SignIn_Account relationship, ordered by creation time."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Company_Invest_Company]->(:Loan) OR (n)-[:Person_Invest_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that do not have a Company_Invest_Company relationship or have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account *1..2]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 21118,
    "is_noise_query": true,
    "nlp": "Count loans that have between 1 and 2 Loan_Deposit_Account relationships."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:246290604621824990",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:282319401640788972",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4863606122583425208",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4768467580455223872",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4885842645743567395",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4835740099889070948",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4877116921465536915",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4892598045184622708",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 loans with the highest balance and then from those, return the top 10 loans with the earliest creation time."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans where the first loan has a higher balance than the second and the second loan has a higher interest rate."
  },
  {
    "query": "MATCH (a:Loan {balance: '4884716745836724815'})-[:Company_Invest_Company]->(b:Loan) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Loan) WHERE c.interestRate = '4884716745836724815' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find loans with a specific balance and follow the Company_Invest_Company relationship to another loan, then check if there's another loan with the same interest rate connected through the same relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.interestRate <> '4884716745836724815' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the top 32 creation times of loans with a specific interest rate, ordered by creation time."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Own_Account]->(:Loan) OR (a)-[:Company_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that do not have a Person_Own_Account relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Invest_Company]->(:Loan) OR (a)-[:Company_Invest_Company]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Find the top 32 loan amounts among loans that do not have a Company_Invest_Company relationship or do have such a relationship, ordered by loan amount."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.email) AS min_value",
    "answer": "37.com",
    "is_noise_query": true,
    "nlp": "Return the email that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the top 32 last login times of accounts that have a Loan_Deposit_Account relationship, ordered by last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Invest_Company]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a Company_Invest_Company relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:64176294690031206",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4661507089305174028",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4644337115725825070",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4671077238513337662",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4662070039258597186",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:41095346599755900",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4672766088373601934",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:45035996273706602",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 accounts with the earliest last login time and then from those, return the top 10 accounts with the earliest creation time."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the first account has a higher nickname ranking than the second and the second account has an earlier creation time."
  },
  {
    "query": "MATCH (a:Account {createTime: '127226689473216529'})-[:Person_Guarantee_Person]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.phonenum = '127226689473216529' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find accounts with a specific create time and follow the Person_Guarantee_Person relationship to another account, then check if there's another account with the same phone number connected through the Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname ENDS WITH '127226689473216529' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose nickname does not end with a specific string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime STARTS WITH '127226689473216529' WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Return phone numbers of accounts whose creation time does not start with '127226689473216529', ordered by phone number, limited to the first 32."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a Company_Own_Account relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Return the top 32 account levels of accounts that do not have an Account_Repay_Loan relationship or have a Person_Invest_Company relationship, ordered by account level."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.phonenum) AS cnt UNION MATCH (b:Account) RETURN count(b.phonenum) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "This query is already good."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.freqLoginType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Find the minimum frequency login type among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Return the frequent login type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the highest account level among all accounts."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Account) OR (n)-[:Loan_Deposit_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the top 32 account types of accounts that have an Account_Withdraw_Account relationship, ordered by account type."
  },
  {
    "query": "MATCH p = (a:Account)-[:Company_Own_Account *2..2]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have an Account_Withdraw_Account relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "This query is already good."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the count of unique account pairs where each account has a different account type and is ordered by account level."
  },
  {
    "query": "MATCH (a:Account {lastLoginTime: '4894849844998308538'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Account_Repay_Loan]->(c:Account) WHERE c.freqLoginType = '4894849844998308538' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of accounts that have both an Account_Withdraw_Account relationship from a specific account and an Account_Repay_Loan relationship to another account with a matching freqLoginType."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType ENDS WITH '4894849844998308538' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the freqLoginType does not end with '4894849844998308538'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname <> '4894849844998308538' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 account types of accounts where the nickname matches '4894849844998308538', ordered by account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Person_Apply_Loan relationship or have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 phone numbers of accounts where there is no Account_Repay_Loan relationship but there is a Person_Guarantee_Person relationship, ordered by phone number."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Account) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the isBlocked status of the top 20 accounts that are not directly connected through a Medium_SignIn_Account relationship, ordered by isBlocked status."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.email) AS min_value",
    "answer": "37.com",
    "is_noise_query": true,
    "nlp": "Return the email that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the highest account level value among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 isBlocked statuses of accounts that have a Company_Own_Account relationship, ordered by isBlocked status."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Account) OR (n)-[:Person_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Find accounts that do not have outgoing Account_Withdraw_Account relationships or have incoming Person_Invest_Company relationships, and return the count of such accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835282663",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282792",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407895802",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4897664594765414427",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285697101361316562",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4897101644811994893",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4897664594765414705",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4897101644811993938",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:286541526291449090",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "Match accounts, sort them by account type, limit to 10, then match other accounts, sort these by email, limit to 10, and return both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find pairs of distinct accounts where the first is ordered by account type and the second by whether they are blocked, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Account {freqLoginType: '284008251501053398'})-[:Account_Transfer_Account]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.accountLevel = '284008251501053398' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find accounts that have received transfers from an account with a specific freqLoginType, and have invested in another account with a specific accountLevel, then return the count of these connections."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel ENDS WITH '284008251501053398' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of accounts whose accountLevel does not end with a specific identifier."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime = '284008251501053398' WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Order accounts by phone number, excluding those with a specific creation time, and return the first 32 phone numbers."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of accounts that either do not apply for loans or withdraw from accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Invest_Company]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Order accounts by last login time, excluding those that invest in companies unless they also withdraw from accounts, and return the first 32 last login times."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.accountId LIMIT 20 RETURN b.accountId",
    "answer": [
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 23080948090274944
      },
      {
        "b.accountId": 27584547717644507
      },
      {
        "b.accountId": 27584547717644507
      },
      {
        "b.accountId": 27584547717644507
      }
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that are part of a Loan_Deposit_Account relationship chain of length 3, where the start and end accounts are not directly linked by a Loan_Deposit_Account relationship, and return up to 20 unique account IDs."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 03:31:14.114",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.mediumType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the mediumType that comes last alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Loan_Deposit_Account]->(:Medium) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the creation times of Medium nodes that have a Loan_Deposit_Account relationship with another Medium node, ordered by their creation time, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Apply_Loan]->(:Medium) OR (n)-[:Account_Withdraw_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either don't have a Person_Apply_Loan relationship or do have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumType LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.mediumId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:680",
        "b": "Medium:19"
      },
      {
        "a": "Medium:386",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1983",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1728",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1861",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1897",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1551",
        "b": "Medium:19"
      },
      {
        "a": "Medium:20",
        "b": "Medium:19"
      },
      {
        "a": "Medium:249",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1718",
        "b": "Medium:19"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 Medium nodes ordered by medium type, then for each of these, retrieve the top 10 Medium nodes ordered by medium ID, and return both sets of nodes."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Medium nodes where the first node's last login time is considered, and the second node's creation time is used for ordering, ensuring the nodes are different."
  },
  {
    "query": "MATCH (a:Medium {riskLevel: '1931'})-[:Company_Apply_Loan]->(b:Medium) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Medium) WHERE c.createTime = '1931' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that have a Company_Apply_Loan relationship with another Medium node and also have a Company_Invest_Company relationship with a Medium node created in 1931."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel CONTAINS '1931' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that do not have a risk level containing '1931'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked STARTS WITH '1931' WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the medium types of Medium nodes whose isBlocked property does not start with '1931', ordered by medium type, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Medium) OR (a)-[:Medium_SignIn_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either don't have a Loan_Deposit_Account relationship or do have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Medium) OR (a)-[:Company_Guarantee_Company]->(:Medium) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Collect the creation times of Medium nodes that either don't have a Person_Guarantee_Person relationship or do have a Company_Guarantee_Company relationship, ordered by creation time, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Medium) RETURN count(b.isBlocked) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Combine counts of blocked status from two sets of Medium nodes into a single result set."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the most frequent login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the email addresses of Account nodes that have a Person_Invest_Company relationship with another Account node, ordered by email, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Account) OR (n)-[:Person_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either don't have a Person_Guarantee_Person relationship or do have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896538694858572073"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407894741"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835283081"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835284218"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve pairs of Account nodes, first selecting 10 accounts ordered by account type, then for each of those, select 10 additional accounts ordered by isBlocked status, and return both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of pairs of distinct Account nodes, where the first set is ordered by account type and the second set is ordered by isBlocked status."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4794081803335893483'})-[:Person_Guarantee_Person]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.phonenum = '4794081803335893483' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that are guaranteed by an Account with a specific account level and also have a Medium_SignIn_Account relationship with an Account that matches a specific phone number."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel = '4794081803335893483' WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect the phone numbers of Account nodes that do not match a specific account level, ordered by phone number, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either don't have a Company_Guarantee_Company relationship or do have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the frequency login types of Account nodes that either don't have outgoing Account_Repay_Loan relationships or do have Company_Guarantee_Company relationships, ordered by frequency login type, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account]-()-[:Person_Own_Account]-(b:Account) WHERE NOT (a)-[:Person_Own_Account]-(b) WITH b ORDER BY b.lastLoginTime LIMIT 20 RETURN b.lastLoginTime",
    "answer": [
      {
        "b.lastLoginTime": "2020-06-24 16:46:53.614"
      },
      {
        "b.lastLoginTime": "2020-06-24 16:46:53.614"
      },
      {
        "b.lastLoginTime": "2020-08-18 23:32:48.069"
      },
      {
        "b.lastLoginTime": "2020-08-18 23:32:48.069"
      },
      {
        "b.lastLoginTime": "2020-08-28 07:47:58.196"
      },
      {
        "b.lastLoginTime": "2020-08-28 07:47:58.196"
      },
      {
        "b.lastLoginTime": "2020-08-30 10:11:20.444"
      },
      {
        "b.lastLoginTime": "2020-08-30 10:11:20.444"
      },
      {
        "b.lastLoginTime": "2020-08-30 10:11:20.444"
      },
      {
        "b.lastLoginTime": "2020-11-11 10:00:42.791"
      },
      {
        "b.lastLoginTime": "2020-11-11 10:00:42.791"
      },
      {
        "b.lastLoginTime": "2020-12-10 10:59:18.092"
      },
      {
        "b.lastLoginTime": "2020-12-10 10:59:18.092"
      },
      {
        "b.lastLoginTime": "2020-12-19 01:10:01.952"
      },
      {
        "b.lastLoginTime": "2020-12-19 01:10:01.952"
      },
      {
        "b.lastLoginTime": "2020-12-21 19:06:27.372"
      },
      {
        "b.lastLoginTime": "2020-12-21 19:06:27.372"
      },
      {
        "b.lastLoginTime": "2021-01-12 11:48:38.381"
      },
      {
        "b.lastLoginTime": "2021-01-28 19:39:50.104"
      },
      {
        "b.lastLoginTime": "2021-01-28 19:39:50.104"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the last login times of Account nodes that are connected through Person_Own_Account relationships but are not directly linked by Person_Own_Account, ordered by last login time, and return the top 20 values."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-01-29 05:12:39.506",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all Medium nodes."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level among all Medium nodes."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Guarantee_Company]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the last login times of Medium nodes that have outgoing Company_Guarantee_Company relationships, ordered by last login time, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Repay_Loan]->(:Medium) OR (n)-[:Person_Guarantee_Person]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either don't have outgoing Account_Repay_Loan relationships or do have Person_Guarantee_Person relationships."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1132",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1952",
        "b": "Medium:884"
      },
      {
        "a": "Medium:80",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1447",
        "b": "Medium:884"
      },
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:884"
      },
      {
        "a": "Medium:884",
        "b": "Medium:884"
      },
      {
        "a": "Medium:918",
        "b": "Medium:884"
      },
      {
        "a": "Medium:697",
        "b": "Medium:884"
      },
      {
        "a": "Medium:386",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve pairs of Medium nodes ordered by creation time, limiting results to 10 from each step."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.mediumType RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Medium nodes, where the first node is ordered by isBlocked status and the second node is ordered by mediumType."
  },
  {
    "query": "MATCH (a:Medium {mediumType: '48378511623261'})-[:Company_Own_Account]->(b:Medium) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Medium) WHERE c.createTime = '48378511623261' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that meet specific ownership and loan conditions, starting from a Medium with a specific mediumType and ending with a Medium created at a specific time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType ENDS WITH '48378511623261' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes whose mediumType does not end with '48378511623261'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime STARTS WITH '48378511623261' WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Match medium nodes where the create time does not start with '48378511623261', then order by medium type and return the first 32 types."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Medium) OR (a)-[:Person_Guarantee_Person]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either do not have a Loan_Deposit_Account relationship or do have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Invest_Company]->(:Medium) OR (a)-[:Medium_SignIn_Account]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked statuses of Medium nodes with specific sign-in relationships, ordered by isBlocked, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the account levels of Account nodes that have an Account_Transfer_Account relationship, ordered by account level, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Apply_Loan]->(:Account) OR (n)-[:Company_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Identify the number of Account nodes that either do not have a Person_Apply_Loan relationship or do have a Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:240661105087611876",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4854598923328685028",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4808155552171427166",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4878805771325802434",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:250512729272484409",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:266556802944993218",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:205758207975490910",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4776911829756543545",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4756082681479956519",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve pairs of Account nodes, where the first set is ordered by email and limited to 10, and the second set is ordered by creation time and also limited to 10."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Account nodes, where the nodes are different, ordered by last login time."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4874020696721720324'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Account) WHERE c.phonenum = '4874020696721720324' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Retrieve the count of paths from an Account with a specific account level through a Company_Invest_Company relationship to another Account, which then has a Person_Guarantee_Person relationship with an Account matching a specific phone number."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel <> '4874020696721720324' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked statuses of Account nodes where the accountLevel is '4874020696721720324', ordered by their isBlocked status, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either do not have an outgoing Account_Withdraw_Account relationship or have an incoming Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Company_Invest_Company]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect the phonenumbers of Account nodes that either do not have an incoming Person_Apply_Loan relationship or have an outgoing Company_Invest_Company relationship, ordered by phonenum, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.riskLevel) AS min_value",
    "answer": "Critical risk",
    "is_noise_query": true,
    "nlp": "Return the minimum riskLevel among all Medium nodes, considering alphabetical order for string values."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all Medium nodes, interpreting isBlocked as a string for lexicographic comparison."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Medium_SignIn_Account]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked statuses of Medium nodes that have an incoming Medium_SignIn_Account relationship, ordered by their isBlocked status, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Own_Account]->(:Medium) OR (n)-[:Account_Transfer_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either do not have an outgoing Person_Own_Account relationship or have an incoming Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.riskLevel LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:680",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1480",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1875",
        "b": "Medium:884"
      },
      {
        "a": "Medium:503",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1650",
        "b": "Medium:884"
      },
      {
        "a": "Medium:962",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1196",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1124",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1297",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Identify the top 10 Medium nodes with the lowest riskLevels, then from these, identify the top 10 Medium nodes with the most recent creation times, and return these pairs."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumType MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of Medium nodes where the first node's mediumType is different from the second node's, and the second node's lastLoginTime is considered for ordering."
  },
  {
    "query": "MATCH (a:Medium {mediumType: '101'})-[:Company_Apply_Loan]->(b:Medium) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Medium) WHERE c.isBlocked = '101' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes where the first node has a mediumType of '101', there is a Company_Apply_Loan relationship leading to a second node, and the second node has a Loan_Deposit_Account relationship leading to a third node with isBlocked set to '101'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime STARTS WITH '101' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Retrieve the count of Medium nodes where the create time does not start with '101'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType STARTS WITH '101' WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Find the risk levels of Medium nodes where the medium type does not start with '101', ordered by risk level, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Invest_Company]->(:Medium) OR (a)-[:Person_Invest_Company]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the Medium nodes that do not have any relationships to other Medium nodes via Company_Invest_Company or Person_Invest_Company."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Person_Apply_Loan]->(:Medium) OR (a)-[:Person_Own_Account]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-01-29 05:12:39.506",
      "2020-02-03 17:46:43.836",
      "2020-02-15 19:29:12.059",
      "2020-03-07 12:38:42.833",
      "2020-03-12 20:53:48.093",
      "2020-03-20 08:34:41.767",
      "2020-03-28 05:20:45.915",
      "2020-04-02 18:27:25.513",
      "2020-04-03 19:25:08.930",
      "2020-04-05 16:30:10.209",
      "2020-04-08 12:15:42.926",
      "2020-04-19 15:31:53.628",
      "2020-04-30 08:24:02.358",
      "2020-05-17 13:12:15.150",
      "2020-05-18 06:16:54.756",
      "2020-05-19 10:29:57.660",
      "2020-05-24 18:06:27.871",
      "2020-05-28 09:43:48.217",
      "2020-05-29 05:26:41.843",
      "2020-06-05 17:35:15.999",
      "2020-06-06 14:42:45.787",
      "2020-06-18 21:36:31.467",
      "2020-06-21 18:28:14.001",
      "2020-06-22 17:25:34.472",
      "2020-06-23 10:15:27.445",
      "2020-06-25 22:58:42.936",
      "2020-07-01 07:39:30.970",
      "2020-07-04 05:11:00.922",
      "2020-07-07 11:59:49.304",
      "2020-07-09 23:56:58.844",
      "2020-07-12 12:44:05.479",
      "2020-07-16 23:19:43.551"
    ],
    "is_noise_query": true,
    "nlp": "Collect the last login times of Medium nodes that do not have a relationship to another Medium node via Person_Apply_Loan but do have a relationship via Person_Own_Account, ordered by last login time, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountLevel) AS min_value",
    "answer": "Basic level",
    "is_noise_query": true,
    "nlp": "Return the minimum account level among all accounts, considering lexicographic order for string values."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the last login times of accounts that have a relationship to another account via Account_Repay_Loan, ordered by last login time, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Account) OR (n)-[:Medium_SignIn_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the accounts that do not have a relationship to another account via Company_Guarantee_Company but do have a relationship via Medium_SignIn_Account."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835283081",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282792",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407894843",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896538694858572073",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282970",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407895701",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284135",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407894741",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of Account nodes ordered by is blocked and email, limiting results to 10 from each step."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts ordered by their blocked status after ordering by account level."
  },
  {
    "query": "MATCH (a:Account {nickname: '4833206825098675956'})-[:Person_Guarantee_Person]->(b:Account) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Account) WHERE c.lastLoginTime = '4833206825098675956' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections between an account with nickname '4833206825098675956' and other accounts through the Person_Guarantee_Person and Person_Invest_Company relationships, where the target account's last login time matches '4833206825098675956', and return the total count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum CONTAINS '4833206825098675956' WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 frequency login types from accounts whose phone numbers do not contain '4833206825098675956', ordered by their frequency login type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Person_Own_Account relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Apply_Loan]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 nicknames from accounts that do not have a Company_Apply_Loan relationship or have a Company_Guarantee_Company relationship, ordered by nickname."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Account) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of distinct last login times in the account dataset."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the highest account level among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account levels from accounts that have a Company_Own_Account relationship, ordered by account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Account) OR (n)-[:Account_Repay_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a Loan_Deposit_Account relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH p = (a:Account)-[:Loan_Deposit_Account *1..5]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.80540558554955,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between accounts connected by Loan_Deposit_Account relationships, with path lengths ranging from 1 to 5 steps."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896257219881861865",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4778037729663387092",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:228557681089053243",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:196188058767327977",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4796333603149578811",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4819414551239852294",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4877398396442248974",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:231372430856161038",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:161285161655207380",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 accounts by nickname and then find the top 10 accounts by last login time among those, returning pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.phonenum RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where one account's nickname is different from another's, ordered by the other account's phone number."
  },
  {
    "query": "MATCH (a:Account {accountType: '44473046320285734'})-[:Company_Own_Account]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.accountLevel = '44473046320285734' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections between accounts of a specific account type through the \"Company_Own_Account\" relationship, where the connected account has a matching account level, and return the count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime = '44473046320285734' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose last login time is not equal to the specific string '44473046320285734'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel = '44473046320285734' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 isBlocked statuses from accounts with an account level not equal to '44473046320285734', ordered by their isBlocked status."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Apply_Loan]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a \"Company_Apply_Loan\" relationship or have a \"Loan_Deposit_Account\" relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 create times from accounts that either do not have a \"Loan_Deposit_Account\" relationship or have a \"Company_Own_Account\" relationship, ordered by create time."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.nickname) AS cnt UNION MATCH (b:Account) RETURN count(b.nickname) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of unique nicknames in the dataset of accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Transfer_Account]-()-[:Account_Transfer_Account]-(b:Account) WHERE NOT (a)-[:Account_Transfer_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the isBlocked status of accounts involved in a chain of \"Account_Transfer_Account\" relationships, excluding direct transfers between the same accounts, ordered by isBlocked status, limited to 20."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the maximum frequent login type among all accounts, ordered alphabetically."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 last login times from accounts that have a Company_Own_Account relationship, ordered by last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Apply_Loan]->(:Account) OR (n)-[:Account_Transfer_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Person_Apply_Loan relationship or have an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account *1..4]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3184,
    "is_noise_query": true,
    "nlp": "Count the number of accounts reachable via a Company_Own_Account relationship chain of up to four steps."
  },
  {
    "query": "MATCH p = (a:Account)-[:Medium_SignIn_Account *2..2]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between accounts connected by Medium_SignIn_Account relationships exactly two steps long."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285134151407895701",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4896820169835284135",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:285134151407894843",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4896820169835282970",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:285134151407895618",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4896820169835282675",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:285415626384607208",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 accounts by account level and then find the top 10 accounts by last login time from those, returning pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the first account is ordered by phone number and the second by account level."
  },
  {
    "query": "MATCH (a:Account {phonenum: '4844465824167101133'})-[:Medium_SignIn_Account]->(b:Account) WITH b MATCH (b)-[:Company_Own_Account]->(c:Account) WHERE c.lastLoginTime = '4844465824167101133' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count accounts that are connected through a Medium_SignIn_Account relationship from a specific account, followed by a Company_Own_Account relationship, where the final account's last login time matches a specific timestamp."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType CONTAINS '4844465824167101133' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose account type does not contain a specific substring."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType ENDS WITH '4844465824167101133' WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account levels from accounts whose account type does not end with a specific string, ordered by account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Collect the count of accounts that either do not have any outgoing Account_Withdraw_Account relationships or have at least one outgoing Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a Person_Apply_Loan relationship or have an Account_Transfer_Account relationship, then order by freqLoginType and collect the first 32 freqLoginTypes."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.email) AS cnt UNION MATCH (b:Account) RETURN count(b.email) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the union of the count of emails from all accounts in two separate datasets."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.lastLoginTime LIMIT 20 RETURN b.lastLoginTime",
    "answer": [
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      },
      {
        "b.lastLoginTime": "2020-05-03 18:42:43.956"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the last 20 distinct lastLoginTimes of accounts that form a cycle through two intermediate nodes via Loan_Deposit_Account relationships, excluding direct Loan_Deposit_Account relationships between them."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.nickname) AS min_value",
    "answer": "Aaron Nutting",
    "is_noise_query": true,
    "nlp": "Return the nickname that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.nickname) AS max_value",
    "answer": "Zulma Dixey",
    "is_noise_query": true,
    "nlp": "Find the nickname that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 email addresses from accounts that have a Company_Apply_Loan relationship, ordered by email."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have an Account_Transfer_Account relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account *1..5]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3200,
    "is_noise_query": true,
    "nlp": "Count the number of accounts reachable through 1 to 5 hops of the Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4897664594765414705",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4897101644811993938",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:285697101361316562",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:285697101361316562",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4897664594765414705",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4897664594765414427",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4897664594765414427",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4897101644811993938",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 accounts by accountType and then, from those, the top 10 by phonenum, returning pairs of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Retrieve pairs of accounts with different account types, excluding self-pairs, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Account), (b:Account) WHERE a.accountType = b.accountType AND a <> b RETURN count(*) AS cnt",
    "answer": 1116910,
    "is_noise_query": true,
    "nlp": "Count pairs of accounts with the same account type, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Account {nickname: '4769312005385357001'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Account) WHERE c.accountType = '4769312005385357001' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections from an account with a specific nickname through \"Account_Withdraw_Account\" and \"Company_Guarantee_Company\" relationships to another account with the same account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime ENDS WITH '4769312005385357001' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the last login time does not end with '4769312005385357001'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.isBlocked STARTS WITH '4769312005385357001' WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect phone numbers of accounts that are not blocked, ordered by phone number, and limit the results to the first 32 entries."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a \"Account_Withdraw_Account\" relationship or have a \"Loan_Deposit_Account\" relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Collect account types of accounts that do not have a \"Company_Own_Account\" relationship or have a \"Loan_Deposit_Account\" relationship, ordered by account type, and limit the results to the first 32 entries."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.createTime) AS cnt UNION MATCH (b:Account) RETURN count(b.createTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of creation times of accounts from two separate matches."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Repay_Loan]-()-[:Account_Repay_Loan]-(b:Account) WHERE NOT (a)-[:Account_Repay_Loan]-(b) WITH b ORDER BY b.phonenum LIMIT 20 RETURN b.phonenum",
    "answer": [
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7839"
      },
      {
        "b.phonenum": "000-7839"
      },
      {
        "b.phonenum": "000-7839"
      },
      {
        "b.phonenum": "000-7839"
      },
      {
        "b.phonenum": "001-1080"
      },
      {
        "b.phonenum": "001-1080"
      },
      {
        "b.phonenum": "001-1080"
      },
      {
        "b.phonenum": "001-1080"
      },
      {
        "b.phonenum": "001-4563"
      },
      {
        "b.phonenum": "001-4563"
      },
      {
        "b.phonenum": "002-3194"
      },
      {
        "b.phonenum": "002-3194"
      },
      {
        "b.phonenum": "002-3194"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve up to 20 phone numbers of accounts involved in a \"Account_Repay_Loan\" relationship but not directly connected through \"Account_Repay_Loan\" to another account, ordered by phone number."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.country) AS min_value",
    "answer": "Afghanistan",
    "is_noise_query": true,
    "nlp": "Return the country that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.gender) AS max_value",
    "answer": "male",
    "is_noise_query": true,
    "nlp": "Find the gender that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Own_Account]->(:Person) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Identify people who have an account owned by a company, order them by country, and return the first 32 unique countries."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Apply_Loan]->(:Person) OR (n)-[:Person_Apply_Loan]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people who either have not applied for a loan or have signed into an account."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personName LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:28587302322699",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:17592186045368",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:17592186045162",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:13194139533389",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:15393162789558",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:15393162789164",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:630",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:2199023255803",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:24189255811260",
        "b": "Person:28587302322284"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 people ordered by name, then for each of these, retrieve the top 10 people ordered by name, and return both sets of people."
  },
  {
    "query": "MATCH (a:Person), (b:Person) WHERE a.personName = b.city AND a <> b WITH a, b ORDER BY a.personName, b.city LIMIT 32 RETURN a, b",
    "answer": [
      {
        "a": "Person:26388279066852",
        "b": "Person:21990232555698"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of people where one's name matches another's city, exclude self-matches, order by person name and city, and return up to 32 such pairs."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.isBlocked MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.birthday RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Identify pairs of people where the first is not blocked and the second has a later birthday than the first, excluding self-pairs, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Person {gender: '26388279066681'})-[:Company_Guarantee_Company]->(b:Person) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Person) WHERE c.personName = '26388279066681' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where a person with a specific gender value acts as a guarantor for a company, and this guarantor also withdraws an account for someone with a specific name."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.city STARTS WITH '26388279066681' WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS vals",
    "answer": [
      "Abay",
      "Abdalas",
      "Abdelli",
      "Abrikosov",
      "Abutalybov",
      "Acevedo",
      "Aghdamski",
      "Agnes Christina Of Austria",
      "Aguilar",
      "Aird",
      "Akhurst",
      "Akindele",
      "Akyz",
      "Al Hussain",
      "Albar",
      "Alcala",
      "Alder",
      "Ales",
      "Alexander",
      "Alghisi",
      "Alling",
      "Almeyda",
      "Altavista",
      "Ambrosius",
      "Amonqulova",
      "Amoroso",
      "Anaya",
      "Anderson",
      "Anderson",
      "Anderson",
      "Anderson Imbert",
      "Andhyarujina"
    ],
    "is_noise_query": true,
    "nlp": "List the names of people whose city does not start with a specific code, ordered by name, and return the first 32 unique names."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Apply_Loan]->(:Person) OR (a)-[:Medium_SignIn_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people who either have not applied for a loan or have signed into a medium account."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Person) OR (a)-[:Account_Transfer_Account]->(:Person) WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS vals",
    "answer": [
      "1980-01-08",
      "1980-01-18",
      "1980-01-21",
      "1980-01-23",
      "1980-01-29",
      "1980-02-02",
      "1980-02-04",
      "1980-02-06",
      "1980-03-11",
      "1980-03-19",
      "1980-03-19",
      "1980-03-21",
      "1980-03-31",
      "1980-04-09",
      "1980-04-13",
      "1980-04-13",
      "1980-04-15",
      "1980-04-15",
      "1980-04-20",
      "1980-04-21",
      "1980-05-22",
      "1980-06-19",
      "1980-06-19",
      "1980-06-27",
      "1980-07-14",
      "1980-07-17",
      "1980-07-27",
      "1980-08-02",
      "1980-08-11",
      "1980-08-15",
      "1980-08-18",
      "1980-08-22"
    ],
    "is_noise_query": true,
    "nlp": "Identify persons not involved in certain company guarantees or involved in account transfers, order them by birthday, and return up to 32 birthdays."
  },
  {
    "query": "MATCH (a:Person)-[:Person_Guarantee_Person]-()-[:Person_Guarantee_Person]-(b:Person) WHERE NOT (a)-[:Person_Guarantee_Person]-(b) WITH b ORDER BY b.createTime LIMIT 20 RETURN b.createTime",
    "answer": [
      {
        "b.createTime": "2020-01-02 18:57:28.118"
      },
      {
        "b.createTime": "2020-01-03 04:37:41.401"
      },
      {
        "b.createTime": "2020-01-07 13:25:56.241"
      },
      {
        "b.createTime": "2020-01-07 13:25:56.241"
      },
      {
        "b.createTime": "2020-01-07 13:25:56.241"
      },
      {
        "b.createTime": "2020-01-08 17:20:47.273"
      },
      {
        "b.createTime": "2020-01-08 17:20:47.273"
      },
      {
        "b.createTime": "2020-01-08 17:20:47.273"
      },
      {
        "b.createTime": "2020-01-08 17:20:47.273"
      },
      {
        "b.createTime": "2020-01-15 02:21:44.159"
      },
      {
        "b.createTime": "2020-01-15 02:21:44.159"
      },
      {
        "b.createTime": "2020-01-15 02:21:44.159"
      },
      {
        "b.createTime": "2020-01-15 02:21:44.159"
      },
      {
        "b.createTime": "2020-01-15 02:21:44.159"
      },
      {
        "b.createTime": "2020-01-15 02:21:44.159"
      },
      {
        "b.createTime": "2020-01-17 03:32:50.477"
      },
      {
        "b.createTime": "2020-01-17 03:32:50.477"
      },
      {
        "b.createTime": "2020-01-17 03:32:50.477"
      },
      {
        "b.createTime": "2020-01-17 03:32:50.477"
      },
      {
        "b.createTime": "2020-01-18 02:21:52.659"
      }
    ],
    "is_noise_query": true,
    "nlp": "Finds persons indirectly connected through specific guarantee relationships, ensuring no direct connection exists between the individuals, orders them by creation time, and limits the results to 20, returning their creation times."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.gender) AS min_value",
    "answer": "female",
    "is_noise_query": true,
    "nlp": "Returns the earliest gender value alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.personName) AS max_value",
    "answer": "ychliski",
    "is_noise_query": true,
    "nlp": "Finds the latest personName alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Guarantee_Company]->(:Person) WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Identifies persons involved in company guarantees, orders them by person name, and returns up to 32 names."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Person) OR (n)-[:Person_Apply_Loan]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts persons who are either not involved in company guarantees or are involved in loan applications."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:755",
        "b": "Person:985"
      },
      {
        "a": "Person:755",
        "b": "Person:640"
      },
      {
        "a": "Person:755",
        "b": "Person:982"
      },
      {
        "a": "Person:755",
        "b": "Person:41"
      },
      {
        "a": "Person:755",
        "b": "Person:729"
      },
      {
        "a": "Person:755",
        "b": "Person:310"
      },
      {
        "a": "Person:755",
        "b": "Person:808"
      },
      {
        "a": "Person:755",
        "b": "Person:630"
      },
      {
        "a": "Person:755",
        "b": "Person:51"
      },
      {
        "a": "Person:755",
        "b": "Person:755"
      }
    ],
    "is_noise_query": true,
    "nlp": "Orders the top 10 persons by creation time, then within this group, finds the top 10 unblocked persons by blocked status, returning pairs of these."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personName MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.personName RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Counts unique person pairs where each person is ordered by name and compared against every other person, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Person {birthday: '4398046511724'})-[:Account_Repay_Loan]->(b:Person) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Person) WHERE c.birthday = '4398046511724' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts paths from a specific person through repay loans to others, then through account transfers back to the same specific person, matching specific birthdates."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.gender STARTS WITH '4398046511724' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts persons whose gender does not start with a specific string."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.gender <> '4398046511724' WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 gender values from persons whose gender matches a specific string, ordered by gender."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Person) OR (a)-[:Account_Transfer_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts persons who do not have any Medium_SignIn_Account relationships or have Account_Transfer_Account relationships."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Invest_Company]->(:Person) OR (a)-[:Loan_Deposit_Account]->(:Person) WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS vals",
    "answer": [
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 genders from persons who are either not involved in Person_Invest_Company relationships or are involved in Loan_Deposit_Account relationships, ordered by gender."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Returns the earliest account type alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Finds the latest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 frequency login types from accounts involved in Person_Guarantee_Person relationships, ordered by frequency login type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Invest_Company]->(:Account) OR (n)-[:Company_Guarantee_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts that are either not involved in Person_Invest_Company relationships or are involved in Company_Guarantee_Company relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:64176294690031206",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4661507089305174028",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4644337115725825070",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4671077238513337662",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4662070039258597186",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:41095346599755900",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4672766088373601934",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:45035996273706602",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Orders the top 10 accounts by last login time and then finds another 10 accounts by creation time, returning pairs of these."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Counts unique pairs of accounts where each account is ordered by account level and compared against every other account."
  },
  {
    "query": "MATCH (a:Account {createTime: '4770156430315487894'})-[:Account_Repay_Loan]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.lastLoginTime = '4770156430315487894' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts paths from a specific account with a given create time through Account_Repay_Loan relationships to other accounts, and then through Company_Invest_Company relationships back to accounts with the same specific create time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname = '4770156430315487894' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts whose nickname does not match a specific string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel CONTAINS '4770156430315487894' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 create times from accounts whose account level does not contain the specific string \"4770156430315487894\", ordered by create time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts that are either not involved in any repay loan relationships or are involved in company guarantee relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Company_Invest_Company]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 phone numbers from accounts that are not involved in person-to-person guarantees or are involved in company-to-company investments, ordered by phone number."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.city) AS min_value",
    "answer": "Aachen",
    "is_noise_query": true,
    "nlp": "Returns the city that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.country) AS max_value",
    "answer": "Zambia",
    "is_noise_query": true,
    "nlp": "Finds the country that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Guarantee_Person]->(:Person) RETURN count(a) AS cnt",
    "answer": 511,
    "is_noise_query": true,
    "nlp": "Counts persons who are involved in person-to-person guarantees."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Invest_Company]->(:Person) WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 person names from individuals involved in company investments, ordered by person name."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Person) OR (n)-[:Account_Withdraw_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts persons who are either not involved in company guarantee relationships or are involved in account withdrawal relationships."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personName LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:17592186045162",
        "b": "Person:4"
      },
      {
        "a": "Person:17592186045368",
        "b": "Person:4"
      },
      {
        "a": "Person:2199023255803",
        "b": "Person:4"
      },
      {
        "a": "Person:13194139533389",
        "b": "Person:4"
      },
      {
        "a": "Person:15393162789558",
        "b": "Person:4"
      },
      {
        "a": "Person:28587302322699",
        "b": "Person:4"
      },
      {
        "a": "Person:15393162789164",
        "b": "Person:4"
      },
      {
        "a": "Person:630",
        "b": "Person:4"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:4"
      },
      {
        "a": "Person:24189255811260",
        "b": "Person:4"
      }
    ],
    "is_noise_query": true,
    "nlp": "Orders the top 10 persons by name and then selects another 10 by ID, returning pairs of these persons."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.personName RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Counts unique pairs of persons where each person is ordered by creation time and compared against every other person."
  },
  {
    "query": "MATCH (a:Person {createTime: '4398046511731'})-[:Loan_Deposit_Account]->(b:Person) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Person) WHERE c.birthday = '4398046511731' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts paths from a specific person through Loan_Deposit_Account relationships to other persons, then through Company_Invest_Company relationships back to persons with a specific birthday, returning the total count."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.createTime = '4398046511731' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Returns the count of Person nodes where the createTime is not '4398046511731'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.isBlocked ENDS WITH '4398046511731' WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Returns up to 32 cities from unblocked Person nodes whose isBlocked property does not end with '4398046511731', ordered by city."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Transfer_Account]->(:Person) OR (a)-[:Company_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts Person nodes that either do not have an Account_Transfer_Account relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Person) OR (a)-[:Company_Guarantee_Company]->(:Person) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belgium",
      "Belgium",
      "Belgium",
      "Belgium",
      "Belgium",
      "Belgium",
      "Belgium",
      "Belgium",
      "Bosnia_and_Herzegovina",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 countries from Person nodes that do not involve Person_Guarantee_Person relationships but do involve Company_Guarantee_Company relationships, ordered by country."
  },
  {
    "query": "MATCH (a:Person)-[:Person_Guarantee_Person]-()-[:Person_Guarantee_Person]-(b:Person) WHERE NOT (a)-[:Person_Guarantee_Person]-(b) WITH b ORDER BY b.personName LIMIT 20 RETURN b.personName",
    "answer": [
      {
        "b.personName": "Abdalas"
      },
      {
        "b.personName": "Abdalas"
      },
      {
        "b.personName": "Abdalas"
      },
      {
        "b.personName": "Abrikosov"
      },
      {
        "b.personName": "Abrikosov"
      },
      {
        "b.personName": "Agnes Christina Of Austria"
      },
      {
        "b.personName": "Agnes Christina Of Austria"
      },
      {
        "b.personName": "Agnes Christina Of Austria"
      },
      {
        "b.personName": "Agnes Christina Of Austria"
      },
      {
        "b.personName": "Aguilar"
      },
      {
        "b.personName": "Aird"
      },
      {
        "b.personName": "Aird"
      },
      {
        "b.personName": "Akyz"
      },
      {
        "b.personName": "Akyz"
      },
      {
        "b.personName": "Al Hussain"
      },
      {
        "b.personName": "Al Hussain"
      },
      {
        "b.personName": "Alder"
      },
      {
        "b.personName": "Alder"
      },
      {
        "b.personName": "Ales"
      },
      {
        "b.personName": "Alghisi"
      }
    ],
    "is_noise_query": true,
    "nlp": "Returns the names of up to 20 distinct Person nodes that are connected through two Person_Guarantee_Person relationships but not directly through a single Person_Guarantee_Person relationship, ordered by personName."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Returns the phone number that comes first alphabetically among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.nickname) AS max_value",
    "answer": "Zulma Dixey",
    "is_noise_query": true,
    "nlp": "Finds the nickname that comes last alphabetically among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Invest_Company]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 account levels from Account nodes involved in Company_Invest_Company relationships, ordered by account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts Account nodes that either do not involve Account_Withdraw_Account relationships or are involved in Company_Apply_Loan relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b"
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Returns a list of ten accounts with the lowest phone numbers and their corresponding ten accounts with the highest frequency of login types."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '242068479971165702'})-[:Company_Own_Account]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.nickname = '242068479971165702' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count"
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime STARTS WITH '242068479971165702' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts the number of unique account pairs where each pair consists of an account and another distinct account, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel ENDS WITH '242068479971165702' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "MATCH (a:Account {accountLevel: '242068479971165702'})-[:Company_Own_Account]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.nickname = '242068479971165702' RETURN count(*) AS total_cnt"
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts the total number of accounts that have a relationship of being invested in by another account with a specific nickname, starting from an account with a particular account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "MATCH (a:Account) WHERE NOT a.createTime STARTS WITH '242068479971165702' RETURN count(a) AS cnt"
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.email) AS cnt UNION MATCH (b:Account) RETURN count(b.email) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts the number of accounts whose creation time does not start with the specified string."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.email) AS min_value",
    "answer": "37.com",
    "is_noise_query": true,
    "nlp": "MATCH (a:Account) WHERE NOT a.accountLevel ENDS WITH '242068479971165702' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals"
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.email) AS max_value",
    "answer": "zoho.com",
    "is_noise_query": true,
    "nlp": "Collects up to 32 email addresses from accounts where the account level does not end with the specified string, ordered by email."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Counts paths from a specific account through investments to others, then through deposits back to the original, matching specific blocked statuses."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Repay_Loan]->(:Account) OR (n)-[:Person_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Returns the count of accounts that do not have an outgoing Account_Repay_Loan relationship or have an incoming Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account *2..4]-(b:Account) RETURN count(b) AS cnt",
    "answer": 711324,
    "is_noise_query": true,
    "nlp": "Counts pairs of accounts connected by Medium_SignIn_Account relationships of length 2 to 4."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896538694858572073"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285134151407894741"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835283081"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835284218"
      }
    ],
    "is_noise_query": true,
    "nlp": "Returns the top 10 accounts with the highest account levels and the top 10 unblocked accounts among them."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Counts distinct pairs of accounts where one account is not equal to the other, ordered by the second account's frequency login type."
  },
  {
    "query": "MATCH (a:Account {nickname: '4690780486883082344'})-[:Person_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Account) WHERE c.isBlocked = '4690780486883082344' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts the number of accounts where a specific nickname invests in companies and those companies have blocked deposit accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum ENDS WITH '4690780486883082344' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts whose phone number does not end with a specific string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType ENDS WITH '4690780486883082344' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 emails from accounts whose frequency login type does not end with a specific string, ordered by email."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts not involved in deposits or are involved in loan applications."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Find the creation times of up to 32 accounts that either have no outgoing Person_Apply_Loan relationships or have an incoming Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.accountId LIMIT 20 RETURN b.accountId",
    "answer": [
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 9570149208163490
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 14918173765665963
      },
      {
        "b.accountId": 23080948090274944
      },
      {
        "b.accountId": 27584547717644507
      },
      {
        "b.accountId": 27584547717644507
      },
      {
        "b.accountId": 27584547717644507
      }
    ],
    "is_noise_query": true,
    "nlp": "Identify 20 accounts that are indirectly connected through Loan_Deposit_Account relationships but do not have a direct Loan_Deposit_Account relationship with each other, ordered by their account ID."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-01-29 05:12:39.506",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all mediums. This value is determined by lexicographic order since isBlocked is a string."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Own_Account]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked status of up to 32 Medium nodes that have a Company_Own_Account relationship, ordered by their isBlocked status."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Apply_Loan]->(:Medium) OR (n)-[:Person_Own_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either do not have a Person_Apply_Loan relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.riskLevel LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:680",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1480",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1875",
        "b": "Medium:884"
      },
      {
        "a": "Medium:503",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1650",
        "b": "Medium:884"
      },
      {
        "a": "Medium:962",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1196",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1124",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1297",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of Medium nodes where the first ten have the lowest risk levels and the second ten within each have the earliest creation times."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.riskLevel RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct Medium nodes where the first node is not blocked and the second node has different risk levels, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Medium {lastLoginTime: '8796093022804'})-[:Company_Own_Account]->(b:Medium) WITH b MATCH (b)-[:Company_Own_Account]->(c:Medium) WHERE c.mediumType = '8796093022804' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections between Medium nodes where the first node has a specific last login time and the second node, which is owned by the first, has a specific medium type."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked = '8796093022804' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count non-blocked Medium nodes, excluding those with a specific isBlocked value."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel ENDS WITH '8796093022804' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-01-29 05:12:39.506",
      "2020-02-03 17:46:43.836",
      "2020-02-15 19:29:12.059",
      "2020-03-07 12:38:42.833",
      "2020-03-12 20:53:48.093",
      "2020-03-20 08:34:41.767",
      "2020-03-28 05:20:45.915",
      "2020-04-02 18:27:25.513",
      "2020-04-03 19:25:08.930",
      "2020-04-05 16:30:10.209",
      "2020-04-08 12:15:42.926",
      "2020-04-19 15:31:53.628",
      "2020-04-30 08:24:02.358",
      "2020-05-17 13:12:15.150",
      "2020-05-18 06:16:54.756",
      "2020-05-19 10:29:57.660",
      "2020-05-24 18:06:27.871",
      "2020-05-28 09:43:48.217",
      "2020-05-29 05:26:41.843",
      "2020-06-05 17:35:15.999",
      "2020-06-06 14:42:45.787",
      "2020-06-18 21:36:31.467",
      "2020-06-21 18:28:14.001",
      "2020-06-22 17:25:34.472",
      "2020-06-23 10:15:27.445",
      "2020-06-25 22:58:42.936",
      "2020-07-01 07:39:30.970",
      "2020-07-04 05:11:00.922",
      "2020-07-07 11:59:49.304",
      "2020-07-09 23:56:58.844",
      "2020-07-12 12:44:05.479",
      "2020-07-16 23:19:43.551"
    ],
    "is_noise_query": true,
    "nlp": "Collect the last login times of up to 32 Medium nodes whose risk level does not end with a specific string, ordered by their last login time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Person_Invest_Company]->(:Medium) OR (a)-[:Medium_SignIn_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count Medium nodes that either do not have a Person_Invest_Company relationship or have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Invest_Company]->(:Medium) OR (a)-[:Account_Withdraw_Account]->(:Medium) WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Collect the risk levels of up to 32 Medium nodes that do not have a Company_Invest_Company relationship or have an Account_Withdraw_Account relationship, ordered by their risk level."
  },
  {
    "query": "MATCH (a:Medium)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Medium) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Identify 20 Medium nodes that are indirectly connected through Medium_SignIn_Account relationships but do not have a direct Medium_SignIn_Account relationship with any other node, ordered by their blocked status."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountLevel) AS min_value",
    "answer": "Basic level",
    "is_noise_query": true,
    "nlp": "Return the minimum account level among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the nicknames of up to 32 Account nodes that have a Person_Invest_Company relationship, ordered by their nickname."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes that either do not have a Company_Apply_Loan relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account *1..4]-(b:Account) RETURN count(b) AS cnt",
    "answer": 120024,
    "is_noise_query": true,
    "nlp": "Count distinct Account nodes that are within 1 to 4 hops of another Account node through Loan_Deposit_Account relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of Account nodes where the first ten have the lowest frequency login types and the second ten within each have the lowest frequency login types."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct Account nodes where the first node has the lowest frequency login type and the second node has the highest account level."
  },
  {
    "query": "MATCH (a:Account {lastLoginTime: '65583669573584462'})-[:Company_Guarantee_Company]->(b:Account) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Account) WHERE c.accountType = '65583669573584462' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Identify connections between Account nodes where the first node guarantees a company and the second node transfers funds to another account, both having specific identifiers, and return the count of such connections."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime CONTAINS '65583669573584462' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes whose creation time does not contain a specific identifier."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email = '65583669573584462' WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the frequency login types of up to 32 Account nodes that do not match a specific email, ordered by their frequency login type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes that either do not have an Account_Repay_Loan relationship or have a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect phone numbers of up to 32 Account nodes, ordered by their phone number, regardless of whether they have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Account) RETURN count(b.isBlocked) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of blocked statuses in Account nodes, effectively counting how many times the isBlocked property appears across all nodes."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account]-()-[:Person_Own_Account]-(b:Account) WHERE NOT (a)-[:Person_Own_Account]-(b) WITH b ORDER BY b.createTime LIMIT 20 RETURN b.createTime",
    "answer": [
      {
        "b.createTime": "2020-03-13 09:01:08.745"
      },
      {
        "b.createTime": "2020-03-13 09:01:08.745"
      },
      {
        "b.createTime": "2020-03-16 20:22:47.571"
      },
      {
        "b.createTime": "2020-03-16 20:22:47.571"
      },
      {
        "b.createTime": "2020-03-17 06:07:41.458"
      },
      {
        "b.createTime": "2020-03-17 06:07:41.458"
      },
      {
        "b.createTime": "2020-04-11 21:50:13.558"
      },
      {
        "b.createTime": "2020-04-11 21:50:13.558"
      },
      {
        "b.createTime": "2020-04-11 21:50:13.558"
      },
      {
        "b.createTime": "2020-04-12 12:38:11.729"
      },
      {
        "b.createTime": "2020-04-18 05:15:51.905"
      },
      {
        "b.createTime": "2020-04-18 05:15:51.905"
      },
      {
        "b.createTime": "2020-04-18 05:15:51.905"
      },
      {
        "b.createTime": "2020-04-22 23:36:21.218"
      },
      {
        "b.createTime": "2020-04-22 23:36:21.218"
      },
      {
        "b.createTime": "2020-04-22 23:36:21.218"
      },
      {
        "b.createTime": "2020-04-26 09:16:17.123"
      },
      {
        "b.createTime": "2020-04-26 09:16:17.123"
      },
      {
        "b.createTime": "2020-05-16 03:17:45.505"
      },
      {
        "b.createTime": "2020-05-16 03:17:45.505"
      }
    ],
    "is_noise_query": true,
    "nlp": "Identify 20 Account nodes that are indirectly connected through Person_Own_Account relationships but do not have a direct Person_Own_Account relationship with any other node, ordered by their creation time."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.interestRate) AS avg_value",
    "answer": 0.05062750217580504,
    "is_noise_query": true,
    "nlp": "Calculate the average interest rate of all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.balance) AS total_value",
    "answer": 59302232892.69993,
    "is_noise_query": true,
    "nlp": "Sum the balances of all Loan nodes to get the total value."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.interestRate) AS min_value",
    "answer": 0.0,
    "is_noise_query": true,
    "nlp": "Find the minimum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.balance) AS max_value",
    "answer": 99766573.87,
    "is_noise_query": true,
    "nlp": "Find the maximum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Medium_SignIn_Account]->(:Loan) WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the balances of up to 32 Loan nodes that have a Medium_SignIn_Account relationship, ordered by their balance."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Loan) OR (n)-[:Company_Guarantee_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count Loan nodes that either do not have an Account_Withdraw_Account relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account *2..4]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 320794,
    "is_noise_query": true,
    "nlp": "Count distinct Loan nodes that are within 2 to 4 hops of another Loan node through Loan_Deposit_Account relationships."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.interestRate LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4866420872350532459"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894568370021597389"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4759460381200482587"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:217298682020626503"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4889501820440805670"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4890627720347648427"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:123848989752689515"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:143833713099145499"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4802807527613924326"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894849844998307888"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of Loan nodes where the first ten have the earliest creation times and the second ten within each have the lowest interest rates."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.loanUsage RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct Loan nodes where the first node has the lowest interest rate and the second node has different loan usages."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.balance = b.balance AND a <> b WITH a, b ORDER BY b.createTime RETURN a, collect(b.createTime)[0..32] AS bs",
    "answer": [
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-06-11 10:55:03.271",
          "loanUsage": "business ventures",
          "_node_id": "Loan:250794204249195062",
          "loanId": 250794204249195062,
          "loanAmount": 14514821.0
        },
        "bs": [
          "2022-05-31 08:24:48.513"
        ]
      },
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-05-31 08:24:48.513",
          "loanUsage": "business ventures",
          "_node_id": "Loan:4859383997932765750",
          "loanId": 4859383997932765750,
          "loanAmount": 14514821.0
        },
        "bs": [
          "2022-06-11 10:55:03.271"
        ]
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-09-12 23:10:13.706",
          "loanUsage": "renovations",
          "_node_id": "Loan:277252852059997235",
          "loanId": 277252852059997235,
          "loanAmount": 90419964.0
        },
        "bs": [
          "2022-06-25 17:52:38.863"
        ]
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-06-25 17:52:38.863",
          "loanUsage": "renovations",
          "_node_id": "Loan:4866420872350532659",
          "loanId": 4866420872350532659,
          "loanAmount": 90419964.0
        },
        "bs": [
          "2022-09-12 23:10:13.706"
        ]
      }
    ],
    "is_noise_query": true,
    "nlp": "Identify pairs of Loan nodes with the same balance, excluding self-pairs, and return the creation times of the second node."
  },
  {
    "query": "MATCH (a:Loan {balance: '146366987889541851'})-[:Company_Invest_Company]->(b:Loan) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Loan) WHERE c.loanAmount = '146366987889541851' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections between Loan nodes where the first node invests in a company and the second node transfers funds, both having specific identifiers."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage = '146366987889541851' WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS vals",
    "answer": [
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures"
    ],
    "is_noise_query": true,
    "nlp": "Collect the loan usages of up to 32 non-matching Loan nodes, ordered by their loan usage."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Own_Account]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count Loan nodes that either do not have a Company_Own_Account relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Loan) OR (a)-[:Loan_Deposit_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect interest rates of up to 32 Loan nodes that do not have an Account_Withdraw_Account relationship or have a Loan_Deposit_Account relationship, ordered by their interest rate."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.createTime LIMIT 20 RETURN b.createTime",
    "answer": [
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      }
    ],
    "is_noise_query": true,
    "nlp": "Identify 20 Loan nodes that are indirectly connected through Loan_Deposit_Account relationships but do not have a direct Loan_Deposit_Account relationship with any other node, ordered by their creation time."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.balance) AS avg_value",
    "answer": 25806019.535552666,
    "is_noise_query": true,
    "nlp": "Calculate the average balance of all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanUsage) AS max_value",
    "answer": "weddings",
    "is_noise_query": true,
    "nlp": "Find the maximum loan usage value among all loans, considering alphabetical order for string values."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Own_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the interest rates of up to 32 Loan nodes that have a Person_Own_Account relationship, ordered by their interest rate."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Loan) OR (n)-[:Account_Repay_Loan]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count Loan nodes that either do not have a Person_Guarantee_Person relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH p = (a:Loan)-[:Company_Apply_Loan *2..5]-(b:Loan) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between Loan nodes that are connected through Company_Apply_Loan relationships, within 2 to 5 hops."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanUsage LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4701476535998088242"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4711891110136381993"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:79375943432405966"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:82472168176223460"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:70650219154375089"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:29836347531329650"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4663195939165439209"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:66146619527004485"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4658973814514778717"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4714705859903489184"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of Loan nodes where the first ten have the earliest creation times and the second ten within each have the lowest loan usages."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.loanUsage RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct Loan nodes where the first node has the lowest interest rate and the second node has different loan usages."
  },
  {
    "query": "MATCH (a:Loan {balance: '103582791429522637'})-[:Company_Guarantee_Company]->(b:Loan) WITH b MATCH (b)-[:Company_Own_Account]->(c:Loan) WHERE c.balance = '103582791429522637' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count connections between Loan nodes where the first node guarantees a company and the second node owns a company, both having a balance of '103582791429522637', and return the total count."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage = '103582791429522637' WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [
      61.51,
      62.37,
      111.44,
      201.44,
      263.89,
      562.45,
      769.15,
      971.05,
      1364.68,
      1474.58,
      1850.89,
      1859.25,
      2638.41,
      2741.97,
      2831.06,
      3021.97,
      3313.09,
      3690.54,
      3885.13,
      4801.41,
      5296.98,
      5491.24,
      8423.84,
      8930.37,
      9107.76,
      9378.97,
      9554.96,
      11339.17,
      11665.03,
      11785.13,
      12075.02,
      12430.63
    ],
    "is_noise_query": true,
    "nlp": "Collect the balances of up to 32 Loan nodes that do not have a loan usage identifier of '103582791429522637', ordered by their balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Loan) OR (a)-[:Company_Guarantee_Company]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count Loan nodes that either do not have a Company_Guarantee_Company relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Loan) OR (a)-[:Person_Apply_Loan]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect interest rates of up to 32 Loan nodes that do not have a Medium_SignIn_Account relationship or have a Person_Apply_Loan relationship, ordered by their interest rate."
  },
  {
    "query": "MATCH (a:Loan)-[:Account_Repay_Loan]-()-[:Account_Repay_Loan]-(b:Loan) WHERE NOT (a)-[:Account_Repay_Loan]-(b) WITH b ORDER BY b.interestRate LIMIT 20 RETURN b.interestRate",
    "answer": [
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      }
    ],
    "is_noise_query": true,
    "nlp": "Identify 20 Loan nodes that are indirectly connected through Account_Repay_Loan relationships but do not have a direct Account_Repay_Loan relationship with any other node, ordered by their interest rate."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.nickname) AS min_value",
    "answer": "Aaron Nutting",
    "is_noise_query": true,
    "nlp": "Return the nickname that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Medium_SignIn_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the frequency login types of up to 32 Account nodes that have a Medium_SignIn_Account relationship, ordered by their frequency login type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Loan_Deposit_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes that either do not have an Account_Transfer_Account relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH p = (a:Account)-[:Account_Repay_Loan *2..3]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths of 2 to 3 hops between accounts through repay loan relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285978576338027459",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by account type and then find another top 10 accounts ordered by account type, returning pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique account pairs where accounts have different IDs and are ordered by account level."
  },
  {
    "query": "MATCH (a:Account {nickname: '4875709546581984772'})-[:Person_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Account_Repay_Loan]->(c:Account) WHERE c.freqLoginType = '4875709546581984772' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where an account with the specific nickname '4875709546581984772' has applied for a loan and repaid it, filtering by frequency login type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname ENDS WITH '4875709546581984772' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose nicknames do not end with '4875709546581984772'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel CONTAINS '4875709546581984772' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account types from accounts where account level does not contain '4875709546581984772', ordered by account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Company_Own_Account relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Return up to 32 email addresses from accounts where the email does not start with a specific string, ordered by email."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountLevel) AS cnt UNION MATCH (b:Account) RETURN count(b.accountLevel) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of account levels from two separate matches on accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Repay_Loan]-()-[:Account_Repay_Loan]-(b:Account) WHERE NOT (a)-[:Account_Repay_Loan]-(b) WITH b ORDER BY b.freqLoginType LIMIT 20 RETURN b.freqLoginType",
    "answer": [
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that are involved in an Account_Repay_Loan relationship twice, but not directly, and return the first 20 distinct freq login types."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanAmount) AS min_value",
    "answer": 88778.0,
    "is_noise_query": true,
    "nlp": "Find the minimum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanUsage) AS max_value",
    "answer": "weddings",
    "is_noise_query": true,
    "nlp": "Find the highest loan usage among all loans, based on alphabetical order."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Loan_Deposit_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 interest rates from loans that have a deposit account relationship, ordered by interest rate."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Loan) OR (n)-[:Person_Guarantee_Person]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans where there is no deposit account relationship or a person guarantee relationship exists."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanUsage LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanUsage LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4701476535998088242"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4711891110136381993"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:79375943432405966"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:82472168176223460"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:70650219154375089"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:29836347531329650"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4663195939165439209"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:66146619527004485"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4658973814514778717"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4714705859903489184"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 loans by loan usage and then find another set of top 10 loans by loan usage, returning pairs of these loans."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.balance RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count unique pairs of loans where the loans have different IDs and are ordered by their balance."
  },
  {
    "query": "MATCH (a:Loan {createTime: '253608954016302318'})-[:Account_Withdraw_Account]->(b:Loan) WITH b MATCH (b)-[:Company_Own_Account]->(c:Loan) WHERE c.balance = '253608954016302318' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where a loan with a specific creation time withdraws funds into another loan, and this second loan has a company ownership account with a matching balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime STARTS WITH '253608954016302318' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans whose creation time does not start with a specific string."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance = '253608954016302318' WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [
      61.51,
      62.37,
      111.44,
      201.44,
      263.89,
      562.45,
      769.15,
      971.05,
      1364.68,
      1474.58,
      1850.89,
      1859.25,
      2638.41,
      2741.97,
      2831.06,
      3021.97,
      3313.09,
      3690.54,
      3885.13,
      4801.41,
      5296.98,
      5491.24,
      8423.84,
      8930.37,
      9107.76,
      9378.97,
      9554.96,
      11339.17,
      11665.03,
      11785.13,
      12075.02,
      12430.63
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 balances from loans where the balance does not equal a specific value, ordered by balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Own_Account]->(:Loan) OR (a)-[:Account_Withdraw_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans where there is no person own account relationship or an account withdraw account relationship exists."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Loan) OR (a)-[:Loan_Deposit_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 interest rates from loans, ordered by interest rate. The condition about the deposit account relationship is redundant and can be removed."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-15 09:39:18.811",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Medium_SignIn_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 creation times from accounts where there is a medium sign-in relationship, ordered by creation time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Own_Account]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where there is no company-owned account relationship or a person guarantee relationship exists."
  },
  {
    "query": "MATCH p = (a:Account)-[:Loan_Deposit_Account *3..4]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 4.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths of 3 to 4 hops between accounts through loan-deposit relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285978576338027459",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts by account type and then find another top 10 accounts by frequency login type, returning pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.nickname RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique account pairs where accounts have different IDs and are ordered by nickname."
  },
  {
    "query": "MATCH (a:Account {email: '296674625453031946'})-[:Account_Repay_Loan]->(b:Account) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Account) WHERE c.lastLoginTime = '296674625453031946' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where an account with a specific email repays a loan and another account applies for it, with matching last login times."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname <> '296674625453031946' WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 nicknames from accounts where the nickname matches a specific string, ordered by nickname."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Invest_Company]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where there is no company-invest company relationship or a loan-deposit account relationship exists."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 frequency login types from accounts where there is no direct 'Person_Guarantee_Person' relationship to another account or where there is a 'Company_Own_Account' relationship, ordered by the frequency login type."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.loanAmount) AS avg_value",
    "answer": 48819411.184508234,
    "is_noise_query": true,
    "nlp": "Calculate the average loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:41:50.010",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Account_Repay_Loan]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 loan usages from loans where there is an 'Account_Repay_Loan' relationship to another loan, ordered by loan usage."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Invest_Company]->(:Loan) OR (n)-[:Company_Invest_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans where there is no 'Person_Invest_Company' relationship or where there is a 'Company_Invest_Company' relationship exists."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account *3..5]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 299676,
    "is_noise_query": true,
    "nlp": "Count loans where there is a 'Loan_Deposit_Account' relationship of 3 to 5 hops."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.interestRate LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4866420872350532459"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894568370021597389"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4759460381200482587"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:217298682020626503"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4889501820440805670"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4890627720347648427"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:123848989752689515"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:143833713099145499"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4802807527613924326"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894849844998307888"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 loans by creation time, then from those, find another top 10 loans by interest rate, returning pairs."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.balance RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count unique loan pairs where loans have different IDs, ordered by balance."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.balance = b.balance AND a <> b WITH a, b ORDER BY b.createTime RETURN a, collect(b.createTime)[0..32] AS bs",
    "answer": [
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-06-11 10:55:03.271",
          "loanUsage": "business ventures",
          "_node_id": "Loan:250794204249195062",
          "loanId": 250794204249195062,
          "loanAmount": 14514821.0
        },
        "bs": [
          "2022-05-31 08:24:48.513"
        ]
      },
      {
        "a": {
          "interestRate": 0.001,
          "balance": 14514821.0,
          "createTime": "2022-05-31 08:24:48.513",
          "loanUsage": "business ventures",
          "_node_id": "Loan:4859383997932765750",
          "loanId": 4859383997932765750,
          "loanAmount": 14514821.0
        },
        "bs": [
          "2022-06-11 10:55:03.271"
        ]
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-09-12 23:10:13.706",
          "loanUsage": "renovations",
          "_node_id": "Loan:277252852059997235",
          "loanId": 277252852059997235,
          "loanAmount": 90419964.0
        },
        "bs": [
          "2022-06-25 17:52:38.863"
        ]
      },
      {
        "a": {
          "interestRate": 0.047,
          "balance": 90419964.0,
          "createTime": "2022-06-25 17:52:38.863",
          "loanUsage": "renovations",
          "_node_id": "Loan:4866420872350532659",
          "loanId": 4866420872350532659,
          "loanAmount": 90419964.0
        },
        "bs": [
          "2022-09-12 23:10:13.706"
        ]
      }
    ],
    "is_noise_query": true,
    "nlp": "Find loans with duplicate balances, ordered by their creation time, and return each loan along with a list of creation times of matching loans, up to 32 entries."
  },
  {
    "query": "MATCH (a:Loan {loanUsage: '110901140823999572'})-[:Company_Own_Account]->(b:Loan) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Loan) WHERE c.interestRate = '110901140823999572' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where an account with a specific loan usage owns a company and another account withdraws funds, with matching interest rates."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanAmount = '110901140823999572' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 create times from loans where loan amount does not equal a specific value, ordered by create time."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Loan) OR (a)-[:Company_Invest_Company]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans where there is no company guarantee company relationship or a company invest company relationship exists."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Loan) OR (a)-[:Person_Invest_Company]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 create times from loans where there is no medium sign in account relationship or a person invest company relationship exists, ordered by create time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.nickname) AS min_value",
    "answer": "Aaron Nutting",
    "is_noise_query": true,
    "nlp": "Return the nickname that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 phone numbers from accounts where there is a transfer account relationship, ordered by phone number."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Apply_Loan]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where there is no person apply loan relationship or an account withdraw account relationship exists."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Transfer_Account *2..2]-(b:Account) RETURN count(b) AS cnt",
    "answer": 10089580,
    "is_noise_query": true,
    "nlp": "Count accounts that are involved in a transfer account relationship exactly twice."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:64176294690031206",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4661507089305174028",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4672766088373601934",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4671077238513337662",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4662070039258597186",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:41095346599755900",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4644337115725825070",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:45035996273706602",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts by last login time and then find another top 10 accounts by last login time, returning pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of accounts where each pair consists of different accounts, ordered by their phone number and then by email."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '217580156997338892'})-[:Account_Transfer_Account]->(b:Account) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Account) WHERE c.accountLevel = '217580156997338892' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of instances where an account with a specific account level transfers funds to another account, and that second account subsequently applies for a loan, both having the same specific account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType = '217580156997338892' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the frequency login type is not equal to the specific string '217580156997338892'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime ENDS WITH '217580156997338892' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 last login times from accounts where the create time does not end with '217580156997338892', ordered by last login time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where there is no repay loan relationship or where a company apply loan relationship exists."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 frequency login types from accounts that do not have a loan deposit relationship or have a company apply loan relationship, ordered by frequency login type."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.loanAmount) AS avg_value",
    "answer": 48819411.184508234,
    "is_noise_query": true,
    "nlp": "Calculate the average loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanAmount) AS min_value",
    "answer": 88778.0,
    "is_noise_query": true,
    "nlp": "Find the minimum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanAmount) AS max_value",
    "answer": 99999435.0,
    "is_noise_query": true,
    "nlp": "Find the maximum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Company_Guarantee_Company]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the lowest 32 interest rates from loans that have a company guarantee relationship, ordered by interest rate."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Loan) OR (n)-[:Company_Apply_Loan]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have a company guarantee or are directly associated with a company through an application."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanAmount LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:19140298416325639",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4633641066610819901",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4628574517030027418",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:17169973579351110",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:17169973579351110",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:19140298416325639",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4628574517030027418",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4633641066610819901",
        "b": "Loan:4907797693926998719"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 newest loans and then find the top 10 loans by loan amount, returning both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.balance RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "For each loan, find another distinct loan with a different balance and count all such unique pairs, ordering by balance."
  },
  {
    "query": "MATCH (a:Loan {interestRate: '201817558301540376'})-[:Company_Guarantee_Company]->(b:Loan) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Loan) WHERE c.balance = '201817558301540376' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find loans guaranteed by another loan and then identify those with an account transfer where the transfer involves a loan with a specific balance, returning the count of such loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime <> '201817558301540376' WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find loans created on a specific date and return the first 32 unique loan usage types ordered by their usage value."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Invest_Company]->(:Loan) OR (a)-[:Person_Guarantee_Person]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not involve person investment or involve person guarantee."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Own_Account]->(:Loan) OR (a)-[:Person_Guarantee_Person]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS vals",
    "answer": [
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures"
    ],
    "is_noise_query": true,
    "nlp": "Find loans that do not involve company ownership or involve person guarantee, and return the first 32 loan usage types ordered by their usage value."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find accounts with person-to-person guarantees and return their creation times."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a medium sign-in relationship or are directly linked as a company-owned account."
  },
  {
    "query": "MATCH p = (a:Account)-[:Loan_Deposit_Account *3..4]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 4.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths where accounts are connected through exactly three or four loan deposit relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4856850723142369842",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:258394028620382770",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:213920982300098729",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4885842645743567017",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4503599627371623"
      },
      {
        "a": "Account:273312202386047344",
        "b": "Account:4503599627371623"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts by phone number, then among these, find the top 10 accounts by account ID, returning both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.nickname RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find unique pairs of distinct accounts ordered by phone number and then by nickname, counting all such pairs."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4897664594765415540'})-[:Person_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.nickname = '4897664594765415540' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find accounts with a specific account level and person loan applications, then identify those with medium sign-ins by a specific nickname, returning the count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType ENDS WITH '4897664594765415540' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the frequency login type does not end with a specific value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime = '4897664594765415540' WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts with last login time not equal to a specific value, order them by account level, and return the first 32 account levels."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Company_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have company ownership or are involved in company investments."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that either do not have person ownership or are involved in loan deposits, and return the first 32 creation times ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Account) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of last login times for accounts, considering two separate but identical sets of accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account]-()-[:Company_Own_Account]-(b:Account) WHERE NOT (a)-[:Company_Own_Account]-(b) WITH b ORDER BY b.freqLoginType LIMIT 20 RETURN b.freqLoginType",
    "answer": [
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      },
      {
        "b.freqLoginType": "ATM"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that are part of a complex ownership chain but have no direct ownership link between them, and return their frequency login type, ordered by this type, limited to the top 20."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.mediumType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the mediumType that comes first alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Account_Withdraw_Account]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find mediums with account withdrawals and return their last login times, ordered by this time, limited to the top 32."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Medium) OR (n)-[:Medium_SignIn_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have medium sign-ins or do have medium sign-ins, effectively counting all mediums."
  },
  {
    "query": "MATCH (a:Medium)-[:Medium_SignIn_Account *1..5]-(b:Medium) RETURN count(b) AS cnt",
    "answer": 1152484,
    "is_noise_query": true,
    "nlp": "Count mediums connected by one to five medium sign-in relationships."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1132",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1952",
        "b": "Medium:884"
      },
      {
        "a": "Medium:80",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1447",
        "b": "Medium:884"
      },
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:884"
      },
      {
        "a": "Medium:884",
        "b": "Medium:884"
      },
      {
        "a": "Medium:918",
        "b": "Medium:884"
      },
      {
        "a": "Medium:697",
        "b": "Medium:884"
      },
      {
        "a": "Medium:386",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 mediums by creation time and then find the top 10 mediums by creation time again, returning both sets."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.riskLevel RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Find unique pairs of mediums where one is not blocked and the other is not blocked, ordered by the risk level of the second medium, and count these pairs."
  },
  {
    "query": "MATCH (a:Medium {mediumType: '26388279067618'})-[:Account_Repay_Loan]->(b:Medium) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Medium) WHERE c.riskLevel = '26388279067618' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find mediums with a specific medium type involved in account repayments, then find those with account withdrawals where the withdrawal target has a specific risk level, returning the count of such transactions."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked = '26388279067618' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums where the isBlocked attribute does not match a specific value."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType <> '26388279067618' WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find mediums with a medium type exactly matching '26388279067618' and return the first 32 medium types."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Person_Own_Account]->(:Medium) OR (a)-[:Account_Transfer_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have any outgoing Person_Own_Account relationships or have outgoing Account_Transfer_Account relationships."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Apply_Loan]->(:Medium) OR (a)-[:Person_Invest_Company]->(:Medium) WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Find mediums that either do not have outgoing Company_Apply_Loan relationships or have outgoing Person_Invest_Company relationships, and return the first 32 risk levels ordered by riskLevel."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Medium) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Return the count of non-null last login times for mediums, effectively counting distinct mediums based on their last login times."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.freqLoginType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the most frequent login type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the highest account level that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find accounts with company guarantees and return their phone numbers, ordered by phonenum."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have any outgoing Account_Transfer_Account relationships or have outgoing Person_Guarantee_Person relationships."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account *2..3]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3184,
    "is_noise_query": true,
    "nlp": "Count accounts that are part of a specific ownership chain where they are owned by another account through Company_Own_Account relationships exactly two or three steps away."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "First, find the top 10 accounts by last login time. Then, from these accounts, find the top 10 accounts by account type, returning both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find unique pairs of accounts where one account is blocked and the other is not, and sort these pairs by the blocked account's email, then count the number of such pairs."
  },
  {
    "query": "MATCH (a:Account {accountType: '232216855786291926'})-[:Person_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Account) WHERE c.isBlocked = '232216855786291926' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find accounts with a specific account type and trace their person loan applications to related accounts. Then, identify accounts from these that also have person investments and are blocked, returning the count of such accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType = '232216855786291926' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts whose frequency login type does not match a specific value, sort these accounts by their last login time, and return the first 32 last login times."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have any outgoing account transfer relationships or have an incoming relationship indicating person ownership."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that either do not have any incoming relationships indicating company ownership or have outgoing account transfer relationships, sort these accounts by their last login time, and return the first 32 last login times."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.createTime) AS cnt UNION MATCH (b:Account) RETURN count(b.createTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of creation times for two separate sets of accounts, effectively doubling the count of account creation instances."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Transfer_Account]-()-[:Account_Transfer_Account]-(b:Account) WHERE NOT (a)-[:Account_Transfer_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that are part of a complex transfer chain but do not have a direct transfer link to another account in the same chain, sort these accounts by their blocked status, limit the results to 20, and return their blocked status."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.nickname) AS max_value",
    "answer": "Zulma Dixey",
    "is_noise_query": true,
    "nlp": "Find the nickname that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find accounts with account transfers, sort these accounts by their creation time, and return the first 32 creation times."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Company_Guarantee_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have company loan applications or have company guarantees."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.nickname LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:9570149208163490",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4617596992938311786",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4617596992938311786",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:241224055041032454"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts by creation time, then among these, find the top 10 by nickname, and return both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find unique pairs of distinct accounts ordered by nickname and then by frequency login type, counting all such pairs."
  },
  {
    "query": "MATCH (a:Account {createTime: '4876835446488826817'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Account) WHERE c.accountLevel = '4876835446488826817' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the account with a specific creation time and its associated company investments, then identify those with person loan applications matching a specific account level, returning the count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType CONTAINS '4876835446488826817' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the frequency login type does not contain a specific value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email CONTAINS '4876835446488826817' WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts with emails not containing a specific value, order them by frequency login type, and return the first 32 frequency login types."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have person investments or have medium sign-ins."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Apply_Loan]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that either do not have company loan applications or have company ownership, order them by last login time, and return the first 32 last login times."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.createTime) AS cnt UNION MATCH (b:Account) RETURN count(b.createTime) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of creation times for accounts from two separate matches."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.nickname LIMIT 20 RETURN b.nickname",
    "answer": [
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Abdul Torigian"
      },
      {
        "b.nickname": "Abdul Torigian"
      },
      {
        "b.nickname": "Abel Toyn"
      },
      {
        "b.nickname": "Abel Toyn"
      },
      {
        "b.nickname": "Abel Toyn"
      },
      {
        "b.nickname": "Abel Toyn"
      },
      {
        "b.nickname": "Abel Toyn"
      },
      {
        "b.nickname": "Abel Toyn"
      },
      {
        "b.nickname": "Adalberto Roghair"
      },
      {
        "b.nickname": "Adalberto Roghair"
      },
      {
        "b.nickname": "Adalberto Roghair"
      },
      {
        "b.nickname": "Adalberto Roghair"
      },
      {
        "b.nickname": "Adalberto Roghair"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find accounts indirectly connected through Loan_Deposit_Account relationships that do not have a direct relationship, order them by nickname, and return the nicknames of these accounts, limited to 20 results."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.country) AS min_value",
    "answer": "Afghanistan",
    "is_noise_query": true,
    "nlp": "Return the country that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum value of the isBlocked field among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Loan_Deposit_Account]->(:Person) WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "For persons with outgoing Loan_Deposit_Account relationships, return the first 32 birthdays sorted by date."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Invest_Company]->(:Person) OR (n)-[:Account_Transfer_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count persons who either do not have an outgoing Person_Invest_Company relationship or have an outgoing Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (a:Person)-[:Person_Guarantee_Person *2..2]-(b:Person) RETURN count(b) AS cnt",
    "answer": 1594,
    "is_noise_query": true,
    "nlp": "Count unique persons involved in a two-hop Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.country LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.birthday LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:2199023256209",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:17592186045396",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:21990232555896",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:19791209300802",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:6597069766957",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:17592186044635",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:26388279066767",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:24189255811977",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:13194139533426",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:10995116277957",
        "b": "Person:6597069766722"
      }
    ],
    "is_noise_query": true,
    "nlp": "Pair each of the top 10 persons by country with the top 10 persons by birthday and return these pairs."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.gender MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.birthday RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different persons ordered by gender and then by birthday."
  },
  {
    "query": "MATCH (a:Person {country: '8796093022474'})-[:Loan_Deposit_Account]->(b:Person) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Person) WHERE c.city = '8796093022474' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of people who have a Loan_Deposit_Account relationship from a specific country and also have a Medium_SignIn_Account relationship with a specific city."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.createTime ENDS WITH '8796093022474' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count persons whose create time does not end with a specific string."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.birthday CONTAINS '8796093022474' WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [
      "Aachen",
      "Aachen",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Addis_Ababa",
      "Agadir",
      "Agadir",
      "Ahmedabad",
      "Ahmedpur_Sial",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Al_Hudaydah",
      "Alappuzha",
      "Alashankou",
      "Aligarh",
      "Aligarh",
      "Aligarh",
      "Allahabad",
      "Almaty",
      "Ambon",
      "Ambovombe",
      "Amparafaravola",
      "Amritsar",
      "Anand",
      "Anand",
      "Anantapur",
      "Anda",
      "Anda"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 cities of persons whose birthdays do not contain a specific string, ordered by city."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Person) OR (a)-[:Company_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count persons who either do not have an outgoing Loan_Deposit_Account relationship or have an outgoing Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Person) OR (a)-[:Person_Invest_Company]->(:Person) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [
      "Aachen",
      "Aachen",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Addis_Ababa",
      "Agadir",
      "Agadir",
      "Ahmedabad",
      "Ahmedpur_Sial",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Al_Hudaydah",
      "Alappuzha",
      "Alashankou",
      "Aligarh",
      "Aligarh",
      "Aligarh",
      "Allahabad",
      "Almaty",
      "Ambon",
      "Ambovombe",
      "Amparafaravola",
      "Amritsar",
      "Anand",
      "Anand",
      "Anantapur",
      "Anda",
      "Anda"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 cities of persons who do not have an outgoing Account_Withdraw_Account relationship or have an outgoing Person_Invest_Company relationship, ordered by city."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 12:37:50.617",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 07:23:57.080",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Guarantee_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 473,
    "is_noise_query": true,
    "nlp": "Count companies that have at least one outgoing Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Invest_Company]->(:Company) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Angola",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Azerbaijan"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 countries of companies that have at least one outgoing Company_Invest_Company relationship, ordered by country."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Own_Account]->(:Company) OR (n)-[:Account_Repay_Loan]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have an incoming Person_Own_Account relationship or have an outgoing Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:344",
        "b": "Company:423"
      },
      {
        "a": "Company:584",
        "b": "Company:423"
      },
      {
        "a": "Company:237",
        "b": "Company:423"
      },
      {
        "a": "Company:43",
        "b": "Company:423"
      },
      {
        "a": "Company:641",
        "b": "Company:423"
      },
      {
        "a": "Company:599",
        "b": "Company:423"
      },
      {
        "a": "Company:423",
        "b": "Company:423"
      },
      {
        "a": "Company:538",
        "b": "Company:423"
      },
      {
        "a": "Company:595",
        "b": "Company:423"
      },
      {
        "a": "Company:807",
        "b": "Company:423"
      }
    ],
    "is_noise_query": true,
    "nlp": "Pair each of the top 10 companies by creation time with the top 10 companies by creation time and return these pairs."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.url MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different companies where one company's URL is different from the other's, ordered by URL and then by creation time."
  },
  {
    "query": "MATCH (a:Company), (b:Company) WHERE a.companyName = b.companyName AND a <> b RETURN count(*) AS cnt",
    "answer": 146,
    "is_noise_query": true,
    "nlp": "Count duplicate company names excluding self-references."
  },
  {
    "query": "MATCH (a:Company {url: '2199023256282'})-[:Person_Own_Account]->(b:Company) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Company) WHERE c.companyName = '2199023256282' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count companies that have a Person_Own_Account relationship from a specific URL and also have a Person_Invest_Company relationship with a company named '2199023256282'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.createTime STARTS WITH '2199023256282' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 isBlocked statuses of companies whose creation times do not start with '2199023256282', ordered by the isBlocked status."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Company) OR (a)-[:Person_Invest_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have an outgoing Person_Guarantee_Person relationship or have an outgoing Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Own_Account]->(:Company) OR (a)-[:Company_Guarantee_Company]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 company names of companies that either do not have an outgoing Person_Own_Account relationship or have an outgoing Company_Guarantee_Company relationship, ordered by company name."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.interestRate) AS avg_value",
    "answer": 0.05062750217580504,
    "is_noise_query": true,
    "nlp": "Calculate the average interest rate of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.balance) AS max_value",
    "answer": 99766573.87,
    "is_noise_query": true,
    "nlp": "Find the maximum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Own_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 interest rates of loans that have an outgoing Person_Own_Account relationship, ordered by interest rate."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Loan) OR (n)-[:Company_Own_Account]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have an outgoing Person_Guarantee_Person relationship or have an outgoing Company_Own_Account relationship."
  },
  {
    "query": "MATCH (n:Loan) WHERE n.interestRate <> '290200700988687183' OR (n)-[:Person_Invest_Company]->(:Loan) RETURN avg(n.loanAmount)",
    "answer": 48819411.184508234,
    "is_noise_query": true,
    "nlp": "Calculate the average loan amount of loans where the interest rate does not match '290200700988687183' or have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Loan)-[:Company_Apply_Loan *1..2]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 2004,
    "is_noise_query": true,
    "nlp": "Count loans involved in a one or two-hop \"Company_Apply_Loan\" relationship."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanAmount LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4863606122583425208",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4877116921465536915",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4835740099889070948",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4835740099889070948",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4863606122583425208",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:4907797693926998719"
      },
      {
        "a": "Loan:4877116921465536915",
        "b": "Loan:188306759419429567"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4907797693926998719"
      }
    ],
    "is_noise_query": true,
    "nlp": "Pair each of the top 10 loans by balance with the top 10 loans by loan amount and return these pairs."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.loanUsage RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different loans, first ordered by balance and then by loan usage."
  },
  {
    "query": "MATCH (a:Loan {loanAmount: '290200700988687183'})-[:Company_Invest_Company]->(b:Loan) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Loan) WHERE c.loanUsage = '290200700988687183' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans that have a \"Company_Invest_Company\" relationship from a specific loan amount and also have a \"Person_Apply_Loan\" relationship with a specific loan usage."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanUsage STARTS WITH '290200700988687183' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans whose loan usage does not start with a specific string."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime CONTAINS '290200700988687183' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 interest rates of loans whose creation time does not contain a specific string, ordered by interest rate."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Loan) OR (a)-[:Person_Invest_Company]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have an outgoing \"Loan_Deposit_Account\" relationship or have an outgoing \"Person_Invest_Company\" relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Invest_Company]->(:Loan) OR (a)-[:Company_Own_Account]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 loan amounts of loans that either do not have an outgoing \"Person_Invest_Company\" relationship or have an outgoing \"Company_Own_Account\" relationship, ordered by loan amount."
  },
  {
    "query": "MATCH (a:Loan) RETURN count(a.balance) AS cnt UNION MATCH (b:Loan) RETURN count(b.balance) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of non-null balances in loans."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.birthday) AS min_value",
    "answer": "1980-01-08",
    "is_noise_query": true,
    "nlp": "Find the earliest birthday among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum value of the isBlocked field among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Guarantee_Person]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [
      "2020-01-02 18:57:28.118",
      "2020-01-07 13:25:56.241",
      "2020-01-08 17:20:47.273",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-27 21:05:33.077",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-06 03:19:45.410",
      "2020-02-15 19:42:27.148",
      "2020-02-16 06:16:05.117",
      "2020-02-20 01:15:46.825",
      "2020-02-20 03:03:26.914",
      "2020-02-20 11:59:13.916",
      "2020-02-23 18:00:08.456",
      "2020-02-25 09:29:29.547",
      "2020-02-26 10:13:20.280",
      "2020-03-04 02:27:58.737",
      "2020-03-13 06:00:17.014",
      "2020-03-15 11:02:33.486",
      "2020-03-19 05:02:39.802",
      "2020-03-21 00:18:41.195"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 create times of persons who have a Person_Guarantee_Person relationship, ordered by their creation time."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Person) OR (n)-[:Person_Own_Account]->(:Person) RETURN count(n)",
    "answer": 469,
    "is_noise_query": true,
    "nlp": "Count persons that either do not have a Person_Guarantee_Person relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Person)-[:Person_Guarantee_Person *2..2]-(b:Person) RETURN count(b) AS cnt",
    "answer": 1594,
    "is_noise_query": true,
    "nlp": "Count unique persons involved in a two-hop Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.birthday LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:808",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:51",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:41",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:310",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:630",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:985",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:982",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:640",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:729",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:755",
        "b": "Person:6597069766722"
      }
    ],
    "is_noise_query": true,
    "nlp": "Pair each of the top 10 persons by blocked status with the top 10 persons by birthday and return these pairs."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.gender MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different persons ordered by gender and then by creation time."
  },
  {
    "query": "MATCH (a:Person {city: '8796093022737'})-[:Company_Invest_Company]->(b:Person) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Person) WHERE c.createTime = '8796093022737' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count persons who have a Company_Invest_Company relationship from a specific city and also have a Person_Guarantee_Person relationship with a specific creation time."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country CONTAINS '8796093022737' WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS vals",
    "answer": [
      "Abay",
      "Abdalas",
      "Abdelli",
      "Abrikosov",
      "Abutalybov",
      "Acevedo",
      "Aghdamski",
      "Agnes Christina Of Austria",
      "Aguilar",
      "Aird",
      "Akhurst",
      "Akindele",
      "Akyz",
      "Al Hussain",
      "Albar",
      "Alcala",
      "Alder",
      "Ales",
      "Alexander",
      "Alghisi",
      "Alling",
      "Almeyda",
      "Altavista",
      "Ambrosius",
      "Amonqulova",
      "Amoroso",
      "Anaya",
      "Anderson",
      "Anderson",
      "Anderson",
      "Anderson Imbert",
      "Andhyarujina"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 person names of persons whose country does not contain a specific string, ordered by person name."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Transfer_Account]->(:Person) OR (a)-[:Company_Invest_Company]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count persons that either do not have an Account_Transfer_Account relationship or have a Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Own_Account]->(:Person) OR (a)-[:Person_Own_Account]->(:Person) WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS vals",
    "answer": [
      "1980-01-08",
      "1980-01-18",
      "1980-01-21",
      "1980-01-23",
      "1980-01-29",
      "1980-02-02",
      "1980-02-04",
      "1980-02-06",
      "1980-03-11",
      "1980-03-19",
      "1980-03-19",
      "1980-03-21",
      "1980-03-31",
      "1980-04-09",
      "1980-04-13",
      "1980-04-13",
      "1980-04-15",
      "1980-04-15",
      "1980-04-20",
      "1980-04-21",
      "1980-05-22",
      "1980-06-19",
      "1980-06-19",
      "1980-06-27",
      "1980-07-14",
      "1980-07-17",
      "1980-07-27",
      "1980-08-02",
      "1980-08-11",
      "1980-08-15",
      "1980-08-18",
      "1980-08-22"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 birthdays of persons who do not have a Company_Own_Account relationship or have a Person_Own_Account relationship, ordered by birthday."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.mediumType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the mediumType that comes first alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 23:57:25.319",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Invest_Company]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 last login times of mediums that have at least one outgoing Company_Invest_Company relationship, ordered by lastLoginTime."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Repay_Loan]->(:Medium) OR (n)-[:Company_Apply_Loan]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have an Account_Repay_Loan relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.mediumId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1447",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1952",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:19"
      },
      {
        "a": "Medium:697",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1132",
        "b": "Medium:19"
      },
      {
        "a": "Medium:80",
        "b": "Medium:19"
      },
      {
        "a": "Medium:918",
        "b": "Medium:19"
      },
      {
        "a": "Medium:86",
        "b": "Medium:19"
      },
      {
        "a": "Medium:884",
        "b": "Medium:19"
      },
      {
        "a": "Medium:386",
        "b": "Medium:19"
      }
    ],
    "is_noise_query": true,
    "nlp": "Pair each of the top 10 mediums by creation time with the top 10 mediums by mediumId and return these pairs."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different mediums ordered by isBlocked."
  },
  {
    "query": "MATCH (a:Medium {createTime: '43980465111982'})-[:Loan_Deposit_Account]->(b:Medium) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Medium) WHERE c.lastLoginTime = '43980465111982' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count mediums that have a Loan_Deposit_Account relationship from a specific creation time and also have a Loan_Deposit_Account relationship with a specific last login time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime ENDS WITH '43980465111982' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums whose creation time does not end with a specific string."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.lastLoginTime <> '43980465111982' WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 medium types of mediums whose last login time matches a specific string, ordered by mediumType."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Medium) OR (a)-[:Account_Withdraw_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that do not have a Medium_SignIn_Account relationship or have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Medium) OR (a)-[:Company_Apply_Loan]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-01-29 05:12:39.506",
      "2020-02-03 17:46:43.836",
      "2020-02-15 19:29:12.059",
      "2020-03-07 12:38:42.833",
      "2020-03-12 20:53:48.093",
      "2020-03-20 08:34:41.767",
      "2020-03-28 05:20:45.915",
      "2020-04-02 18:27:25.513",
      "2020-04-03 19:25:08.930",
      "2020-04-05 16:30:10.209",
      "2020-04-08 12:15:42.926",
      "2020-04-19 15:31:53.628",
      "2020-04-30 08:24:02.358",
      "2020-05-17 13:12:15.150",
      "2020-05-18 06:16:54.756",
      "2020-05-19 10:29:57.660",
      "2020-05-24 18:06:27.871",
      "2020-05-28 09:43:48.217",
      "2020-05-29 05:26:41.843",
      "2020-06-05 17:35:15.999",
      "2020-06-06 14:42:45.787",
      "2020-06-18 21:36:31.467",
      "2020-06-21 18:28:14.001",
      "2020-06-22 17:25:34.472",
      "2020-06-23 10:15:27.445",
      "2020-06-25 22:58:42.936",
      "2020-07-01 07:39:30.970",
      "2020-07-04 05:11:00.922",
      "2020-07-07 11:59:49.304",
      "2020-07-09 23:56:58.844",
      "2020-07-12 12:44:05.479",
      "2020-07-16 23:19:43.551"
    ],
    "is_noise_query": true,
    "nlp": "Return the last login times of Medium nodes that do not have a Loan_Deposit_Account relationship or have a Company_Apply_Loan relationship, ordered by their last login time, limited to 32."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.createTime) AS cnt UNION MATCH (b:Medium) RETURN count(b.createTime) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Union count of creation times from two separate matches on Medium nodes, effectively returning the same count twice."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.phonenum) AS max_value",
    "answer": "999-9198",
    "is_noise_query": true,
    "nlp": "Find the phone number that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the last login times of Account nodes that have a Company_Own_Account relationship, ordered by their last login time, limited to 32."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that do not have a Person_Guarantee_Person relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.nickname LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4744542207434819682",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:241224055041032454"
      }
    ],
    "is_noise_query": true,
    "nlp": "Collect nicknames of Account nodes whose phone number is not '223209656531552190', ordered by nickname, limited to 10. Then, for each of these, collect nicknames of other Account nodes ordered by nickname, also limited to 10, and return both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Account nodes where the first node does not have a Company_Own_Account relationship with the second node, ordered by account type and then by frequency of login type."
  },
  {
    "query": "MATCH (a:Account {nickname: '223209656531552190'})-[:Person_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Account) WHERE c.accountLevel = '223209656531552190' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that are part of a path where they are connected by Person_Invest_Company and Account_Transfer_Account relationships, where the target node's account level is '223209656531552190'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType CONTAINS '223209656531552190' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of Account nodes where the account type does not contain '223209656531552190'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum = '223209656531552190' WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Find the nicknames of Account nodes excluding those with phone number '223209656531552190', ordered by nickname, limited to 32."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either do not have a Company_Own_Account relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect nicknames of Account nodes that either do not have a Company_Own_Account relationship or have a Person_Invest_Company relationship, ordered by nickname, limited to 32."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Account) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.nickname LIMIT 20 RETURN b.nickname",
    "answer": [
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      },
      {
        "b.nickname": "Aaron Nutting"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the nicknames of Account nodes where there exists a path involving Medium_SignIn_Account relationships, but not directly connected by Medium_SignIn_Account, ordered by nickname, limited to 20."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountLevel) AS min_value",
    "answer": "Basic level",
    "is_noise_query": true,
    "nlp": "Return the minimum account level value among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Return the maximum account level value among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect phone numbers of Account nodes that have a Company_Guarantee_Company relationship, ordered by phone number, limited to 32."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Person_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either do not have a Company_Apply_Loan relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH p = (a:Account)-[:Loan_Deposit_Account *1..5]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.80540558554955,
    "is_noise_query": true,
    "nlp": "Return the average length of paths between Account nodes connected by Loan_Deposit_Account relationships, with a path length between 1 and 5."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountId LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4503599627371623",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "Collect pairs of Account nodes where the first ten are ordered by accountId and the second ten by accountType."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Account nodes where the first node's freqLoginType is ordered, and the second node's accountType is also ordered, excluding self-pairing."
  },
  {
    "query": "MATCH (a:Account {createTime: '281474976710657836'})-[:Person_Own_Account]->(b:Account) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Account) WHERE c.phonenum = '281474976710657836' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of Account nodes that have a Person_Own_Account relationship with another Account node, which in turn has a Company_Apply_Loan relationship with an Account node having a specific phone number."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email = '281474976710657836' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of Account nodes whose email does not match a given value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel = '281474976710657836' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 create times of Account nodes that do not have a specified account level, ordered by their creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Repay_Loan]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either do not have an Account_Repay_Loan relationship or have an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 blocked statuses of Account nodes that do not have a Person_Apply_Loan relationship or have a Person_Invest_Company relationship, ordered by their blocked status."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Transfer_Account]-()-[:Account_Transfer_Account]-(b:Account) WHERE NOT (a)-[:Account_Transfer_Account]-(b) WITH b ORDER BY b.phonenum LIMIT 20 RETURN b.phonenum",
    "answer": [
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      },
      {
        "b.phonenum": "000-7201"
      }
    ],
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that are part of a path involving Account_Transfer_Account relationships, excluding direct connections, and have a phone number different from a specified value."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.email) AS min_value",
    "answer": "37.com",
    "is_noise_query": true,
    "nlp": "Return the email that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.nickname) AS max_value",
    "answer": "Zulma Dixey",
    "is_noise_query": true,
    "nlp": "Find the nickname that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 frequency login types of Account nodes that have an Account_Repay_Loan relationship, ordered by their frequency login type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes that either do not have a Person_Guarantee_Person relationship pointing to another Account or do have such a relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 Accounts ordered by accountLevel, then for each of these, find the top 10 Accounts ordered by accountType, and return the pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of Account nodes where the first node's nickname is ordered and the second node's freqLoginType is ordered, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Account {freqLoginType: '216735732067207154'})-[:Account_Withdraw_Account]->(b:Account) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Account) WHERE c.createTime = '216735732067207154' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes where the source node has a specific freqLoginType and there is an Account_Withdraw_Account relationship leading to a target node, which in turn has a Person_Invest_Company relationship to another node created at a specific time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email CONTAINS '216735732067207154' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count Account nodes where the email does not contain a specific substring."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime STARTS WITH '216735732067207154' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect the creation times of the first 32 Account nodes whose last login time does not start with a specific string, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes that either do not have a Person_Own_Account relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect the emails of the first 32 Account nodes that either do not have a Person_Apply_Loan relationship or have a Loan_Deposit_Account relationship, ordered by email."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountType) AS cnt UNION MATCH (b:Account) RETURN count(b.accountType) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Union count of account types from two separate matches on Account nodes, effectively returning the same count twice."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.country) AS min_value",
    "answer": "Afghanistan",
    "is_noise_query": true,
    "nlp": "Return the country that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum value of the isBlocked attribute among all Person nodes."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Guarantee_Company]->(:Person) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return a list of up to 32 unique city names of Person nodes who are involved in a Company_Guarantee_Company relationship with another Person node, sorted by city."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Company_Own_Account]->(:Person) OR (n)-[:Person_Own_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count Person nodes that either do not have a Company_Own_Account relationship or have a Person_Own_Account relationship with another Person node."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.country LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:6597069766957",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:17592186045396",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:2199023256209",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:24189255811977",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:26388279066767",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:21990232555896",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:13194139533426",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:19791209300802",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:17592186044635",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:10995116277957",
        "b": "Person:28587302322284"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 Person nodes ordered by country, then for each of these find the top 10 associated Person nodes ordered by personName, and return both sets of nodes."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.gender MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.birthday RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Person nodes (a, b) where a and b are different, ordered by gender of a and birthday of b."
  },
  {
    "query": "MATCH (a:Person {createTime: '6597069766739'})-[:Company_Apply_Loan]->(b:Person) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Person) WHERE c.birthday = '6597069766739' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes b that are connected to a specific Person node a through a Company_Apply_Loan relationship, and also have a Company_Guarantee_Company relationship with a Person node c who has a specific birthday."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.birthday = '6597069766739' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes whose birthday does not match a specific value."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country ENDS WITH '6597069766739' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the isBlocked statuses of up to 32 Person nodes whose country does not end with a specific string, ordered by isBlocked."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Person) OR (a)-[:Company_Invest_Company]->(:Person) RETURN count(a) AS cnt",
    "answer": 469,
    "is_noise_query": true,
    "nlp": "Count Person nodes that either do not have a Person_Guarantee_Person relationship or have a Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Invest_Company]->(:Person) OR (a)-[:Company_Guarantee_Company]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Collect the creation times of up to 32 Person nodes who either do not have a Company_Invest_Company relationship or have a Company_Guarantee_Company relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.interestRate) AS avg_value",
    "answer": 0.05062750217580504,
    "is_noise_query": true,
    "nlp": "Calculate the average interest rate of all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.loanAmount) AS total_value",
    "answer": 112187006902.0,
    "is_noise_query": true,
    "nlp": "Find the total sum of loan amounts for all Loan nodes."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.interestRate) AS max_value",
    "answer": 0.1,
    "is_noise_query": true,
    "nlp": "Find the maximum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Loan_Deposit_Account]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the loan amounts of Loan nodes that have a Loan_Deposit_Account relationship, ordered by loan amount, limited to 32."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Own_Account]->(:Loan) OR (n)-[:Company_Apply_Loan]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of Loan nodes that either do not have a Person_Own_Account relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH p = (a:Loan)-[:Person_Apply_Loan *2..4]-(b:Loan) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths involving Loan nodes where there are between 2 and 4 consecutive Person_Apply_Loan relationships."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.interestRate LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4866420872350532459"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4894568370021597389"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4759460381200482587"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:217298682020626503"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4889501820440805670"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4890627720347648427"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:123848989752689515"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:143833713099145499"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4802807527613924326"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4894849844998307888"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 Loan nodes ordered by loan amount, then find the top 10 Loan nodes ordered by interest rate and return both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of Loan nodes, excluding self-pairs, ordered by create time."
  },
  {
    "query": "MATCH (a:Loan {createTime: '237846355320504912'})-[:Person_Guarantee_Person]->(b:Loan) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Loan) WHERE c.createTime = '237846355320504912' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of loans that have both a Person_Guarantee_Person relationship and a Person_Invest_Company relationship with the same createTime."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime ENDS WITH '237846355320504912' WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Return the top 32 loan amounts excluding those whose createTime ends with '237846355320504912', ordered by loan amount."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Loan) OR (a)-[:Person_Invest_Company]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that do not have a Medium_SignIn_Account relationship or do have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Own_Account]->(:Loan) OR (a)-[:Company_Guarantee_Company]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Return the top 32 loan amounts of loans that do not have a Person_Own_Account relationship or do have a Company_Guarantee_Company relationship, ordered by loan amount."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 03:31:14.114",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Account_Transfer_Account]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 medium types that have an Account_Transfer_Account relationship, ordered by medium type."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Medium) OR (n)-[:Account_Transfer_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that do not have a Loan_Deposit_Account relationship or do have an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.mediumType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:884",
        "b": "Medium:249"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1551"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1897"
      },
      {
        "a": "Medium:884",
        "b": "Medium:20"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1983"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1728"
      },
      {
        "a": "Medium:884",
        "b": "Medium:680"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1861"
      },
      {
        "a": "Medium:884",
        "b": "Medium:386"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1718"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the first 10 mediums ordered by creation time and then, from those, the first 10 mediums ordered by medium type."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumType MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct mediums where the second medium is not blocked and both are ordered by medium type initially, then by blocked status."
  },
  {
    "query": "MATCH (a:Medium {lastLoginTime: '48378511623157'})-[:Account_Repay_Loan]->(b:Medium) WITH b MATCH (b)-[:Company_Own_Account]->(c:Medium) WHERE c.createTime = '48378511623157' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans that have a repay relationship and a company ownership relationship with the same lastLoginTime."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel STARTS WITH '48378511623157' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes whose riskLevel does not start with '48378511623157'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.lastLoginTime STARTS WITH '48378511623157' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-01-29 05:12:39.506",
      "2020-02-03 17:46:43.836",
      "2020-02-15 19:29:12.059",
      "2020-03-07 12:38:42.833",
      "2020-03-12 20:53:48.093",
      "2020-03-20 08:34:41.767",
      "2020-03-28 05:20:45.915",
      "2020-04-02 18:27:25.513",
      "2020-04-03 19:25:08.930",
      "2020-04-05 16:30:10.209",
      "2020-04-08 12:15:42.926",
      "2020-04-19 15:31:53.628",
      "2020-04-30 08:24:02.358",
      "2020-05-17 13:12:15.150",
      "2020-05-18 06:16:54.756",
      "2020-05-19 10:29:57.660",
      "2020-05-24 18:06:27.871",
      "2020-05-28 09:43:48.217",
      "2020-05-29 05:26:41.843",
      "2020-06-05 17:35:15.999",
      "2020-06-06 14:42:45.787",
      "2020-06-18 21:36:31.467",
      "2020-06-21 18:28:14.001",
      "2020-06-22 17:25:34.472",
      "2020-06-23 10:15:27.445",
      "2020-06-25 22:58:42.936",
      "2020-07-01 07:39:30.970",
      "2020-07-04 05:11:00.922",
      "2020-07-07 11:59:49.304",
      "2020-07-09 23:56:58.844",
      "2020-07-12 12:44:05.479",
      "2020-07-16 23:19:43.551"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 lastLoginTime values of Medium nodes whose lastLoginTime does not start with '48378511623157', ordered by lastLoginTime."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Person_Invest_Company]->(:Medium) OR (a)-[:Person_Guarantee_Person]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of Medium nodes that either do not have a Person_Invest_Company relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Medium) OR (a)-[:Loan_Deposit_Account]->(:Medium) WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 riskLevel values of Medium nodes that either do not have a Loan_Deposit_Account relationship or have a Loan_Deposit_Account relationship, ordered by riskLevel."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum value of the isBlocked attribute among all Person nodes."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum value of the isBlocked attribute among all Person nodes."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Guarantee_Person]->(:Person) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belgium",
      "Belgium",
      "Belgium",
      "Belgium",
      "Bolivia",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil",
      "Brazil"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 countries of Person nodes that have a Person_Guarantee_Person relationship, ordered by country."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Person) OR (n)-[:Company_Own_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes that either do not have an Account_Withdraw_Account relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.birthday LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:21990232556205",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:17592186044516",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:431",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:2199023256119",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:10995116278290",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:24189255811885",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:675",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:4398046511995",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:6597069766722",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:24189255811770",
        "b": "Person:28587302322284"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the first 10 persons ordered by birthday and then, from those, the first 10 persons ordered by person name."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.personName RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count the number of distinct pairs of Person nodes where one node comes before the other in creation time, and both are ordered by person name."
  },
  {
    "query": "MATCH (a:Person {isBlocked: '24189255811460'})-[:Account_Transfer_Account]->(b:Person) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Person) WHERE c.isBlocked = '24189255811460' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of people who have both a transfer relationship and a guarantee relationship with another person having the same isBlocked value."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.gender CONTAINS '24189255811460' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons whose gender does not contain the specific value '24189255811460'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.gender CONTAINS '24189255811460' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 isBlocked values of persons whose gender does not contain the specific value '24189255811460', ordered by isBlocked."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Person) OR (a)-[:Company_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons who either do not have a Company_Guarantee_Company relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Person) OR (a)-[:Account_Withdraw_Account]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 creation times of persons who either do not have a Medium_SignIn_Account relationship or have an Account_Withdraw_Account relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 last login times of accounts that have a person apply loan relationship, ordered by last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Repay_Loan]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have an account repay loan relationship or have a company ownership relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.nickname LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4744542207434819682",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:241224055041032454"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the first 10 accounts ordered by phone number, and from those, return the first 10 accounts ordered by nickname."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts, where the pairs are ordered by the second account's isBlocked status after initially ordering by the first account's email."
  },
  {
    "query": "MATCH (a:Account {lastLoginTime: '4743134832551265197'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Person_Own_Account]->(c:Account) WHERE c.phonenum = '4743134832551265197' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of distinct Account nodes where there is a relationship from an Account with a specific lastLoginTime to another Account via Company_Invest_Company, and then from that Account to another Account via Person_Own_Account, where the latter Account has a specific phone number."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime CONTAINS '4743134832551265197' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 isBlocked statuses of accounts that do not have '4743134832551265197' in their lastLoginTime, ordered by isBlocked."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have a Person_Invest_Company relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Apply_Loan]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 phone numbers of accounts that do not have a Company_Apply_Loan relationship or do have a Company_Own_Account relationship, ordered by phone number."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum isBlocked value among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 23:57:25.319",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Apply_Loan]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 last login times of mediums that have a company apply loan relationship, ordered by last login time."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Medium) OR (n)-[:Medium_SignIn_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of mediums, as the condition specified always evaluates to true due to logical OR with its negation, effectively counting all mediums."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.mediumType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1994",
        "b": "Medium:249"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1551"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1897"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:20"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1983"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1728"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:680"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1861"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:386"
      },
      {
        "a": "Medium:1994",
        "b": "Medium:1718"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the first 10 mediums ordered by last login time and then, from those, the first 10 mediums ordered by medium type."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumType MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.mediumType RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct mediums, where the first medium is ordered by its medium type, and then each pair is further ordered by the second medium's medium type, returning the total count of such pairs."
  },
  {
    "query": "MATCH (a:Medium {riskLevel: '52776558135244'})-[:Company_Own_Account]->(b:Medium) WITH b MATCH (b)-[:Company_Own_Account]->(c:Medium) WHERE c.createTime = '52776558135244' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of distinct paths where a medium with a specific risk level has a 'Company_Own_Account' relationship with another medium, and this second medium also has a 'Company_Own_Account' relationship with a third medium, both having the same creation time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel STARTS WITH '52776558135244' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 creation times of mediums that do not start with '52776558135244' in their riskLevel attribute, ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Medium) OR (a)-[:Company_Guarantee_Company]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of mediums that either do not have an 'Account_Withdraw_Account' relationship or have a 'Company_Guarantee_Company' relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Invest_Company]->(:Medium) OR (a)-[:Person_Own_Account]->(:Medium) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 creation times of mediums that do not have a 'Company_Invest_Company' relationship or do have a 'Person_Own_Account' relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Medium) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Combine the counts of last login times from two separate sets of mediums into a single count."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountType) AS max_value",
    "answer": "trust account",
    "is_noise_query": true,
    "nlp": "Find the account type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 last login times of accounts that have a 'Company_Guarantee_Company' relationship, ordered by last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the total number of accounts, as the condition checks every account whether they have or do not have an 'Account_Withdraw_Account' relationship, effectively counting all accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.nickname LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:231372430856161038",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4796333603149578811",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:231372430856161038",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4819414551239852294",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4877398396442248974",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4819414551239852294",
        "b": "Account:4819414551239852294"
      },
      {
        "a": "Account:4877398396442248974",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:241224055041032454"
      },
      {
        "a": "Account:4796333603149578811",
        "b": "Account:241224055041032454"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the first 10 accounts ordered by nickname, then for each of those, return the first 10 associated accounts ordered by their nickname."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the second account's last login time is ordered after the first account's creation time."
  },
  {
    "query": "MATCH (a:Account {freqLoginType: '4894849844998308386'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.lastLoginTime = '4894849844998308386' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of relationships where an account with a specific freqLoginType has both a Company_Invest_Company relationship and a Medium_SignIn_Account relationship with another account that has the same lastLoginTime."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email = '4894849844998308386' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have the specific email address '4894849844998308386'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType ENDS WITH '4894849844998308386' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 account types of accounts that do not end with '4894849844998308386', ordered by account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Person_Guarantee_Person relationship or have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 emails of accounts that either do not have an Account_Transfer_Account relationship or do have an Account_Withdraw_Account relationship, ordered by email."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the highest account level among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find and return the phone numbers of accounts involved in an account transfer, ordered by phone number, up to 32 entries."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Account) OR (n)-[:Person_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either don't have a Medium_SignIn_Account relationship or do have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:286260051314737727",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4897383119788705189",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:285697101361317507",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:285697101361317507",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:286260051314737727",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:286823001268159172",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:286823001268159172",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4897383119788705189",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 accounts ordered by login frequency, then from those, select another top 10 based on phone number, and return both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "For each account, find another distinct account not equal to itself, order the pairs by the second account's last login time, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4798866877939974442'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Account) WHERE c.lastLoginTime = '4798866877939974442' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find loans related to a specific account through Company_Invest_Company relationships, then find further related loans through Loan_Deposit_Account, where the loan's last login time matches the given timestamp, and return the count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType = '4798866877939974442' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts with a login type different from a specified value, order them by account type, and return the first 32 account types."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either don't have an Account_Withdraw_Account relationship or do have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that either don't have a Person_Own_Account relationship or do have an Account_Transfer_Account relationship, order them by phone number, and return the first 32 phone numbers."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.createTime) AS min_value",
    "answer": "2020-02-15 04:08:32.798",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.interestRate) AS max_value",
    "answer": 0.1,
    "is_noise_query": true,
    "nlp": "Find the maximum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Company_Guarantee_Company]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find and return the creation times of loans related through Company_Guarantee_Company relationships, ordered by creation time, up to 32 entries."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Invest_Company]->(:Loan) OR (n)-[:Loan_Deposit_Account]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either don't have a Person_Invest_Company relationship or do have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanId LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.interestRate LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4866420872350532459"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894568370021597389"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4759460381200482587"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:217298682020626503"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4889501820440805670"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4890627720347648427"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:123848989752689515"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:143833713099145499"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4802807527613924326"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:4894849844998307888"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select top 10 loans ordered by loan ID, then from those select another top 10 ordered by interest rate, and return both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "For each loan, find another distinct loan not equal to itself, ordered by interest rate, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Loan {loanUsage: '4789015253755101996'})-[:Account_Withdraw_Account]->(b:Loan) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Loan) WHERE c.interestRate = '4789015253755101996' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find loans related through Account_Withdraw_Account relationships, then find further related loans through Medium_SignIn_Account, where the loan's interest rate matches a given value, and return the count."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime ENDS WITH '4789015253755101996' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans where the create time does not end with a specified value."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.interestRate STARTS WITH '4789015253755101996' WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find loans where the interest rate does not start with a specified value, order them by loan amount, and return the first 32 loan amounts."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either don't have a Person_Guarantee_Person relationship or do have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Own_Account]->(:Loan) OR (a)-[:Person_Guarantee_Person]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS vals",
    "answer": [
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures"
    ],
    "is_noise_query": true,
    "nlp": "Find loans that either don't have a Company_Own_Account relationship or do have a Person_Guarantee_Person relationship, order them by loan usage, and return the first 32 loan usages."
  },
  {
    "query": "MATCH (a:Loan)-[:Person_Apply_Loan]-()-[:Person_Apply_Loan]-(b:Loan) WHERE NOT (a)-[:Person_Apply_Loan]-(b) WITH b ORDER BY b.interestRate LIMIT 20 RETURN b.interestRate",
    "answer": [
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.0
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      },
      {
        "b.interestRate": 0.001
      }
    ],
    "is_noise_query": true,
    "nlp": "Find loans connected through two Person_Apply_Loan relationships, ensuring they are not directly connected, order them by interest rate, limit to 20, and return their interest rates."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the login type that appears last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find and return the last login times of accounts that have repaid loans to other accounts, ordered by their last login time, up to 32 entries."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either don't have an outgoing Account_Withdraw_Account relationship or do have such a relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835283081",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282792",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407894843",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896538694858572073",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282970",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407895701",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284135",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407894741",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 accounts ordered by isBlocked status, then from those, select another top 10 accounts ordered by email, and return both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "For each account, find another distinct account not equal to itself, ordered by account level, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Account), (b:Account) WHERE a.accountLevel = b.accountLevel AND a <> b RETURN count(*) AS cnt",
    "answer": 6380426,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts with the same account level."
  },
  {
    "query": "MATCH (a:Account {email: '280067601827104610'})-[:Company_Own_Account]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.lastLoginTime = '280067601827104610' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find and return the count of accounts where an account with a specific email is related through a Company_Own_Account relationship to another account, and that second account has a Medium_SignIn_Account relationship with an account whose last login time matches the specific email."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum ENDS WITH '280067601827104610' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the phone number does not end with the specified string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum ENDS WITH '280067601827104610' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Select the top 32 email addresses of accounts where the phone number does not end with the specified string, ordered by email address."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either don't have an outgoing Account_Withdraw_Account relationship or do have such a relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Find and return the last login times of accounts that either do not have any outgoing Company_Guarantee_Company relationships or have incoming Account_Withdraw_Account relationships, ordered by last login time, up to 32 entries."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 03:31:14.114",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all mediums, where 'isBlocked' values are compared lexicographically."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Own_Account]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find and return the medium types of mediums that have a Company_Own_Account relationship pointing to another Medium, ordered by medium type, up to 32 entries."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Transfer_Account]->(:Medium) OR (n)-[:Person_Own_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of mediums that either do not have an Account_Transfer_Account relationship or do have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.mediumId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1447",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1952",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:19"
      },
      {
        "a": "Medium:697",
        "b": "Medium:19"
      },
      {
        "a": "Medium:1132",
        "b": "Medium:19"
      },
      {
        "a": "Medium:80",
        "b": "Medium:19"
      },
      {
        "a": "Medium:918",
        "b": "Medium:19"
      },
      {
        "a": "Medium:86",
        "b": "Medium:19"
      },
      {
        "a": "Medium:884",
        "b": "Medium:19"
      },
      {
        "a": "Medium:386",
        "b": "Medium:19"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find and return the last login times of accounts that either do not have any outgoing Company_Guarantee_Company relationships or have incoming Account_Withdraw_Account relationships, ordered by last login time, up to 32 entries."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.mediumType RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Find and return the ten mediums with the earliest creation times, then find the ten mediums with the earliest medium IDs and return them along with the first ten mediums."
  },
  {
    "query": "MATCH (a:Medium {mediumType: '4398046512025'})-[:Company_Apply_Loan]->(b:Medium) WITH b MATCH (b)-[:Company_Own_Account]->(c:Medium) WHERE c.createTime = '4398046512025' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find and return the count of distinct pairs of mediums where the first medium is blocked and the second medium is not the same as the first, ordered by the second medium's type."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.lastLoginTime ENDS WITH '4398046512025' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of mediums with a specific medium type ('4398046512025') that have a Company_Apply_Loan relationship leading to another medium, which in turn has a Company_Own_Account relationship to a third medium created at a specific time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime <> '4398046512025' WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Count the number of mediums whose last login time does not end with '4398046512025'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Medium) OR (a)-[:Account_Repay_Loan]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Return the count of mediums that either do not have a Loan_Deposit_Account relationship pointing to another medium or have an Account_Repay_Loan relationship pointing to another medium."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Medium) OR (a)-[:Company_Apply_Loan]->(:Medium) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "For each medium, find those that do not have an Account_Withdraw_Account relationship pointing to another medium or have a Company_Apply_Loan relationship pointing to another medium, order them by creation time, and return the first 32 creation times."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.gender) AS min_value",
    "answer": "female",
    "is_noise_query": true,
    "nlp": "Return the gender that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.city) AS max_value",
    "answer": "d",
    "is_noise_query": true,
    "nlp": "Find the city that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person)-[r:Person_Guarantee_Person]-(b:Person) WHERE r._edge_id <> '10995116278450' RETURN count(a) AS cnt",
    "answer": 1292,
    "is_noise_query": true,
    "nlp": "Find the count of persons who are involved in a Person_Guarantee_Person relationship but not with the edge id '10995116278450'."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Guarantee_Company]->(:Person) WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Count persons that have a Company_Guarantee_Company relationship leading to another person, order them by birthday, and return the first 32 birthdays."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Invest_Company]->(:Person) OR (n)-[:Company_Own_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count persons that either do not have a Person_Invest_Company relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.gender LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:315",
        "b": "Person:985"
      },
      {
        "a": "Person:315",
        "b": "Person:640"
      },
      {
        "a": "Person:315",
        "b": "Person:982"
      },
      {
        "a": "Person:315",
        "b": "Person:41"
      },
      {
        "a": "Person:315",
        "b": "Person:729"
      },
      {
        "a": "Person:315",
        "b": "Person:310"
      },
      {
        "a": "Person:315",
        "b": "Person:808"
      },
      {
        "a": "Person:315",
        "b": "Person:630"
      },
      {
        "a": "Person:315",
        "b": "Person:51"
      },
      {
        "a": "Person:315",
        "b": "Person:755"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select top 10 persons ordered by gender, then from those select another top 10 ordered by isBlocked, and return both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.country MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.personName RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Find and return the count of distinct person-country pairs, excluding self-pairs, ordered by country and then by person name."
  },
  {
    "query": "MATCH (a:Person {personName: '10995116278450'})-[:Company_Own_Account]->(b:Person) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Person) WHERE c.createTime = '10995116278450' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find and return the count of persons related through the Company_Own_Account and Company_Guarantee_Company relationships where the latter's creation time matches a specific value."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country STARTS WITH '10995116278450' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes where the country property does not start with '10995116278450'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.birthday STARTS WITH '10995116278450' WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS vals",
    "answer": [
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female"
    ],
    "is_noise_query": true,
    "nlp": "Select the first 32 genders of Person nodes where the birthday property does not start with '10995116278450', ordered by gender."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Person) OR (a)-[:Person_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of Person nodes where there is no Medium_SignIn_Account relationship or there is a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Invest_Company]->(:Person) OR (a)-[:Medium_SignIn_Account]->(:Person) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [
      "Aachen",
      "Aachen",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Addis_Ababa",
      "Agadir",
      "Agadir",
      "Ahmedabad",
      "Ahmedpur_Sial",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Al_Hudaydah",
      "Alappuzha",
      "Alashankou",
      "Aligarh",
      "Aligarh",
      "Aligarh",
      "Allahabad",
      "Almaty",
      "Ambon",
      "Ambovombe",
      "Amparafaravola",
      "Amritsar",
      "Anand",
      "Anand",
      "Anantapur",
      "Anda",
      "Anda"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 cities of Person nodes where there is no Company_Invest_Company relationship or there is a Medium_SignIn_Account relationship, ordered by city."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-15 09:39:18.811",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountType) AS max_value",
    "answer": "trust account",
    "is_noise_query": true,
    "nlp": "Find the account type that comes last alphabetically among all Account nodes."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 account levels of Account nodes where there is a Person_Own_Account relationship, ordered by account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Account) OR (n)-[:Loan_Deposit_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of Account nodes where there is no Medium_SignIn_Account relationship or there is a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285978576338027459",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the first 10 Account nodes ordered by account type, then from those, return another set of the first 10 Account nodes ordered by account type."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the count of unique account type pairs where the second account's last login time is considered, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Account {lastLoginTime: '265149428061438717'})-[:Loan_Deposit_Account]->(b:Account) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Account) WHERE c.nickname = '265149428061438717' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that are indirectly connected through loan deposit relationships, excluding direct connections, where the initial account has a specific last login time, and the final account is guaranteed by a person with a matching nickname."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel = '265149428061438717' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Collect the last login times of accounts that do not have a specific account level, ordered by last login time, up to 32 values."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Account_Repay_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either lack a medium sign-in relationship or have an account repay loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect email addresses of accounts that do not have an account withdraw relationship or have a person invest company relationship, ordered by email, up to 32 values."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Account) RETURN count(b.isBlocked) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of blocked and unblocked accounts using a union query."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.accountType LIMIT 20 RETURN b.accountType",
    "answer": [
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find account types of accounts indirectly connected through loan deposit relationships, excluding direct connections, ordered by account type, limited to 20 results."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 03:31:14.114",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Apply_Loan]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect blocked statuses of mediums that have applied for loans, ordered by blocked status, up to 32 values."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Medium) OR (n)-[:Account_Withdraw_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have a person guarantee relationship or have an account withdraw relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumType LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1861",
        "b": "Medium:884"
      },
      {
        "a": "Medium:386",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1897",
        "b": "Medium:884"
      },
      {
        "a": "Medium:680",
        "b": "Medium:884"
      },
      {
        "a": "Medium:20",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1983",
        "b": "Medium:884"
      },
      {
        "a": "Medium:249",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1551",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1728",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1718",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Match medium nodes, order them by their medium type, limit the result to 10, then for each of these, match other medium nodes, order them by creation time, limit to 10, and return both sets of medium nodes."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Find the count of unique pairs of medium nodes where the first node is not equal to the second, ordered by the last login time of the second node."
  },
  {
    "query": "MATCH (a:Medium {lastLoginTime: '57174604646198'})-[:Account_Withdraw_Account]->(b:Medium) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Medium) WHERE c.isBlocked = '57174604646198' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of transfers where a specific medium (with a given last login time) has withdrawn funds from another account and is involved in a transfer to a blocked medium."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel = '57174604646198' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of mediums that do not have a specific risk level."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType = '57174604646198' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the blocked statuses of mediums that do not have a specific medium type, ordered by their blocked status, up to 32 values."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Transfer_Account]->(:Medium) OR (a)-[:Company_Own_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of mediums that either do not have an outgoing account transfer relationship or have an incoming company own account relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Own_Account]->(:Medium) OR (a)-[:Person_Invest_Company]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect the medium types of mediums that either do not have an incoming company own account relationship or have an outgoing person invest company relationship, ordered by medium type, up to 32 values."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Medium) RETURN count(b.isBlocked) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Return the count of blocked and unblocked mediums using a union query."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.birthday) AS min_value",
    "answer": "1980-01-08",
    "is_noise_query": true,
    "nlp": "Find the earliest birthday among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Invest_Company]->(:Person) WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 genders of people who have invested in companies, ordered by gender."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Account_Transfer_Account]->(:Person) OR (n)-[:Medium_SignIn_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people who either do not have an account transfer relationship or have a medium sign-in relationship with another person."
  },
  {
    "query": "MATCH (a:Person)-[:Person_Guarantee_Person *1..4]-(b:Person) RETURN count(b) AS cnt",
    "answer": 6886,
    "is_noise_query": true,
    "nlp": "Count the number of distinct people within a guarantee relationship chain of up to four links."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personName LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.gender LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:28587302322284",
        "b": "Person:315"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:535"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:107"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:24"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:729"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:467"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:808"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:982"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:41"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:675"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 people ordered by name, then for each of those, find the top 10 people ordered by gender, and return both sets."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.gender RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Find the count of unique pairs of people where the first person's creation time is earlier than the second person's, and return the count ordered by the second person's gender."
  },
  {
    "query": "MATCH (a:Person {birthday: '8796093022346'})-[:Person_Apply_Loan]->(b:Person) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Person) WHERE c.isBlocked = '8796093022346' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the count of instances where a person with a specific birthday applies for a loan, and that person subsequently invests in a company owned by someone who is blocked."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.createTime ENDS WITH '8796093022346' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people whose creation time does not end with a specific value."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.birthday <> '8796093022346' WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 genders of people born on a specific date, ordered by gender."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Apply_Loan]->(:Person) OR (a)-[:Person_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of people who either do not apply for loans or own accounts."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Person) OR (a)-[:Loan_Deposit_Account]->(:Person) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [
      "Aachen",
      "Aachen",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Abidjan",
      "Addis_Ababa",
      "Agadir",
      "Agadir",
      "Ahmedabad",
      "Ahmedpur_Sial",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Ajmer",
      "Al_Hudaydah",
      "Alappuzha",
      "Alashankou",
      "Aligarh",
      "Aligarh",
      "Aligarh",
      "Allahabad",
      "Almaty",
      "Ambon",
      "Ambovombe",
      "Amparafaravola",
      "Amritsar",
      "Anand",
      "Anand",
      "Anantapur",
      "Anda",
      "Anda"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 cities of people who either have or do not have a loan deposit relationship, ordered by city."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountLevel) AS min_value",
    "answer": "Basic level",
    "is_noise_query": true,
    "nlp": "Return the lowest account level among all accounts based on alphabetical order."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the highest account level among all accounts based on alphabetical order."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the emails of accounts that have invested in companies, ordered by email, up to 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a medium sign-in relationship or have a company apply loan relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896538694858572073"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407894741"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835283081"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:285978576338027459",
        "b": "Account:4896820169835284218"
      }
    ],
    "is_noise_query": true,
    "nlp": "Match the top 10 accounts ordered by account type, then within each of these, match the top 10 accounts ordered by whether they are blocked, and return both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.nickname RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the count of unique account pairs where the second account's nickname is ordered, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4856850723142370521'})-[:Company_Guarantee_Company]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.freqLoginType = '4856850723142370521' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the number of accounts where a specific account with a given account level guarantees another account, and this guaranteed account invests in yet another account with a specific login frequency."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel CONTAINS '4856850723142370521' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have an account level containing the specified value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum = '4856850723142370521' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect the emails of accounts that do not have a specific phone number, ordered by email, up to 32 values."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a person invest company relationship or have an account transfer relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect account levels of accounts that either do not have a company-owned account relationship or do have such a relationship, ordered by account level, up to 32 values."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Account) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.email LIMIT 20 RETURN b.email",
    "answer": [
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "allhiphop.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find emails of accounts indirectly connected through medium sign-in relationships, excluding direct connections, ordered by email, limited to 20 results."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.companyName) AS min_value",
    "answer": "Abernathy PLC",
    "is_noise_query": true,
    "nlp": "Return the company name that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.business) AS max_value",
    "answer": "Youth Social Services Organization",
    "is_noise_query": true,
    "nlp": "Find the business type that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Account_Withdraw_Account]->(:Company) WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect business types of companies that have accounts that have been withdrawn, ordered by business type, up to 32 values."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Own_Account]->(:Company) OR (n)-[:Company_Own_Account]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a person-owned account relationship or have a company-owned account relationship."
  },
  {
    "query": "MATCH (a:Company)-[:Person_Invest_Company *2..4]-(b:Company) RETURN count(b) AS cnt",
    "answer": 680,
    "is_noise_query": true,
    "nlp": "Count companies within a specified range of two to four person-invested company relationships."
  },
  {
    "query": "MATCH p = (a:Company)-[:Person_Invest_Company *2..2]-(b:Company) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between companies through exactly two person-invested company relationships."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.companyId LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.url LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:178",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:192",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:93",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:100",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:23",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:180",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:29",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:64",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:43",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:237",
        "b": "Company:3298534883592"
      }
    ],
    "is_noise_query": true,
    "nlp": "Match the top 10 companies by ID, then for each of these, match the top 10 companies by URL, and return both sets."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.url RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Find the count of unique company pairs where the first company's business type is different from the second, ordered by the second company's URL."
  },
  {
    "query": "MATCH (a:Company {url: '1099511628000'})-[:Loan_Deposit_Account]->(b:Company) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Company) WHERE c.isBlocked = '1099511628000' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find relationships between a specific company with URL '1099511628000' and other companies through loan deposit and company investment connections, where the invested company is blocked with the same URL, and return the total count."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.country ENDS WITH '1099511628000' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that do not have their country name ending with '1099511628000'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.createTime = '1099511628000' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect blocked statuses of companies that do not have a specific creation time '1099511628000', ordered by whether they are blocked, up to 32 values."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Own_Account]->(:Company) OR (a)-[:Account_Withdraw_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a direct 'Company_Own_Account' relationship or have an 'Account_Withdraw_Account' relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Company) OR (a)-[:Person_Invest_Company]->(:Company) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-03 13:22:12.950",
      "2020-01-06 13:18:44.184",
      "2020-01-09 05:12:29.209",
      "2020-01-12 00:23:45.776",
      "2020-01-13 18:54:25.370",
      "2020-01-16 16:50:43.225",
      "2020-01-21 22:59:58.120",
      "2020-01-23 04:52:42.781",
      "2020-01-24 16:00:55.899",
      "2020-01-30 06:46:05.619",
      "2020-01-31 12:16:50.346",
      "2020-02-02 10:04:06.081",
      "2020-02-05 19:25:53.688",
      "2020-02-06 14:23:04.501",
      "2020-02-16 19:33:26.573",
      "2020-02-21 16:46:24.442",
      "2020-02-21 23:39:46.744",
      "2020-02-22 00:08:46.152",
      "2020-02-23 23:11:13.114",
      "2020-02-24 19:00:33.936",
      "2020-02-25 07:38:15.426",
      "2020-02-25 16:03:28.703",
      "2020-02-26 01:25:32.523",
      "2020-02-26 19:37:05.929",
      "2020-02-27 00:25:48.653",
      "2020-02-28 02:48:53.725",
      "2020-02-28 22:14:42.963",
      "2020-03-07 11:57:55.866",
      "2020-03-08 19:34:24.717",
      "2020-03-10 01:39:44.334",
      "2020-03-10 23:13:53.875",
      "2020-03-11 07:19:31.544"
    ],
    "is_noise_query": true,
    "nlp": "Collect creation times of companies that either do not have a 'Company_Guarantee_Company' relationship or have a 'Person_Invest_Company' relationship, ordered by creation time, up to 32 values."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.city) AS cnt UNION MATCH (b:Company) RETURN count(b.city) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Return the count of distinct city names among companies using a union query."
  },
  {
    "query": "MATCH (a:Company)-[:Company_Guarantee_Company]-()-[:Company_Guarantee_Company]-(b:Company) WHERE NOT (a)-[:Company_Guarantee_Company]-(b) WITH b ORDER BY b.description LIMIT 20 RETURN b.description",
    "answer": [
      {
        "b.description": "A cave, a stranger would have to overcome it because he feared his father now from the bed first, of course, moving it an inch. His father were of no help, for instance, whenever i go back to the window."
      },
      {
        "b.description": "A cave, a stranger would have to overcome it because he feared his father now from the bed first, of course, moving it an inch. His father were of no help, for instance, whenever i go back to the window."
      },
      {
        "b.description": "A cave, a stranger would have to overcome it because he feared his father now from the bed first, of course, moving it an inch. His father were of no help, for instance, whenever i go back to the window."
      },
      {
        "b.description": "A month earlier he had been living in it. That set his mother screaming anew, she brought him a little more slowly than them, louts, was still hurriedly thinking all this time, though, did not understand."
      },
      {
        "b.description": "A page to each of the other hand, he made it difficult to eat if his whole body against it. Gregor also refrained, this was so resentful of it. That' s mother had now fallen completely asleep. He was using."
      },
      {
        "b.description": "A page to each of the other hand, he made it difficult to eat if his whole body against it. Gregor also refrained, this was so resentful of it. That' s mother had now fallen completely asleep. He was using."
      },
      {
        "b.description": "A serious cold, which had probably been permanently set aside for emergencies; money to live off the interest; it was only ever thinks about the others. What shall we take now, he called to him, what is."
      },
      {
        "b.description": "A short while he told himself once more pursue their parents with the violin. Whenever they can. Perhaps only because her mother quite worried, that would have enough space to get gregor to open the window."
      },
      {
        "b.description": "A time. Gregor is ill. Quick, get the top part of the need to earn money? she had time to catch her breath, he felt as if he left most of all playing the violin went silent. What he was moreover unable."
      },
      {
        "b.description": "A time. The previous morning while his parents about the others? she was fully( in his back and sides; he had put her finger on her lips and made a sudden fear that mr. Samsa, he startled her when she reached."
      },
      {
        "b.description": "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march."
      },
      {
        "b.description": "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march."
      },
      {
        "b.description": "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march."
      },
      {
        "b.description": "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march."
      },
      {
        "b.description": "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march."
      },
      {
        "b.description": "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march."
      },
      {
        "b.description": "Again now, then. Let' s got to get dressed so quickly? there was someone at the same place, imagining the wildest possibilities, but that was the boss and told him just what i' m just getting out of the."
      },
      {
        "b.description": "Again straight away. Gregor slowly pushed his head kept nodding it could be seriously ill and he smiled sweetly. The cleaner came in on gregor and went over to the living room. The cleaner wanted to show."
      },
      {
        "b.description": "Again straight away. Gregor slowly pushed his head kept nodding it could be seriously ill and he smiled sweetly. The cleaner came in on gregor and went over to the living room. The cleaner wanted to show."
      },
      {
        "b.description": "Again straight away. Gregor slowly pushed his head kept nodding it could be seriously ill and he smiled sweetly. The cleaner came in on gregor and went over to the living room. The cleaner wanted to show."
      }
    ],
    "is_noise_query": true,
    "nlp": "Find descriptions of companies indirectly connected through 'Company_Guarantee_Company' relationships, excluding direct connections, ordered by description, limited to 20 results."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.email) AS min_value",
    "answer": "37.com",
    "is_noise_query": true,
    "nlp": "Return the email address that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2029-12-28 06:55:11.555",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the nicknames of accounts that have a 'Person_Own_Account' relationship with another account, ordered by nickname, limited to the first 32."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have an Account_Transfer_Account relationship or have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account *2..2]-(b:Account) RETURN count(b) AS cnt",
    "answer": 11678,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have exactly two Loan_Deposit_Account relationships with other accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:253327479039591558",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by email, then for each find the top 10 associated accounts ordered by freqLoginType."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of distinct accounts where the first is ordered by creation time and the second by last login time, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4895131319975019472'})-[:Company_Own_Account]->(b:Account) WITH b MATCH (b)-[:Person_Own_Account]->(c:Account) WHERE c.accountType = '4895131319975019472' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count related accounts where the initial account has a specific account level and its linked account has a specific account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime STARTS WITH '4895131319975019472' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 emails of accounts whose creation time does not start with a specific string, ordered by email."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have an Account_Transfer_Account relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 account levels of accounts that do not have a Company_Own_Account relationship or have an Account_Transfer_Account relationship, ordered by account level."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.createTime LIMIT 20 RETURN b.createTime",
    "answer": [
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the creation times of 20 accounts that have a complex Loan_Deposit_Account relationship but are not directly connected by this relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-15 09:39:18.811",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the highest frequency login type among all accounts, ordered alphabetically."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Guarantee_Company]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the blocked status of accounts that have a Company_Guarantee_Company relationship with another account, ordered by their blocked status, limited to the first 32 entries."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Invest_Company]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Company_Invest_Company relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:20266198323168013",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:20547673299879219",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:14918173765665963",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4631952216750555239",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4617596992938311786",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4632796641680687311",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by creation time, then for each of these, find the top 10 associated accounts ordered by their last login time."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of distinct accounts where the first account is ordered by nickname and the second by frequency login type, excluding pairs where both accounts are the same."
  },
  {
    "query": "MATCH (a:Account {isBlocked: '270778927595651520'})-[:Person_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Account) WHERE c.phonenum = '270778927595651520' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count related accounts where the initial account has a specific blocked status and is connected through a Person_Invest_Company relationship to another account which, in turn, has a Company_Guarantee_Company relationship with an account having a specific phone number."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime ENDS WITH '270778927595651520' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 emails of accounts whose creation time does not end with a specific string, ordered by email."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Invest_Company]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Company_Invest_Company relationship or have a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Return the creation times of accounts that do not have a Person_Own_Account relationship or have an Account_Repay_Loan relationship, ordered by creation time, limited to the first 32 entries."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountLevel) AS cnt UNION MATCH (b:Account) RETURN count(b.accountLevel) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Combine the counts of account levels from two separate sets of accounts."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-01-29 05:12:39.506",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2022-12-31 23:55:02.684",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Company_Apply_Loan]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 last login times of mediums that have a Company_Apply_Loan relationship, ordered by last login time."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Medium) OR (n)-[:Loan_Deposit_Account]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have an Account_Withdraw_Account relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.riskLevel LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:680",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1480",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1875",
        "b": "Medium:884"
      },
      {
        "a": "Medium:503",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1650",
        "b": "Medium:884"
      },
      {
        "a": "Medium:962",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1196",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1124",
        "b": "Medium:884"
      },
      {
        "a": "Medium:1297",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 mediums ordered by risk level, then for each find the top 10 associated mediums ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count unique pairs of distinct mediums where the first is ordered by last login time and the second by creation time, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Medium), (b:Medium) WHERE a.mediumType = b.mediumType AND a <> b RETURN count(*) AS cnt",
    "answer": 380978,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct mediums with the same medium type, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Medium {mediumType: '21990232557127'})-[:Account_Withdraw_Account]->(b:Medium) WITH b MATCH (b)-[:Company_Own_Account]->(c:Medium) WHERE c.createTime = '21990232557127' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count related mediums where the initial medium has a specific medium type ('21990232557127') and its linked medium has a specific creation time ('21990232557127')."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType CONTAINS '21990232557127' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 creation times of mediums whose medium type does not contain '21990232557127', ordered by creation time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Own_Account]->(:Medium) OR (a)-[:Person_Apply_Loan]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have a Company_Own_Account relationship or have a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Medium) OR (a)-[:Person_Guarantee_Person]->(:Medium) WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 risk levels of mediums that either do not have a Company_Guarantee_Company relationship or have a Person_Guarantee_Person relationship, ordered by risk level."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.balance) AS min_value",
    "answer": 61.51,
    "is_noise_query": true,
    "nlp": "Find the minimum balance among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanAmount) AS max_value",
    "answer": 99999435.0,
    "is_noise_query": true,
    "nlp": "Find the maximum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Invest_Company]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 loan amounts of loans that have a Person_Invest_Company relationship, ordered by loan amount."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Apply_Loan]->(:Loan) OR (n)-[:Company_Guarantee_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have a Person_Apply_Loan relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account *1..2]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 21118,
    "is_noise_query": true,
    "nlp": "Count loans that have one or two Loan_Deposit_Account relationships with other loans."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanUsage LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4701476535998088242"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4711891110136381993"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:79375943432405966"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:82472168176223460"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:70650219154375089"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:29836347531329650"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4663195939165439209"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:66146619527004485"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4658973814514778717"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:4714705859903489184"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 loans ordered by loan amount, then for each of those, find the top 10 associated loans ordered by loan usage."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.balance RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count unique pairs of loans where the first loan is ordered by interest rate and the second by balance, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.balance = b.balance AND a <> b RETURN count(*) AS cnt",
    "answer": 4,
    "is_noise_query": true,
    "nlp": "Count pairs of loans with the same balance, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Loan {loanAmount: '4776630354779832940'})-[:Account_Repay_Loan]->(b:Loan) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Loan) WHERE c.interestRate = '4776630354779832940' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count related loans where the initial loan has a specific loan amount and its linked loan has a specific interest rate."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime = '4776630354779832940' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 interest rates of loans whose creation time is not equal to '4776630354779832940', ordered by interest rate."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Account_Withdraw_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have a Person_Guarantee_Person relationship or have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Invest_Company]->(:Loan) OR (a)-[:Company_Invest_Company]->(:Loan) WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [
      61.51,
      62.37,
      111.44,
      201.44,
      263.89,
      562.45,
      769.15,
      971.05,
      1364.68,
      1474.58,
      1850.89,
      1859.25,
      2638.41,
      2741.97,
      2831.06,
      3021.97,
      3313.09,
      3690.54,
      3885.13,
      4801.41,
      5296.98,
      5491.24,
      8423.84,
      8930.37,
      9107.76,
      9378.97,
      9554.96,
      11339.17,
      11665.03,
      11785.13,
      12075.02,
      12430.63
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 balances of loans that do not have a Person_Invest_Company relationship or have a Company_Invest_Company relationship, ordered by balance."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.companyName) AS min_value",
    "answer": "Abernathy PLC",
    "is_noise_query": true,
    "nlp": "Return the company name that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Invest_Company]->(:Company) WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 URLs of companies that have a Person_Invest_Company relationship, ordered by URL."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Company) OR (n)-[:Person_Invest_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have an Account_Withdraw_Account relationship or have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.country LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:2199023256399",
        "b": "Company:23"
      },
      {
        "a": "Company:5497558139404",
        "b": "Company:23"
      },
      {
        "a": "Company:13194139533678",
        "b": "Company:23"
      },
      {
        "a": "Company:8796093022284",
        "b": "Company:23"
      },
      {
        "a": "Company:678",
        "b": "Company:23"
      },
      {
        "a": "Company:4398046511482",
        "b": "Company:23"
      },
      {
        "a": "Company:8796093022248",
        "b": "Company:23"
      },
      {
        "a": "Company:1099511628330",
        "b": "Company:23"
      },
      {
        "a": "Company:8796093022964",
        "b": "Company:23"
      },
      {
        "a": "Company:8796093022320",
        "b": "Company:23"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 companies ordered by country, then for each find the top 10 associated companies ordered by company ID."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.createTime MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.business RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count unique pairs of companies where the first is ordered by creation time and the second by business, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Company {description: '2199023255702'})-[:Company_Apply_Loan]->(b:Company) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Company) WHERE c.url = '2199023255702' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count related companies where the initial company has a description of '2199023255702' and its linked company has a URL of '2199023255702'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business = '2199023255702' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies whose business identifier is not \"2199023255702\"."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.description STARTS WITH '2199023255702' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 blocked statuses of companies whose description does not start with \"2199023255702\", ordered by whether they are blocked."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Repay_Loan]->(:Company) OR (a)-[:Company_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have an outgoing Account_Repay_Loan relationship or have an incoming Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Apply_Loan]->(:Company) OR (a)-[:Account_Repay_Loan]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 company names of companies that either do not have an incoming Person_Apply_Loan relationship or have an outgoing Account_Repay_Loan relationship, ordered by company name."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.email) AS min_value",
    "answer": "37.com",
    "is_noise_query": true,
    "nlp": "Return the earliest email address alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the most recent frequent login type alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 frequency login types of accounts that have an incoming Person_Own_Account relationship, ordered by frequency login type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have an incoming Company_Apply_Loan relationship or have an outgoing Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4671077238513337662",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4661507089305174028",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4672766088373601934",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:41095346599755900",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4644337115725825070",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:64176294690031206",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4662070039258597186",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4615626668101338845",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:45035996273706602",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by their last login time, then for each of these top 10 accounts, find the top 10 associated accounts ordered by email."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the count of unique pairs of distinct accounts where the first account is ordered by phone number and the second account is ordered by account type."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '223209656531551027'})-[:Person_Own_Account]->(b:Account) WITH b MATCH (b)-[:Person_Own_Account]->(c:Account) WHERE c.accountLevel = '223209656531551027' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have a specific account level '223209656531551027' and are connected through the 'Person_Own_Account' relationship in a two-hop path."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel = '223209656531551027' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the last login times of accounts that do not have the specific account level '223209656531551027', ordered by their last login time, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have outgoing 'Person_Own_Account' relationships or have outgoing 'Company_Guarantee_Company' relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect the phone numbers of accounts that do not have 'Medium_SignIn_Account' relationships but have 'Loan_Deposit_Account' relationships, ordered by phone number, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Repay_Loan]-()-[:Account_Repay_Loan]-(b:Account) WHERE NOT (a)-[:Account_Repay_Loan]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Check if there are any blocked accounts in a chain of 'Account_Repay_Loan' relationships, excluding direct connections, and return up to 20 non-blocked accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all accounts, which will be 1 if any account is blocked, as isBlocked is a boolean field."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect nicknames of accounts with 'Company_Own_Account' relationships, ordered by nickname, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Repay_Loan]->(:Account) OR (n)-[:Account_Repay_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count all accounts, regardless of 'Account_Repay_Loan' relationships. The current NLP accurately describes the query but could be more precise about the nature of the condition."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "Create pairs of accounts by first ordering accounts by phone number and limiting to the top 10, then further ordering these by frequency login type and limiting to the top 10 pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the count of unique pairs of accounts, ordered first by creation time of the first account, then by account type of the second account."
  },
  {
    "query": "MATCH (a:Account {isBlocked: '260082878480648308'})-[:Person_Own_Account]->(b:Account) WITH b MATCH (b)-[:Person_Own_Account]->(c:Account) WHERE c.createTime = '260082878480648308' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts where the specified 'isBlocked' account is the owner and those accounts have at least one additional 'Person_Own_Account' relationship with another account whose creation time matches the given timestamp."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname = '260082878480648308' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Retrieve the count of accounts that do not have the specified nickname."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime STARTS WITH '260082878480648308' WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Return the phone numbers of accounts where the last login time does not start with the specified string, ordered by phone number, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have 'Loan_Deposit_Account' relationships or do have 'Person_Own_Account' relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect phone numbers of accounts that do not have 'Medium_SignIn_Account' relationships but do have 'Person_Own_Account' relationships, ordered by phone number, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.nickname) AS max_value",
    "answer": "Zulma Dixey",
    "is_noise_query": true,
    "nlp": "Find the nickname that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect emails of accounts that have 'Person_Own_Account' relationships, ordered by email, and return the first 32 values."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Own_Account]->(:Account) OR (n)-[:Loan_Deposit_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count all accounts, regardless of 'Person_Own_Account' relationships."
  },
  {
    "query": "MATCH p = (a:Account)-[:Medium_SignIn_Account *2..5]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.926683199217228,
    "is_noise_query": true,
    "nlp": "Find the average length of paths between two accounts involving 2 to 5 'Medium_SignIn_Account' relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.email LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896820169835282970",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284135",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407894843",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407895618",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285134151407895701",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835282675",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835284218",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:4896820169835283571",
        "b": "Account:253327479039591558"
      },
      {
        "a": "Account:285415626384607208",
        "b": "Account:253327479039591558"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts with the highest account levels and then find the top 10 accounts with the lowest email values among them, returning these 10 pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of accounts where the phone number is ordered first and then by email."
  },
  {
    "query": "MATCH (a:Account {phonenum: '4885842645743567017'})-[:Company_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Account) WHERE c.createTime = '4885842645743567017' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Retrieve the count of accounts where an account with the specified phone number applies for a loan and is further involved in investing in another company with a matching creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountType ENDS WITH '4885842645743567017' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that do not end with a specific account type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime STARTS WITH '4885842645743567017' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [
      "37.com",
      "allhiphop.com",
      "allhiphop.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "anjungcafe.com",
      "archaeologist.com",
      "archaeologist.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "asiancutes.com",
      "autopm.com",
      "autopm.com",
      "autopm.com",
      "banha.cc",
      "banha.cc",
      "bgay.com",
      "bgay.com",
      "blackvault.com",
      "blackvault.com",
      "certifiedbitches.com",
      "clerk.com",
      "clerk.com",
      "coolmail.ru",
      "darkforces.com",
      "darkforces.com",
      "deliveryman.com",
      "deliveryman.com",
      "diplomats.com",
      "diplomats.com"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 email addresses of accounts with phone numbers not starting with a specific value, ordered by email, and return these emails."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have 'Person_Own_Account' relationships or have 'Person_Guarantee_Person' relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Own_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 nicknames of accounts that do not have 'Company_Own_Account' relationships or have 'Loan_Deposit_Account' relationships, ordered by nickname, and return these nicknames."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.url) AS min_value",
    "answer": "https://www.abeampedestalled.com",
    "is_noise_query": true,
    "nlp": "Return the URL that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Invest_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 918,
    "is_noise_query": true,
    "nlp": "Count the number of companies that have outgoing 'Company_Invest_Company' relationships."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Guarantee_Person]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Count the number of companies that are guaranteed by another company through the 'Person_Guarantee_Person' relationship, and return the first 32 company names, sorted by name."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Company) OR (n)-[:Company_Own_Account]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that either do not have 'Person_Guarantee_Person' relationships or have 'Company_Own_Account' relationships."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.city LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:9895604650966",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:2199023256395",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:2199023255701",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:1099511628516",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093022277",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093023206",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:8796093023099",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:14293651161100",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:13194139534055",
        "b": "Company:4398046511515"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of companies where the first ten are ordered by city and the second ten are ordered by company name from each of those ten, with both sets limited to ten results."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.createTime MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.companyName RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of unique company pairs where the companies are different and ordered by creation time, then by company name, returning the total count of such pairs."
  },
  {
    "query": "MATCH (a:Company {description: '7696581395139'})-[:Loan_Deposit_Account]->(b:Company) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Company) WHERE c.description = '7696581395139' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of times a specific company (with a given description) is involved in 'Loan_Deposit_Account' relationships leading to other companies that apply for loans from the same specific company."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business CONTAINS '7696581395139' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies whose business description does not contain '7696581395139'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.country <> '7696581395139' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the creation times of companies located in '7696581395139', ordered by creation time, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Company) OR (a)-[:Company_Invest_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that either do not have 'Account_Withdraw_Account' relationships or have 'Company_Invest_Company' relationships."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Company) OR (a)-[:Account_Withdraw_Account]->(:Company) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS vals",
    "answer": [
      "Aachen",
      "Aachen",
      "Aachen",
      "Abbottabad",
      "Abidjan",
      "Abidjan",
      "Agadez",
      "Agadez",
      "Agra",
      "Agra",
      "Ahmedpur_Sial",
      "Ahmedpur_Sial",
      "Aix-en-Provence",
      "Aizawl",
      "Akita_City",
      "Aktobe",
      "Aktobe",
      "Alappuzha",
      "Alashankou",
      "Algiers",
      "Allahabad",
      "Almaty",
      "Almaty",
      "Altamira",
      "Ambon",
      "Ambovombe",
      "Ambovombe",
      "Amman",
      "Amparafaravola",
      "Amsterdam",
      "Anand",
      "Anantapur"
    ],
    "is_noise_query": true,
    "nlp": "Collect the cities of companies that do not have 'Person_Guarantee_Person' relationships but do have 'Account_Withdraw_Account' relationships, ordered by city, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.createTime) AS cnt UNION MATCH (b:Company) RETURN count(b.createTime) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Create pairs of companies, ordered by creation time, returning the count of each pair."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.gender) AS min_value",
    "answer": "female",
    "is_noise_query": true,
    "nlp": "Return the gender that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Company_Invest_Company]->(:Person) WITH a ORDER BY a.city RETURN collect(a.city)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the top 32 cities of persons that have a 'Company_Invest_Company' relationship with another person, ordered by city."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Account_Transfer_Account]->(:Person) OR (n)-[:Company_Invest_Company]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons that either do not have 'Account_Transfer_Account' relationships or have 'Company_Invest_Company' relationships."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.personName LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.birthday LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:17592186045162",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:17592186045368",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:15393162789164",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:2199023255803",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:28587302322699",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:28587302322284",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:15393162789558",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:13194139533389",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:630",
        "b": "Person:6597069766722"
      },
      {
        "a": "Person:24189255811260",
        "b": "Person:6597069766722"
      }
    ],
    "is_noise_query": true,
    "nlp": "Count the number of persons that either do not have 'Person_Apply_Loan' relationships or have 'Company_Own_Account' relationships."
  },
  {
    "query": "MATCH (a:Person), (b:Person) WHERE a.personName = b.city AND a <> b WITH a, b ORDER BY a.personName, b.city LIMIT 32 RETURN a, b",
    "answer": [
      {
        "a": "Person:26388279066852",
        "b": "Person:21990232555698"
      }
    ],
    "is_noise_query": true,
    "nlp": "Collect creation times of persons where their name matches another person's city, ordered by person name and city, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Find the number of unique pairs of persons where the second person is not blocked, ordered by creation time and block status."
  },
  {
    "query": "MATCH (a:Person {gender: '19791209300478'})-[:Company_Guarantee_Company]->(b:Person) WITH b MATCH (b)-[:Account_Repay_Loan]->(c:Person) WHERE c.birthday = '19791209300478' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Determine the count of persons who are guaranteed by a specific person and have repaid loans to another person with a specific birthday."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.city ENDS WITH '19791209300478' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-02 18:57:28.118",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:25:56.241",
      "2020-01-07 13:56:26.822",
      "2020-01-08 17:20:47.273",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-15 02:21:44.159",
      "2020-01-17 03:32:50.477",
      "2020-01-17 04:09:18.151",
      "2020-01-18 02:21:52.659",
      "2020-01-18 10:05:44.091",
      "2020-01-18 16:55:05.001",
      "2020-01-19 10:56:59.136",
      "2020-01-20 05:33:17.058",
      "2020-01-20 17:48:55.822",
      "2020-01-21 03:48:32.939",
      "2020-01-21 22:35:52.862",
      "2020-01-22 11:03:11.491",
      "2020-01-25 22:59:08.892",
      "2020-01-27 21:05:33.077",
      "2020-01-29 12:02:40.132",
      "2020-01-30 04:26:35.762",
      "2020-02-01 04:09:52.198",
      "2020-02-02 13:54:29.833",
      "2020-02-02 22:17:38.684",
      "2020-02-04 00:31:40.881",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904"
    ],
    "is_noise_query": true,
    "nlp": "Collect creation times of persons whose city does not end with '19791209300478', ordered by creation time, and return the first 32 values."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Apply_Loan]->(:Person) OR (a)-[:Company_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count all people who either do not have outgoing Person_Apply_Loan relationships or have incoming Company_Own_Account relationships."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Person) OR (a)-[:Company_Guarantee_Company]->(:Person) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 18:13:47.158",
      "2020-01-03 04:37:41.401",
      "2020-01-07 13:56:26.822",
      "2020-01-09 03:57:02.637",
      "2020-01-09 09:54:36.654",
      "2020-01-12 20:52:02.831",
      "2020-01-13 11:31:04.635",
      "2020-01-17 04:09:18.151",
      "2020-01-20 05:33:17.058",
      "2020-01-25 22:59:08.892",
      "2020-01-29 12:02:40.132",
      "2020-02-02 13:54:29.833",
      "2020-02-04 01:55:53.000",
      "2020-02-04 22:36:12.904",
      "2020-02-09 06:34:27.731",
      "2020-02-11 17:15:46.943",
      "2020-02-14 18:01:24.105",
      "2020-02-16 21:06:02.850",
      "2020-02-17 05:50:30.270",
      "2020-02-21 03:55:26.026",
      "2020-02-24 05:58:07.340",
      "2020-02-25 23:29:54.020",
      "2020-02-26 06:47:10.448",
      "2020-02-27 02:17:11.443",
      "2020-02-29 05:21:11.391",
      "2020-03-01 04:50:25.192",
      "2020-03-02 11:32:10.709",
      "2020-03-02 13:28:33.084",
      "2020-03-03 17:22:26.472",
      "2020-03-05 20:53:24.508",
      "2020-03-06 21:56:55.404",
      "2020-03-07 17:54:47.318"
    ],
    "is_noise_query": true,
    "nlp": "Create a list of up to 32 creation times for people, ordered by their creation time, regardless of whether they have 'Person_Guarantee_Person' or 'Company_Guarantee_Company' relationships."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum value of the 'isBlocked' property among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.companyName) AS max_value",
    "answer": "Zulauf LLC",
    "is_noise_query": true,
    "nlp": "Find the company name that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Guarantee_Person]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 company names, ordered alphabetically, where the company has a 'Person_Guarantee_Person' relationship to another company."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Own_Account]->(:Company) OR (n)-[:Person_Invest_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count all companies that either do not have outgoing 'Person_Own_Account' relationships or have incoming 'Person_Invest_Company' relationships."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.url LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:10995116278646",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:3298534883452",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:1099511628698",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:12094627906048",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:12094627906439",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:961",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:8796093022808",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:2199023255941",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:13194139534270",
        "b": "Company:3298534883592"
      },
      {
        "a": "Company:790",
        "b": "Company:3298534883592"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return pairs of companies where the first ten are ordered by business and the second ten are ordered by URL, without specifying the nature of the relationship between the pairs."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.url MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.business RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of unique company pairs (a, b) where a and b are different, ordered by a's URL and then by b's business."
  },
  {
    "query": "MATCH (a:Company {description: '12094627905746'})-[:Company_Invest_Company]->(b:Company) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Company) WHERE c.country = '12094627905746' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the total count of companies related through 'Account_Transfer_Account' to companies invested by a specific company with a given description, where the related companies are located in a specified country."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.city STARTS WITH '12094627905746' WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Angola",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Azerbaijan"
    ],
    "is_noise_query": true,
    "nlp": "Find the first 32 countries of companies whose city does not start with a specific code, ordered by country."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Invest_Company]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 50,
    "is_noise_query": true,
    "nlp": "Count companies that do not have outgoing relationships of type \"Company_Invest_Company\" or have incoming relationships of type \"Person_Own_Account\"."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Own_Account]->(:Company) OR (a)-[:Company_Invest_Company]->(:Company) WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS vals",
    "answer": [
      "https://www.abeampedestalled.com",
      "https://www.abeamspray.io",
      "https://www.abeddishonors.net",
      "https://www.ablyrechristens.io",
      "https://www.abroachthack.edu",
      "https://www.activelyveers.info",
      "https://www.adriftlob.io",
      "https://www.afielddarn.org",
      "https://www.afirewaff.net",
      "https://www.aflutterschlepp.org",
      "https://www.aforetimerecrudesce.com",
      "https://www.aftblent.edu",
      "https://www.againknead.net",
      "https://www.agapedome.io",
      "https://www.agapeflavours.info",
      "https://www.agoneligatures.info",
      "https://www.aheadstore.io",
      "https://www.airilybask.edu",
      "https://www.aleetwins.gov",
      "https://www.allchaperons.org",
      "https://www.alldisputing.io",
      "https://www.aloftequalise.edu",
      "https://www.alongshorebreakwaters.net",
      "https://www.aloudreworks.org",
      "https://www.alsoescalades.io",
      "https://www.alsojee.edu",
      "https://www.alsovacations.gov",
      "https://www.alwaysingest.com",
      "https://www.alwayspouches.com",
      "https://www.alwaysredescend.com",
      "https://www.aneardignify.net",
      "https://www.anesblub.edu"
    ],
    "is_noise_query": true,
    "nlp": "Collect URLs of companies that either do not own accounts or invest in other companies, and return the first 32 URLs sorted by company URL."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.birthday) AS min_value",
    "answer": "1980-01-08",
    "is_noise_query": true,
    "nlp": "Find the earliest birthday among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.gender) AS max_value",
    "answer": "male",
    "is_noise_query": true,
    "nlp": "Find the gender that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Account_Withdraw_Account]->(:Person) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect countries of people who have withdrawn accounts from others, and return the first 32 countries sorted by the person's country."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Person) OR (n)-[:Person_Guarantee_Person]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people who either do not withdraw accounts from others or guarantee relationships with other people."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.gender LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.city LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:24",
        "b": "Person:13194139533667"
      },
      {
        "a": "Person:729",
        "b": "Person:13194139533667"
      },
      {
        "a": "Person:107",
        "b": "Person:26388279067387"
      },
      {
        "a": "Person:535",
        "b": "Person:13194139533667"
      },
      {
        "a": "Person:315",
        "b": "Person:26388279067387"
      },
      {
        "a": "Person:24",
        "b": "Person:26388279067387"
      },
      {
        "a": "Person:535",
        "b": "Person:26388279067387"
      },
      {
        "a": "Person:107",
        "b": "Person:13194139533667"
      },
      {
        "a": "Person:315",
        "b": "Person:13194139533667"
      },
      {
        "a": "Person:729",
        "b": "Person:26388279067387"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return ten people ordered by gender, and for each of these, return ten additional people ordered by city."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.city MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.city RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct people, where each pair is ordered by their city."
  },
  {
    "query": "MATCH (a:Person {createTime: '4398046511890'})-[:Account_Withdraw_Account]->(b:Person) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Person) WHERE c.birthday = '4398046511890' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where a person, created at a specific timestamp, withdraws an account and then guarantees another person who was born on the same timestamp."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country = '4398046511890' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the blocked status of people who are not from a specific country, and return the first 32 blocked statuses sorted by the person's blocked status."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Person) OR (a)-[:Person_Own_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count people who do not have a Company Guarantee relationship with any person or own an account."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Person_Invest_Company]->(:Person) OR (a)-[:Person_Own_Account]->(:Person) WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS vals",
    "answer": [
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female",
      "female"
    ],
    "is_noise_query": true,
    "nlp": "Collect genders of people who either do not invest in companies or own accounts, ordered by gender and limited to the top 32 results."
  },
  {
    "query": "MATCH (a:Person) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Person) RETURN count(b.isBlocked) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Union count of people where `isBlocked` is true from two separate matches."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.nickname) AS min_value",
    "answer": "Aaron Nutting",
    "is_noise_query": true,
    "nlp": "Return the nickname that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.nickname) AS max_value",
    "answer": "Zulma Dixey",
    "is_noise_query": true,
    "nlp": "Find the nickname that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Own_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect account levels of accounts owned by other people, ordered by account level and limited to the top 32 results."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Own_Account]->(:Account) OR (n)-[:Account_Transfer_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not own company accounts or are involved in account transfers."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account *2..3]-(b:Account) RETURN count(b) AS cnt",
    "answer": 26076,
    "is_noise_query": true,
    "nlp": "Count accounts signed in through a medium that involves between 2 to 3 steps."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896820169835283571"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285134151407895618"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896820169835282675"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896820169835284218"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285415626384607208"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return ten accounts ordered by login frequency type, and for each of these, return ten accounts ordered by account level."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where one is blocked and the other is not, ordered by the last login time of the non-blocked account."
  },
  {
    "query": "MATCH (a:Account {isBlocked: '4687965737115975738'})-[:Company_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Person_Own_Account]->(c:Account) WHERE c.accountType = '4687965737115975738' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where a blocked account applies for a loan and the resulting loan is owned by an account of the same type."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime STARTS WITH '4687965737115975738' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Collect account types of accounts that have not logged in at a specific time, ordered by account type, and limit the results to the top 32."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not own other accounts or invest in companies."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect account levels of accounts that do not guarantee other companies or have loan deposits, ordered by account level, and limit the results to the top 32."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.nickname) AS cnt UNION MATCH (b:Account) RETURN count(b.nickname) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Union count of unique nicknames from two separate sets of accounts."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.balance) AS total_value",
    "answer": 59302232892.69993,
    "is_noise_query": true,
    "nlp": "Sum balances of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanUsage) AS min_value",
    "answer": "business ventures",
    "is_noise_query": true,
    "nlp": "Return the lexicographically smallest loan usage among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.interestRate) AS max_value",
    "answer": 0.1,
    "is_noise_query": true,
    "nlp": "Find the maximum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Account_Withdraw_Account]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect loan usages of loans that have been withdrawn from other accounts, ordered by loan usage, and limit the results to the top 32."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Loan) OR (n)-[:Person_Guarantee_Person]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that do not withdraw from other accounts or guarantee other persons."
  },
  {
    "query": "MATCH (a:Loan)-[:Account_Repay_Loan *1..5]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 109282,
    "is_noise_query": true,
    "nlp": "Count loans that can be reached within 1 to 5 repayment steps."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanId LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:29836347531329650",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:37436171902517700",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:23643898043696390",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:27584547717644754",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:27303072740934442",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:34058472181990599",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:19140298416325639",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:17169973579351110",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:12666373951980233",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:37436171902518055",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the top 10 loans ordered by ID from the first match, then for each of those, return the top 10 loans ordered by ID from the second match."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.loanAmount RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans where the first loan is ordered by creation time and the second loan is ordered by loan amount."
  },
  {
    "query": "MATCH (a:Loan {loanUsage: '4894005420068177122'})-[:Company_Own_Account]->(b:Loan) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Loan) WHERE c.loanUsage = '4894005420068177122' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count loans where a company-owned account is also signed in through a medium with the same usage code."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.createTime = '4894005420068177122' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that were not created at the specific timestamp '4894005420068177122'."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.interestRate = '4894005420068177122' WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Collect the top 32 loan amounts of loans with interest rates not equal to '4894005420068177122', ordered by loan amount."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Apply_Loan]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either do not have a person applying for them or are owned by a person, indicating they are not personal loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Account_Transfer_Account]->(:Loan) OR (a)-[:Person_Invest_Company]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Collect the creation times of the top 32 loans that do not involve account transfers or investments, ordered by creation time."
  },
  {
    "query": "MATCH (a:Loan)-[:Company_Apply_Loan]-()-[:Company_Apply_Loan]-(b:Loan) WHERE NOT (a)-[:Company_Apply_Loan]-(b) WITH b ORDER BY b.loanAmount LIMIT 20 RETURN b.loanAmount",
    "answer": [
      {
        "b.loanAmount": 88778.0
      },
      {
        "b.loanAmount": 88778.0
      },
      {
        "b.loanAmount": 88778.0
      },
      {
        "b.loanAmount": 156301.0
      },
      {
        "b.loanAmount": 166473.0
      },
      {
        "b.loanAmount": 166473.0
      },
      {
        "b.loanAmount": 166473.0
      },
      {
        "b.loanAmount": 251290.0
      },
      {
        "b.loanAmount": 312267.0
      },
      {
        "b.loanAmount": 312267.0
      },
      {
        "b.loanAmount": 312267.0
      },
      {
        "b.loanAmount": 355342.0
      },
      {
        "b.loanAmount": 363826.0
      },
      {
        "b.loanAmount": 363826.0
      },
      {
        "b.loanAmount": 456276.0
      },
      {
        "b.loanAmount": 456276.0
      },
      {
        "b.loanAmount": 456276.0
      },
      {
        "b.loanAmount": 567068.0
      },
      {
        "b.loanAmount": 627637.0
      },
      {
        "b.loanAmount": 627637.0
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the loan amounts of the top 20 loans where the application path does not directly connect two loans, ordered by loan amount."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.business) AS min_value",
    "answer": "Abortion Clinic",
    "is_noise_query": true,
    "nlp": "Return the business code that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.country) AS max_value",
    "answer": "Zambia",
    "is_noise_query": true,
    "nlp": "Find the country that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Apply_Loan]->(:Company) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the first 32 creation times of companies that have either received a loan application or are part of a company's network, ordered by their creation time."
  },
  {
    "query": "MATCH (n:Company) WHERE (n)-[:Company_Guarantee_Company]->(:Company) OR (n)-[:Company_Own_Account]->(:Company) RETURN count(n) AS cnt",
    "answer": 473,
    "is_noise_query": true,
    "nlp": "Count companies that either guarantee another company or own an account."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Company) OR (n)-[:Company_Apply_Loan]->(:Company) RETURN count(n)",
    "answer": 495,
    "is_noise_query": true,
    "nlp": "Count companies that either do not guarantee another company or apply for a loan."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.companyId LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:23",
        "b": "Company:538"
      },
      {
        "a": "Company:23",
        "b": "Company:237"
      },
      {
        "a": "Company:23",
        "b": "Company:641"
      },
      {
        "a": "Company:23",
        "b": "Company:599"
      },
      {
        "a": "Company:23",
        "b": "Company:595"
      },
      {
        "a": "Company:23",
        "b": "Company:43"
      },
      {
        "a": "Company:23",
        "b": "Company:344"
      },
      {
        "a": "Company:23",
        "b": "Company:584"
      },
      {
        "a": "Company:23",
        "b": "Company:807"
      },
      {
        "a": "Company:23",
        "b": "Company:423"
      }
    ],
    "is_noise_query": true,
    "nlp": "This query is unclear and does not accurately represent the Cypher query provided. The correct NLP should be: Return the first 10 companies ordered by their company ID, then for each of these, return the first 10 companies they are associated with, ordered by whether they are blocked, and finally return both sets of companies."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.business MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.url RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count the number of companies that are either involved in a guarantee relationship or own an account."
  },
  {
    "query": "MATCH (a:Company {city: '12094627906450'})-[:Account_Repay_Loan]->(b:Company) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Company) WHERE c.business = '12094627906450' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of unique company pairs where the first company is not the same as the second, ordered by their business and URL, and return the count of such pairs."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.city = '12094627906450' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that repay loans to another company located in '12094627906450' and subsequently invest in another company with the business '12094627906450'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.createTime STARTS WITH '12094627906450' WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [
      "Abortion Clinic",
      "Accountant",
      "Accounting Firm",
      "Accounting School",
      "Acoustical Consultant",
      "Acrobatic Diving Pool",
      "Aerobics Instructor",
      "Afghani Restaurant",
      "Aggregate Supplier",
      "Agricultural Association",
      "Aikido School",
      "Air Compressor Supplier",
      "Air Conditioning Repair Service",
      "Air Conditioning Store",
      "Airbrushing Service",
      "Aircraft Rental Service",
      "Airline",
      "Airline",
      "Alcohol Manufacturer",
      "Alcohol Retail Monopoly",
      "Alcoholism Treatment Program",
      "Alternator Supplier",
      "Aluminum Window",
      "Ambulance Service",
      "Amusement Center",
      "Amusement Ride Supplier",
      "Andalusian Restaurant",
      "Anesthesiologist",
      "Anglican Church",
      "Animation Studio",
      "Apartment Building",
      "Apartment Building"
    ],
    "is_noise_query": true,
    "nlp": "Count the number of companies that are not located in '12094627906450'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Company) OR (a)-[:Company_Invest_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Collect the business types of companies whose creation time does not start with '12094627906450', ordered by their business type, and limit the results to the top 32."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Company) OR (a)-[:Person_Invest_Company]->(:Company) WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS vals",
    "answer": [
      "https://www.abeampedestalled.com",
      "https://www.abeamspray.io",
      "https://www.abeddishonors.net",
      "https://www.ablyrechristens.io",
      "https://www.abroachthack.edu",
      "https://www.activelyveers.info",
      "https://www.adriftlob.io",
      "https://www.afielddarn.org",
      "https://www.afirewaff.net",
      "https://www.aflutterschlepp.org",
      "https://www.aforetimerecrudesce.com",
      "https://www.aftblent.edu",
      "https://www.againknead.net",
      "https://www.agapedome.io",
      "https://www.agapeflavours.info",
      "https://www.agoneligatures.info",
      "https://www.aheadstore.io",
      "https://www.airilybask.edu",
      "https://www.aleetwins.gov",
      "https://www.allchaperons.org",
      "https://www.alldisputing.io",
      "https://www.aloftequalise.edu",
      "https://www.alongshorebreakwaters.net",
      "https://www.aloudreworks.org",
      "https://www.alsoescalades.io",
      "https://www.alsojee.edu",
      "https://www.alsovacations.gov",
      "https://www.alwaysingest.com",
      "https://www.alwayspouches.com",
      "https://www.alwaysredescend.com",
      "https://www.aneardignify.net",
      "https://www.anesblub.edu"
    ],
    "is_noise_query": true,
    "nlp": "Find companies that do not have any outgoing Loan_Deposit_Account relationships or have incoming Person_Invest_Company relationships, then order by company URL and return the first 32 URLs."
  },
  {
    "query": "MATCH (a:Company)-[:Person_Invest_Company]-()-[:Person_Invest_Company]-(b:Company) WHERE NOT (a)-[:Person_Invest_Company]-(b) WITH b ORDER BY b.country LIMIT 20 RETURN b.country",
    "answer": [
      {
        "b.country": "Algeria"
      },
      {
        "b.country": "Algeria"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "China"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      },
      {
        "b.country": "Cuba"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find companies that are connected through two Person_Invest_Company relationships but are not directly connected, then order by country and return the countries of the top 20 such companies."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.loanAmount) AS total_value",
    "answer": 112187006902.0,
    "is_noise_query": true,
    "nlp": "Return the total value of all loan amounts."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.createTime) AS min_value",
    "answer": "2020-02-15 04:08:32.798",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.interestRate) AS max_value",
    "answer": 0.1,
    "is_noise_query": true,
    "nlp": "Find the maximum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Account_Withdraw_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect interest rates of loans that have an Account_Withdraw_Account relationship, order by interest rate, and return the top 32 values."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Company_Apply_Loan]->(:Loan) OR (n)-[:Account_Repay_Loan]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that do not have a Company_Apply_Loan relationship but have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanId LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:283445301547631063",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4734690583249944819",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4823355200913801910",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:249386829365641434",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4807311127241294042",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:223772606484971763",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:246572079598535350",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:188306759419429567",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:248260929458799829",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "This query finds the top 10 loans by loan amount and then for each of those loans, finds the top 10 loans by loan ID, returning both sets of loans."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanUsage MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans where the second loan's interest rate is higher than the first, after ordering by loan usage."
  },
  {
    "query": "MATCH (a:Loan), (b:Loan) WHERE a.loanUsage = b.loanUsage AND a <> b RETURN count(*) AS cnt",
    "answer": 480418,
    "is_noise_query": true,
    "nlp": "Counts pairs of loans with the same usage but different nodes."
  },
  {
    "query": "MATCH (a:Loan {loanUsage: '298082000336584999'})-[:Account_Repay_Loan]->(b:Loan) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Loan) WHERE c.balance = '298082000336584999' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts loans that have both an account repayment relationship leading to another loan and a person application relationship originating from that loan, where the second loan has the same balance as the initial loan."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance <> '298082000336584999' WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 balances from loans where the balance equals '298082000336584999', ordered by balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Counts loans that either do not have a person guarantee relationship or have a person own account relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Loan) OR (a)-[:Loan_Deposit_Account]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 creation times from loans that either do not have a person guarantee relationship or have a loan deposit account relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Loan)-[:Company_Apply_Loan]-()-[:Company_Apply_Loan]-(b:Loan) WHERE NOT (a)-[:Company_Apply_Loan]-(b) WITH b ORDER BY b.createTime LIMIT 20 RETURN b.createTime",
    "answer": [
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-02-15 04:08:32.798"
      },
      {
        "b.createTime": "2020-03-25 21:38:48.861"
      },
      {
        "b.createTime": "2020-03-25 21:38:48.861"
      },
      {
        "b.createTime": "2020-04-08 01:40:31.404"
      },
      {
        "b.createTime": "2020-04-08 09:26:17.655"
      },
      {
        "b.createTime": "2020-04-08 09:26:17.655"
      },
      {
        "b.createTime": "2020-04-08 09:26:17.655"
      },
      {
        "b.createTime": "2020-05-01 04:43:56.658"
      },
      {
        "b.createTime": "2020-05-13 23:09:16.040"
      },
      {
        "b.createTime": "2020-05-13 23:09:16.040"
      },
      {
        "b.createTime": "2020-05-18 06:30:40.531"
      },
      {
        "b.createTime": "2020-05-18 06:30:40.531"
      },
      {
        "b.createTime": "2020-05-27 10:04:16.571"
      },
      {
        "b.createTime": "2020-05-27 10:04:16.571"
      },
      {
        "b.createTime": "2020-05-27 10:04:16.571"
      },
      {
        "b.createTime": "2020-05-31 10:52:56.713"
      },
      {
        "b.createTime": "2020-05-31 10:52:56.713"
      },
      {
        "b.createTime": "2020-05-31 10:52:56.713"
      }
    ],
    "is_noise_query": true,
    "nlp": "Lists up to 20 creation times from loans that have a company apply loan relationship with other loans, excluding direct relationships between the same loans."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.gender) AS min_value",
    "answer": "female",
    "is_noise_query": true,
    "nlp": "Returns the gender that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.gender) AS max_value",
    "answer": "male",
    "is_noise_query": true,
    "nlp": "Finds the gender that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Person_Apply_Loan]->(:Person) WITH a ORDER BY a.gender RETURN collect(a.gender)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 genders from persons who have applied for loans, ordered by gender."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Apply_Loan]->(:Person) OR (n)-[:Account_Withdraw_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts persons who either do not apply for loans or have an account withdrawal relationship."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.gender LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.country LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:535",
        "b": "Person:24189255811977"
      },
      {
        "a": "Person:315",
        "b": "Person:24189255811977"
      },
      {
        "a": "Person:535",
        "b": "Person:13194139533426"
      },
      {
        "a": "Person:535",
        "b": "Person:21990232555896"
      },
      {
        "a": "Person:315",
        "b": "Person:13194139533426"
      },
      {
        "a": "Person:315",
        "b": "Person:17592186044635"
      },
      {
        "a": "Person:315",
        "b": "Person:21990232555896"
      },
      {
        "a": "Person:315",
        "b": "Person:26388279066767"
      },
      {
        "a": "Person:535",
        "b": "Person:17592186044635"
      },
      {
        "a": "Person:535",
        "b": "Person:26388279066767"
      }
    ],
    "is_noise_query": true,
    "nlp": "Matches ten people based on gender and then, for each of those ten, matches ten more people based on country, returning pairs of people."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.country MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.country RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Counts unique pairs of people from different countries, excluding self-pairing, ordered by country."
  },
  {
    "query": "MATCH (a:Person), (b:Person) WHERE a.personName = b.city AND a <> b WITH a, b ORDER BY b.isBlocked RETURN a, collect(b.isBlocked)[0..32] AS bs",
    "answer": [
      {
        "a": {
          "birthday": "1990-03-26",
          "personName": "Santos",
          "country": "Brazil",
          "gender": "female",
          "createTime": "2022-07-26 05:07:04.062",
          "city": "Lavras",
          "isBlocked": false,
          "personId": 26388279066852,
          "_node_id": "Person:26388279066852"
        },
        "bs": [
          false
        ]
      }
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 blocked statuses of persons whose name matches their city, ordered by whether they are blocked."
  },
  {
    "query": "MATCH (a:Person {createTime: '10995116277957'})-[:Account_Repay_Loan]->(b:Person) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Person) WHERE c.personName = '10995116277957' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts instances where a person who repays a loan also applies for a loan with the same name as the repayment's creation time."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.personName STARTS WITH '10995116277957' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts people whose names do not start with '10995116277957'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.createTime = '10995116277957' WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS vals",
    "answer": [
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Afghanistan",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Algeria",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Argentina",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Australia",
      "Austria",
      "Azerbaijan",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belarus",
      "Belgium"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 distinct countries from people where the creation time is not '10995116277957', ordered by country."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Repay_Loan]->(:Person) OR (a)-[:Account_Transfer_Account]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Counts people who either do not have a repay relationship or have a transfer relationship."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Account_Repay_Loan]->(:Person) OR (a)-[:Person_Guarantee_Person]->(:Person) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 blocked statuses from people who do not have a repay relationship or have a guarantee relationship, ordered by blocked status."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanAmount) AS min_value",
    "answer": 88778.0,
    "is_noise_query": true,
    "nlp": "Finds the minimum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.interestRate) AS max_value",
    "answer": 0.1,
    "is_noise_query": true,
    "nlp": "Finds the maximum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Company_Invest_Company]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 loan usages from loans that have an investment relationship, ordered by loan usage."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Account_Transfer_Account]->(:Loan) OR (n)-[:Person_Invest_Company]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Counts loans that do not have a direct transfer relationship or have an investment relationship involving another loan."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account *1..4]-(b:Loan) RETURN count(b) AS cnt",
    "answer": 320794,
    "is_noise_query": true,
    "nlp": "Counts loans within up to four levels of deposit account relationships."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.balance LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4885842645743567395",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:282319401640788972",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4835740099889070948",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:246290604621824990",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4863606122583425208",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4907797693926998719",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4784511654127731833",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4877116921465536915",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4768467580455223872",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4892598045184622708",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "Matches the top ten loans based on balance, then for each of these, matches the top ten loans based on creation time, returning the pairs."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.createTime MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.balance RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Counts unique pairs of loans where the first loan is created before the second, and the second loan has a higher balance, ordered by the second loan's balance."
  },
  {
    "query": "MATCH (a:Loan {balance: '4901042294485943076'})-[:Person_Apply_Loan]->(b:Loan) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Loan) WHERE c.balance = '4901042294485943076' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts loans that have an application relationship with another loan, both having the specified balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance = '4901042294485943076' RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Counts loans where the balance is not equal to the specified value."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance = '4901042294485943076' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collects interest rates from loans where the balance is not equal to the specified value, ordered by interest rate, returning the first thirty-two rates."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Loan) OR (a)-[:Person_Apply_Loan]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Counts loans that do not have a direct deposit relationship or have an application relationship involving another loan."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Invest_Company]->(:Loan) OR (a)-[:Company_Own_Account]->(:Loan) WITH a ORDER BY a.loanAmount RETURN collect(a.loanAmount)[0..32] AS vals",
    "answer": [
      88778.0,
      88778.0,
      156301.0,
      156301.0,
      166473.0,
      166473.0,
      251290.0,
      312267.0,
      312267.0,
      355342.0,
      363826.0,
      363826.0,
      453579.0,
      453579.0,
      456276.0,
      456276.0,
      567068.0,
      627637.0,
      627637.0,
      728145.0,
      788756.0,
      788756.0,
      819280.0,
      819280.0,
      901438.0,
      901438.0,
      933261.0,
      1177444.0,
      1177444.0,
      1290917.0,
      1290917.0,
      1298223.0
    ],
    "is_noise_query": true,
    "nlp": "Collects loan amounts from loans that do not have an investment relationship or have an ownership relationship, ordered by loan amount, returning the first thirty-two amounts."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.mediumType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Returns the alphabetically first mediumType among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.riskLevel) AS max_value",
    "answer": "Very high risk",
    "is_noise_query": true,
    "nlp": "Find the highest risk level among all mediums, using alphabetical order."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Account_Repay_Loan]->(:Medium) WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 medium types from media that have a repay relationship, ordered by medium type."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Medium) OR (n)-[:Company_Apply_Loan]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts media that either do not have a deposit relationship or have an apply relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumId LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:130",
        "b": "Medium:884"
      },
      {
        "a": "Medium:141",
        "b": "Medium:884"
      },
      {
        "a": "Medium:28",
        "b": "Medium:884"
      },
      {
        "a": "Medium:101",
        "b": "Medium:884"
      },
      {
        "a": "Medium:46",
        "b": "Medium:884"
      },
      {
        "a": "Medium:80",
        "b": "Medium:884"
      },
      {
        "a": "Medium:19",
        "b": "Medium:884"
      },
      {
        "a": "Medium:20",
        "b": "Medium:884"
      },
      {
        "a": "Medium:86",
        "b": "Medium:884"
      },
      {
        "a": "Medium:174",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Matches ten media with the lowest medium IDs, then for each of these, matches ten media with the earliest creation times, returning pairs."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Counts pairs of distinct media where the second media has a later last login time than the first, ordered by last login time."
  },
  {
    "query": "MATCH (a:Medium {mediumType: '39582418601375'})-[:Loan_Deposit_Account]->(b:Medium) WITH b MATCH (b)-[:Account_Repay_Loan]->(c:Medium) WHERE c.lastLoginTime = '39582418601375' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts instances where a medium has both a deposit relationship and a repay relationship with another medium, where the second medium's last login time matches a specified value."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel STARTS WITH '39582418601375' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts media where the risk level does not start with a specific value."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked = '39582418601375' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 blocked statuses from media where the blocked status is not a specific value, ordered by blocked status."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Transfer_Account]->(:Medium) OR (a)-[:Person_Guarantee_Person]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts media that either do not have a transfer relationship or have a guarantee relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Transfer_Account]->(:Medium) OR (a)-[:Company_Apply_Loan]->(:Medium) WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk",
      "Critical risk"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 risk levels from media that do not have a transfer relationship or have an apply relationship, ordered by risk level."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.lastLoginTime) AS cnt UNION MATCH (b:Medium) RETURN count(b.lastLoginTime) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts the number of last login times in media for two separate matches, returning the counts as cnt."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.mediumType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the mediumType that comes first alphabetically among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all mediums. Note that isBlocked is treated as a string, so the max is determined lexicographically."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Person_Invest_Company]->(:Medium) WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 risk levels from media that have an invest relationship with a person, ordered by risk level."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Apply_Loan]->(:Medium) OR (n)-[:Person_Guarantee_Person]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts media that either do not have an apply loan relationship or have a guarantee person relationship."
  },
  {
    "query": "MATCH p = (a:Medium)-[:Medium_SignIn_Account *1..3]-(b:Medium) RETURN avg(length(p)) AS avg_len",
    "answer": 2.0,
    "is_noise_query": true,
    "nlp": "Calculates the average length of paths between media through a specific relationship, with the path length ranging from 1 to 3 hops."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumId LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:19",
        "b": "Medium:918"
      },
      {
        "a": "Medium:19",
        "b": "Medium:80"
      },
      {
        "a": "Medium:19",
        "b": "Medium:86"
      },
      {
        "a": "Medium:19",
        "b": "Medium:1624"
      },
      {
        "a": "Medium:19",
        "b": "Medium:697"
      },
      {
        "a": "Medium:19",
        "b": "Medium:1447"
      },
      {
        "a": "Medium:19",
        "b": "Medium:1132"
      },
      {
        "a": "Medium:19",
        "b": "Medium:1952"
      },
      {
        "a": "Medium:19",
        "b": "Medium:386"
      },
      {
        "a": "Medium:19",
        "b": "Medium:884"
      }
    ],
    "is_noise_query": true,
    "nlp": "Matches the top ten media based on medium ID and then finds the top ten unblocked media, returning the pairs."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.mediumType RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Counts unique pairs of media where the second media has a different medium type than the first, ordered by medium type."
  },
  {
    "query": "MATCH (a:Medium {riskLevel: '30786325578800'})-[:Company_Own_Account]->(b:Medium) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Medium) WHERE c.createTime = '30786325578800' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Counts media that have an own account relationship and then a transfer relationship with another media, where the transfer media was created at the same time as specified."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel = '30786325578800' WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-01-29 05:12:39.506",
      "2020-02-03 17:46:43.836",
      "2020-02-15 19:29:12.059",
      "2020-03-07 12:38:42.833",
      "2020-03-12 20:53:48.093",
      "2020-03-20 08:34:41.767",
      "2020-03-28 05:20:45.915",
      "2020-04-02 18:27:25.513",
      "2020-04-03 19:25:08.930",
      "2020-04-05 16:30:10.209",
      "2020-04-08 12:15:42.926",
      "2020-04-19 15:31:53.628",
      "2020-04-30 08:24:02.358",
      "2020-05-17 13:12:15.150",
      "2020-05-18 06:16:54.756",
      "2020-05-19 10:29:57.660",
      "2020-05-24 18:06:27.871",
      "2020-05-28 09:43:48.217",
      "2020-05-29 05:26:41.843",
      "2020-06-05 17:35:15.999",
      "2020-06-06 14:42:45.787",
      "2020-06-18 21:36:31.467",
      "2020-06-21 18:28:14.001",
      "2020-06-22 17:25:34.472",
      "2020-06-23 10:15:27.445",
      "2020-06-25 22:58:42.936",
      "2020-07-01 07:39:30.970",
      "2020-07-04 05:11:00.922",
      "2020-07-07 11:59:49.304",
      "2020-07-09 23:56:58.844",
      "2020-07-12 12:44:05.479",
      "2020-07-16 23:19:43.551"
    ],
    "is_noise_query": true,
    "nlp": "Collects last login times from media where the risk level is not a specific value, ordered by last login time, and returns up to 32 values."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Repay_Loan]->(:Medium) OR (a)-[:Account_Repay_Loan]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts media that do not have a repay relationship or have any repay relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Own_Account]->(:Medium) OR (a)-[:Company_Invest_Company]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-01-29 05:12:39.506",
      "2020-02-03 17:46:43.836",
      "2020-02-15 19:29:12.059",
      "2020-03-07 12:38:42.833",
      "2020-03-12 20:53:48.093",
      "2020-03-20 08:34:41.767",
      "2020-03-28 05:20:45.915",
      "2020-04-02 18:27:25.513",
      "2020-04-03 19:25:08.930",
      "2020-04-05 16:30:10.209",
      "2020-04-08 12:15:42.926",
      "2020-04-19 15:31:53.628",
      "2020-04-30 08:24:02.358",
      "2020-05-17 13:12:15.150",
      "2020-05-18 06:16:54.756",
      "2020-05-19 10:29:57.660",
      "2020-05-24 18:06:27.871",
      "2020-05-28 09:43:48.217",
      "2020-05-29 05:26:41.843",
      "2020-06-05 17:35:15.999",
      "2020-06-06 14:42:45.787",
      "2020-06-18 21:36:31.467",
      "2020-06-21 18:28:14.001",
      "2020-06-22 17:25:34.472",
      "2020-06-23 10:15:27.445",
      "2020-06-25 22:58:42.936",
      "2020-07-01 07:39:30.970",
      "2020-07-04 05:11:00.922",
      "2020-07-07 11:59:49.304",
      "2020-07-09 23:56:58.844",
      "2020-07-12 12:44:05.479",
      "2020-07-16 23:19:43.551"
    ],
    "is_noise_query": true,
    "nlp": "Collects up to 32 last login times from media that either do not have a Company_Own_Account relationship or have a Company_Invest_Company relationship, ordered by last login time."
  },
  {
    "query": "MATCH (a:Medium) RETURN count(a.isBlocked) AS cnt UNION MATCH (b:Medium) RETURN count(b.isBlocked) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Counts the number of distinct isBlocked statuses in media. The result is effectively the same as counting the total number of media nodes since isBlocked is a property of each medium node."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.freqLoginType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Returns the earliest frequent login type alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.email) AS max_value",
    "answer": "zoho.com",
    "is_noise_query": true,
    "nlp": "Finds the email address that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collects up to 32 account types from accounts that have a repay relationship, ordered by account type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Counts accounts that either do not have an apply loan relationship or have any apply loan relationship. This condition essentially applies to all accounts, so it counts all accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Repay_Loan *1..5]-(b:Account) RETURN count(b) AS cnt",
    "answer": 44326,
    "is_noise_query": true,
    "nlp": "Counts accounts within up to five levels of repay relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountId LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:25895697857381261",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:26740122787514064",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:20547673299879219",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:23080948090274944",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:20266198323168013",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:9570149208163490",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:4503599627371623",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:9570149208163943",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:14918173765665963",
        "b": "Account:4615626668101338845"
      },
      {
        "a": "Account:27584547717644507",
        "b": "Account:4615626668101338845"
      }
    ],
    "is_noise_query": true,
    "nlp": "Matches the top ten accounts based on account ID and then finds the ten most recently logged-in accounts, returning pairs of these accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Counts the number of unique email address pairs among accounts, excluding self-pairs, and orders the results by the creation time of the second account in each pair."
  },
  {
    "query": "MATCH (a:Account), (b:Account) WHERE a.email = b.email AND a <> b RETURN count(*) AS cnt",
    "answer": 4089624,
    "is_noise_query": true,
    "nlp": "Count the number of duplicate email addresses across different account records."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4878242821372380462'})-[:Account_Repay_Loan]->(b:Account) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Account) WHERE c.isBlocked = '4878242821372380462' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Identify the total count of accounts that have repaid loans and then transferred funds, where the transfer destination is blocked."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel STARTS WITH '4878242821372380462' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts not starting with a specific account level prefix."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname STARTS WITH '4878242821372380462' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the first 32 creation times of accounts whose nickname does not start with a given string, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that do not have a person ownership relationship but may have a medium sign-in relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 creation times of accounts that either lack a medium sign-in relationship or have a company ownership relationship, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountType) AS cnt UNION MATCH (b:Account) RETURN count(b.accountType) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Perform two separate counts of account types and return the results as a union."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Account) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.createTime LIMIT 20 RETURN b.createTime",
    "answer": [
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      },
      {
        "b.createTime": "2020-01-15 09:39:18.811"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the earliest creation times of 20 accounts involved in loan deposits, excluding direct deposit relationships, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.phonenum) AS min_value",
    "answer": "000-7201",
    "is_noise_query": true,
    "nlp": "Return the phone number that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountLevel) AS max_value",
    "answer": "Silver level",
    "is_noise_query": true,
    "nlp": "Find the account level that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.freqLoginType RETURN collect(a.freqLoginType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 frequency login types of accounts that are owned by a company, ordered by frequency login type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not have a person guarantee relationship or have an account withdrawal relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:231372430856161038",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4796333603149578811",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4877398396442248974",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4877398396442248974",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:231372430856161038",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4819414551239852294",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4819414551239852294",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4796333603149578811",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 accounts by nickname and then, for each of these accounts, retrieve the top 10 accounts by phone number, returning pairs of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.createTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Find the count of unique pairs of accounts where the first account is ordered by creation time and the second account is ordered by frequency login type, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Account {accountType: '4907797693926998417'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Account) WHERE c.accountLevel = '4907797693926998417' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the total number of transfers from companies invested by another company to accounts with a specific account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.email STARTS WITH '4907797693926998417' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose email does not start with a specific prefix."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel = '4907797693926998417' WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 blocked status values of accounts not having a specific account level, ordered by blocked status."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Medium_SignIn_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that do not have a loan deposit relationship but may have a medium sign-in relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Apply_Loan]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS vals",
    "answer": [
      "000-7201",
      "000-7201",
      "000-7839",
      "001-1080",
      "001-1080",
      "001-3035",
      "001-3035",
      "001-4136",
      "001-4136",
      "001-4563",
      "001-4563",
      "001-8324",
      "002-1465",
      "002-1465",
      "002-3194",
      "002-3194",
      "002-5859",
      "002-5859",
      "002-6881",
      "002-6881",
      "003-0293",
      "003-0293",
      "003-3319",
      "003-3319",
      "003-6401",
      "004-1700",
      "004-1700",
      "005-3819",
      "005-3819",
      "005-9828",
      "005-9828",
      "006-4259"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 phone numbers of accounts that do not have a company loan application but may have one, ordered by phone number."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Account) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.accountType LIMIT 20 RETURN b.accountType",
    "answer": [
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the account types of 20 companies involved in medium sign-ins, excluding direct sign-in relationships between the same accounts."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.country) AS min_value",
    "answer": "Afghanistan",
    "is_noise_query": true,
    "nlp": "Return the country that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.isBlocked) AS max_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Medium_SignIn_Account]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 company names of companies associated with medium sign-ins, ordered by company name."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Company_Own_Account]->(:Company) OR (n)-[:Loan_Deposit_Account]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that either do not have a company ownership relationship or have a loan deposit relationship."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.country LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:237",
        "b": "Company:4398046511482"
      },
      {
        "a": "Company:237",
        "b": "Company:8796093022248"
      },
      {
        "a": "Company:538",
        "b": "Company:13194139533678"
      },
      {
        "a": "Company:237",
        "b": "Company:1099511628330"
      },
      {
        "a": "Company:538",
        "b": "Company:8796093022964"
      },
      {
        "a": "Company:538",
        "b": "Company:8796093022284"
      },
      {
        "a": "Company:538",
        "b": "Company:1099511628330"
      },
      {
        "a": "Company:538",
        "b": "Company:8796093022248"
      },
      {
        "a": "Company:538",
        "b": "Company:4398046511482"
      },
      {
        "a": "Company:237",
        "b": "Company:8796093022964"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 companies by blocked status and the top 10 by country, returning both sets."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.url MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.city RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Find the count of unique pairs of companies where each pair consists of a company with a distinct URL and another with a distinct city, ordered by city."
  },
  {
    "query": "MATCH (a:Company {description: '29'})-[:Account_Transfer_Account]->(b:Company) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Company) WHERE c.url = '29' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the total number of investments from companies with a specific description ('29') to other companies with a matching URL ('29')."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.business STARTS WITH '29' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies not starting with a specific business prefix ('29')."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.createTime STARTS WITH '29' WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS vals",
    "answer": [
      "https://www.abeampedestalled.com",
      "https://www.abeamspray.io",
      "https://www.abeddishonors.net",
      "https://www.ablyrechristens.io",
      "https://www.abroachthack.edu",
      "https://www.activelyveers.info",
      "https://www.adriftlob.io",
      "https://www.afielddarn.org",
      "https://www.afirewaff.net",
      "https://www.aflutterschlepp.org",
      "https://www.aforetimerecrudesce.com",
      "https://www.aftblent.edu",
      "https://www.againknead.net",
      "https://www.agapedome.io",
      "https://www.agapeflavours.info",
      "https://www.agoneligatures.info",
      "https://www.aheadstore.io",
      "https://www.airilybask.edu",
      "https://www.aleetwins.gov",
      "https://www.allchaperons.org",
      "https://www.alldisputing.io",
      "https://www.aloftequalise.edu",
      "https://www.alongshorebreakwaters.net",
      "https://www.aloudreworks.org",
      "https://www.alsoescalades.io",
      "https://www.alsojee.edu",
      "https://www.alsovacations.gov",
      "https://www.alwaysingest.com",
      "https://www.alwayspouches.com",
      "https://www.alwaysredescend.com",
      "https://www.aneardignify.net",
      "https://www.anesblub.edu"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 URLs of companies not starting with a specific creation time prefix ('29'), ordered by URL."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Invest_Company]->(:Company) OR (a)-[:Person_Invest_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count the number of companies that have any person investment relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Company) OR (a)-[:Company_Guarantee_Company]->(:Company) WITH a ORDER BY a.description RETURN collect(a.description)[0..32] AS vals",
    "answer": [
      "A broom and swept up the room. Then there was still just a moment, and he was weak from hunger, made up for in some way, but he had, after all, and rushed forward in a smart blue uniform with his father.",
      "A cave, a stranger would have to overcome it because he feared his father now from the bed first, of course, moving it an inch. His father were of no help, for instance, whenever i go back to the window.",
      "A corner. His idea of relaxation is working with his chin on the banister, he called again with the whole evening looking at all, and it had only been alarmed briefly. Now they did exactly as he sought.",
      "A gush of coffee was pouring down onto the key or pushed it from the living room where he was forced to remain made him feel better. He was unable to pay off my parents know about it, repeatedly raising.",
      "A month earlier he had been living in it. That set his mother screaming anew, she brought him a little more slowly than them, louts, was still hurriedly thinking all this time, though, did not understand.",
      "A page to each of the other hand, he made it difficult to eat if his whole body against it. Gregor also refrained, this was so resentful of it. That' s mother had now fallen completely asleep. He was using.",
      "A pleasant experience, and gregor' s room any more. And indeed, his mother, and then throw himself at his two friends joined in with the whole flat and especially in the office, so he started working especially.",
      "A possible reason for her. As they pushed it down again with the same way. During the day, early in the middle had produced a newspaper, given a page to each other as if he happened to me? he could do even.",
      "A serious cold, which had probably been permanently set aside for emergencies; money to live off the interest; it was only ever thinks about the others. What shall we take now, he called to him, what is.",
      "A short while he told himself once more pursue their parents with the violin. Whenever they can. Perhaps only because her mother quite worried, that would have enough space to get gregor to open the window.",
      "A strain for her to immediately open the door again straight away that gregor had only been able to actually move around on those spindly little legs along one side hung quivering in the air while those.",
      "A time. Gregor is ill. Quick, get the top part of the need to earn money? she had time to catch her breath, he felt as if he left most of all playing the violin went silent. What he was moreover unable.",
      "A time. The previous morning while his parents about the others? she was fully( in his back and sides; he had put her finger on her lips and made a sudden fear that mr. Samsa, he startled her when she reached.",
      "A use. Should he do anything to make, and his hands, get the job finished before gregor' s feelings, as his father and continue being of help to him as he was still there and fetch it herself he would still.",
      "A wink but scratching at the same conclusion: for the days that i' ll be someone from work, she had spoken to him today could ever happen to it. They had seen her as a girl who was already the end of march.",
      "About. Where is our breakfast?, the middle of the bed, when he was well aware that we can very easily fall victim to gossip and chance and groundless complaints, and believe me it would also have let him.",
      "Acquired, that made it difficult for him. She left the premises. Mr. Samsa were struck, almost whispering as if he succeeded in falling out of his mobility- probably permanently. He soon had to blow himself.",
      "Action for damages from you, and mumbled something into their beards and moved it because of the flat knew when she' s room. Before, they took everything calmly he would have seen long ago that it' ll be.",
      "Actually was that although the flat. What' s experienced hand, i' ll be able to eat and it was an apple; then he used the tip of his mother, accused her of not leaving the chair twice before she even swore.",
      "Again now, then. Let' s got to get dressed so quickly? there was someone at the same place, imagining the wildest possibilities, but that was the boss and told him just what i' m just getting out of the.",
      "Again straight away. Gregor slowly pushed his head kept nodding it could be seriously ill and he smiled sweetly. The cleaner came in on gregor and went over to the living room. The cleaner wanted to show.",
      "Again straight away. Gregor slowly pushed his head kept nodding it could be seriously ill and he smiled sweetly. The cleaner came in on gregor and went over to the living room. The cleaner wanted to show.",
      "Against its glass, it was only able to speak to you personally. So now gregor' s responsibility and he smiled sweetly. The change in gregor' s mother and sister, naturally, tried as far as possible to look.",
      "Aim, threw one apple after another. These earnest gentlemen- all three of them he only had they earned a break from work, but the milk as it would soon be time to give directions from a junior salesman.",
      "All could be seen. His sister noticed the full dish immediately and looked at it for five years that he couldn' t. I' d have gone of his legs as they danced around. For instance, whenever she felt like.",
      "All excitedly following his efforts to muster all the breakfast things on it without further difficulty. In his highly polished boots could now be heard in the room several times a year when they came back.",
      "All it' s not coming into the room, and mumbled something into their beards and moved back towards their room only very slowly. Meanwhile, it might happen that he was now quite light in the circumstances.",
      "All it' s voice probably could not see it at all, mr. Samsa might go to all the more diligence and concentration. You' ve chosen! travelling day in and looked round. It is, but one day a week, perhaps caused.",
      "All times and they had had no success with that she would strain herself. This picture at least partly right! but you always think you can come in, not every day of his room before the night, my train leaves.",
      "Almonds; some cheese that gregor, one that would excuse their behaviour. The food that was the nearest to the chief clerk, but he could meet her eyes met those of gregor when he tried to climb up to him.",
      "Almost as a girl who was beside himself with anger, into the room came in, she broke out so heavily in tears, thumped on the spot. But he never goes out in her chair with her hand on her hat, which was.",
      "Almost as a sign to the window wide. Although it was before so that she was fully dressed, opened her eyes nearly closed with exhaustion; his sister, who had not heard her coming at all, either night or."
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 descriptions of companies that either do not have a medium sign-in relationship or have a company guarantee relationship, ordered by their description."
  },
  {
    "query": "MATCH (a:Company)-[:Person_Invest_Company]-()-[:Person_Invest_Company]-(b:Company) WHERE NOT (a)-[:Person_Invest_Company]-(b) WITH b ORDER BY b.companyId LIMIT 20 RETURN b.companyId",
    "answer": [
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 93
      },
      {
        "b.companyId": 354
      },
      {
        "b.companyId": 354
      },
      {
        "b.companyId": 354
      },
      {
        "b.companyId": 354
      },
      {
        "b.companyId": 354
      },
      {
        "b.companyId": 354
      },
      {
        "b.companyId": 2199023256322
      },
      {
        "b.companyId": 2199023256322
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the company IDs of 20 distinct companies involved in person-to-person investment chains, excluding those with direct investment relationships between the same companies."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-01 03:31:14.114",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.lastLoginTime) AS max_value",
    "answer": "2022-12-31 23:55:02.684",
    "is_noise_query": true,
    "nlp": "Find the latest last login time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Person_Guarantee_Person]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 blocked statuses of mediums associated with person guarantees, ordered by whether they are blocked."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Repay_Loan]->(:Medium) OR (n)-[:Person_Guarantee_Person]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of mediums that do not have an account repay loan relationship but might have a person guarantee relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.mediumType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:918",
        "b": "Medium:249"
      },
      {
        "a": "Medium:918",
        "b": "Medium:1551"
      },
      {
        "a": "Medium:918",
        "b": "Medium:1897"
      },
      {
        "a": "Medium:918",
        "b": "Medium:20"
      },
      {
        "a": "Medium:918",
        "b": "Medium:1983"
      },
      {
        "a": "Medium:918",
        "b": "Medium:1728"
      },
      {
        "a": "Medium:918",
        "b": "Medium:680"
      },
      {
        "a": "Medium:918",
        "b": "Medium:1861"
      },
      {
        "a": "Medium:918",
        "b": "Medium:386"
      },
      {
        "a": "Medium:918",
        "b": "Medium:1718"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 blocked mediums and the top 10 mediums by type, returning both sets."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Find the count of unique last login time pairs among mediums, where each pair consists of two different mediums, ordered by the last login time."
  },
  {
    "query": "MATCH (a:Medium), (b:Medium) WHERE a.mediumType = b.mediumType AND a <> b RETURN count(*) AS cnt",
    "answer": 380978,
    "is_noise_query": true,
    "nlp": "Count the number of distinct medium pairs with the same medium type, excluding self-references."
  },
  {
    "query": "MATCH (a:Medium {mediumType: '26388279067580'})-[:Medium_SignIn_Account]->(b:Medium) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Medium) WHERE c.createTime = '26388279067580' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the total number of transfers from media signed in by another medium to media with a specific creation time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.createTime CONTAINS '26388279067580' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of media whose creation time does not contain the specific string '26388279067580'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.lastLoginTime = '26388279067580' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 creation times of media whose last login time does not match '26388279067580', ordered by their creation time."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Transfer_Account]->(:Medium) OR (a)-[:Person_Guarantee_Person]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count the number of media that either do not have an account transfer relationship or do have a person guarantee relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Medium) OR (a)-[:Person_Invest_Company]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 blocked statuses of media that do not have an account withdrawal relationship but may have a person investment relationship, ordered by their blocked status."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.balance) AS avg_value",
    "answer": 25806019.535552666,
    "is_noise_query": true,
    "nlp": "Calculate the average balance of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.interestRate) AS min_value",
    "answer": 0.0,
    "is_noise_query": true,
    "nlp": "Find the minimum interest rate among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanAmount) AS max_value",
    "answer": 99999435.0,
    "is_noise_query": true,
    "nlp": "Find the maximum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Apply_Loan]->(:Loan) WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 loan usage types of loans that are associated with person applications, ordered by their loan usage."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Apply_Loan]->(:Loan) OR (n)-[:Person_Apply_Loan]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of loans that have a person application."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanUsage LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:4701476535998088242"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:4711891110136381993"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:79375943432405966"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:82472168176223460"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:70650219154375089"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:29836347531329650"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:4663195939165439209"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:66146619527004485"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:4658973814514778717"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:4714705859903489184"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve the top 10 loans by interest rate and the top 10 by loan usage, returning both sets."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.interestRate RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Find the count of unique loan interest rate pairs, where each pair consists of loans with different interest rates, ordered by their interest rates."
  },
  {
    "query": "MATCH (a:Loan {balance: '144959613005987994'})-[:Person_Guarantee_Person]->(b:Loan) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Loan) WHERE c.loanAmount = '144959613005987994' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the total number of distinct loans that are both guaranteed by another loan and have a deposit account relationship with a specific balance."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.interestRate STARTS WITH '144959613005987994' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the first 32 interest rates of loans whose interest rates do not start with '144959613005987994', ordered by interest rate."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Invest_Company]->(:Loan) OR (a)-[:Account_Withdraw_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of loans that either do not have a person investment relationship or have an account withdrawal relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Own_Account]->(:Loan) OR (a)-[:Account_Withdraw_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 interest rates of loans that do not have a company ownership relationship but may have an account withdrawal relationship, ordered by interest rate."
  },
  {
    "query": "MATCH (a:Loan) RETURN count(a.createTime) AS cnt UNION MATCH (b:Loan) RETURN count(b.createTime) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Perform two separate counts of loan creation times and return the results as a union."
  },
  {
    "query": "MATCH (a:Loan)-[:Loan_Deposit_Account]-()-[:Loan_Deposit_Account]-(b:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]-(b) WITH b ORDER BY b.loanId LIMIT 20 RETURN b.loanId",
    "answer": [
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      },
      {
        "b.loanId": 12666373951980233
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the loan IDs of 20 loans involved in indirect loan deposit relationships, excluding those with direct deposit relationships."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.email) AS max_value",
    "answer": "zoho.com",
    "is_noise_query": true,
    "nlp": "Find the email that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Medium_SignIn_Account]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the first 32 account types of accounts that have a Medium_SignIn_Account relationship, ordered by account type."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Company_Apply_Loan]->(:Account) OR (n)-[:Account_Withdraw_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that do not have a direct loan application relationship but may have a withdrawal relationship with other accounts."
  },
  {
    "query": "MATCH (a:Account)-[:Person_Own_Account *1..4]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3200,
    "is_noise_query": true,
    "nlp": "Count the number of accounts connected through ownership relationships within 1 to 4 hops."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835283571"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407895618"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835282675"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835284218"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285415626384607208"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by phone number and then identify another set of top 10 accounts based on account level, returning both sets."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.phonenum RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct non-blocking accounts where each pair has a different phone number."
  },
  {
    "query": "MATCH (a:Account {nickname: '4850376798678026230'})-[:Loan_Deposit_Account]->(b:Account) WITH b MATCH (b)-[:Company_Invest_Company]->(c:Account) WHERE c.lastLoginTime = '4850376798678026230' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of connections involving specific loan and company investment relationships associated with a given nickname."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType STARTS WITH '4850376798678026230' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose frequency login type does not start with a specified string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.isBlocked CONTAINS '4850376798678026230' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the email addresses of non-blocking accounts that do not contain a specific string, ordered by email, up to 32 entries."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count all accounts, as the condition is always true."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Invest_Company]->(:Account) OR (a)-[:Account_Transfer_Account]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS vals",
    "answer": [
      "2020-05-03 18:42:43.956",
      "2020-06-11 05:14:46.792",
      "2020-06-24 16:46:53.614",
      "2020-07-27 13:03:02.659",
      "2020-08-18 23:32:48.069",
      "2020-08-28 07:47:58.196",
      "2020-08-30 10:11:20.444",
      "2020-09-03 06:58:23.591",
      "2020-09-04 13:07:17.076",
      "2020-09-23 03:39:36.501",
      "2020-10-16 07:22:56.398",
      "2020-10-28 19:27:36.434",
      "2020-11-11 10:00:42.791",
      "2020-11-12 05:48:37.974",
      "2020-11-14 13:49:51.771",
      "2020-12-10 10:59:18.092",
      "2020-12-13 19:36:10.040",
      "2020-12-19 01:10:01.952",
      "2020-12-21 19:06:27.372",
      "2020-12-28 01:36:47.828",
      "2021-01-03 17:00:42.824",
      "2021-01-11 08:49:41.025",
      "2021-01-12 11:48:38.381",
      "2021-01-19 16:15:08.017",
      "2021-01-22 02:19:33.987",
      "2021-01-27 10:58:22.658",
      "2021-01-28 19:39:50.104",
      "2021-02-08 20:18:21.203",
      "2021-02-09 10:00:02.597",
      "2021-02-13 17:30:42.266",
      "2021-02-15 16:59:19.703",
      "2021-03-01 18:22:28.660"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 last login times of accounts that do not invest in companies or may have transferred accounts, ordered by login time."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.freqLoginType) AS min_value",
    "answer": "ATM",
    "is_noise_query": true,
    "nlp": "Return the frequent login type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.phonenum) AS max_value",
    "answer": "999-9198",
    "is_noise_query": true,
    "nlp": "Find the phone number that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 creation times of accounts owned by a company, ordered by creation time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Account_Transfer_Account]->(:Account) OR (n)-[:Person_Invest_Company]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not transfer money to another account or invest in companies."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:231372430856161038",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4796333603149578811",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4877398396442248974",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4877398396442248974",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:231372430856161038",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4819414551239852294",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4819414551239852294",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:241224055041032454",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4796333603149578811",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of accounts where the first ten have the top nicknames and the second ten have the top phone numbers."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts with different emails, ordered by the second account's account level."
  },
  {
    "query": "MATCH (a:Account {phonenum: '4880776096162775937'})-[:Medium_SignIn_Account]->(b:Account) WITH b MATCH (b)-[:Account_Withdraw_Account]->(c:Account) WHERE c.accountLevel = '4880776096162775937' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of connections where a specific account signs in via a medium and then withdraws funds, with the withdrawn account having a specific account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime STARTS WITH '4880776096162775937' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose last login time does not start with a specified string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.isBlocked STARTS WITH '4880776096162775937' WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 nicknames of accounts that are not blocked and do not start with a specified string, ordered by nickname."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Own_Account]->(:Account) OR (a)-[:Company_Invest_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not own a person's account or are involved in company investments."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Account) OR (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account levels of accounts that do not sign in via a medium or repay loans, ordered by account level."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Transfer_Account]-()-[:Account_Transfer_Account]-(b:Account) WHERE NOT (a)-[:Account_Transfer_Account]-(b) WITH b ORDER BY b.accountType LIMIT 20 RETURN b.accountType",
    "answer": [
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      },
      {
        "b.accountType": "brokerage account"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the account types of accounts that have indirect Account Transfer relationships but no direct ones, limited to 20 results."
  },
  {
    "query": "MATCH (a:Person) RETURN min(a.personName) AS min_value",
    "answer": "Abay",
    "is_noise_query": true,
    "nlp": "Return the personName that comes first alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) RETURN max(a.personName) AS max_value",
    "answer": "ychliski",
    "is_noise_query": true,
    "nlp": "Find the personName that comes last alphabetically among all people."
  },
  {
    "query": "MATCH (a:Person) WHERE (a)-[:Medium_SignIn_Account]->(:Person) WITH a ORDER BY a.country RETURN collect(a.country)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 distinct countries of persons that have signed in via medium, ordered by country."
  },
  {
    "query": "MATCH (n:Person) WHERE NOT (n)-[:Person_Invest_Company]->(:Person) OR (n)-[:Medium_SignIn_Account]->(:Person) RETURN count(n)",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons who either do not invest in companies or sign in via medium."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Person) WITH a, b ORDER BY b.personName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Person:630",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:51",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:808",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:640",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:982",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:41",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:729",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:310",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:985",
        "b": "Person:28587302322284"
      },
      {
        "a": "Person:755",
        "b": "Person:28587302322284"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of persons where the first ten are ordered by their block status and the second ten by their names."
  },
  {
    "query": "MATCH (a:Person) WITH a ORDER BY a.createTime MATCH (b:Person) WHERE a <> b WITH a, b ORDER BY b.gender RETURN count(*) AS pair_count",
    "answer": 959420,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct persons with different creation times, ordered by the second person's gender."
  },
  {
    "query": "MATCH (a:Person {personName: '648'})-[:Account_Repay_Loan]->(b:Person) WITH b MATCH (b)-[:Person_Invest_Company]->(c:Person) WHERE c.gender = '648' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of connections involving specific repay loan and invest company relationships where the initial person's name is '648' and the invested person's gender is '648'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.createTime = '648' RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons whose creation time is not equal to '648'."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT a.country = '648' WITH a ORDER BY a.birthday RETURN collect(a.birthday)[0..32] AS vals",
    "answer": [
      "1980-01-08",
      "1980-01-18",
      "1980-01-21",
      "1980-01-23",
      "1980-01-29",
      "1980-02-02",
      "1980-02-04",
      "1980-02-06",
      "1980-03-11",
      "1980-03-19",
      "1980-03-19",
      "1980-03-21",
      "1980-03-31",
      "1980-04-09",
      "1980-04-13",
      "1980-04-13",
      "1980-04-15",
      "1980-04-15",
      "1980-04-20",
      "1980-04-21",
      "1980-05-22",
      "1980-06-19",
      "1980-06-19",
      "1980-06-27",
      "1980-07-14",
      "1980-07-17",
      "1980-07-27",
      "1980-08-02",
      "1980-08-11",
      "1980-08-15",
      "1980-08-18",
      "1980-08-22"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 distinct birthdays of persons whose country is not equal to '648', ordered by birthday."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Company_Own_Account]->(:Person) OR (a)-[:Account_Repay_Loan]->(:Person) RETURN count(a) AS cnt",
    "answer": 980,
    "is_noise_query": true,
    "nlp": "Count the number of persons who either do not own a company or have repaid loans."
  },
  {
    "query": "MATCH (a:Person) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Person) OR (a)-[:Medium_SignIn_Account]->(:Person) WITH a ORDER BY a.personName RETURN collect(a.personName)[0..32] AS vals",
    "answer": [
      "Abay",
      "Abdalas",
      "Abdelli",
      "Abrikosov",
      "Abutalybov",
      "Acevedo",
      "Aghdamski",
      "Agnes Christina Of Austria",
      "Aguilar",
      "Aird",
      "Akhurst",
      "Akindele",
      "Akyz",
      "Al Hussain",
      "Albar",
      "Alcala",
      "Alder",
      "Ales",
      "Alexander",
      "Alghisi",
      "Alling",
      "Almeyda",
      "Altavista",
      "Ambrosius",
      "Amonqulova",
      "Amoroso",
      "Anaya",
      "Anderson",
      "Anderson",
      "Anderson",
      "Anderson Imbert",
      "Andhyarujina"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 person names of all individuals, ordered by their names, regardless of whether they sign in via medium or not."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.loanAmount) AS avg_value",
    "answer": 48819411.184508234,
    "is_noise_query": true,
    "nlp": "Find the average loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN sum(a.interestRate) AS total_value",
    "answer": 116.34200000000003,
    "is_noise_query": true,
    "nlp": "Calculate the total sum of interest rates across all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.createTime) AS min_value",
    "answer": "2020-02-15 04:08:32.798",
    "is_noise_query": true,
    "nlp": "Determine the earliest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.loanUsage) AS max_value",
    "answer": "weddings",
    "is_noise_query": true,
    "nlp": "Identify the loan usage that comes last alphabetically among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Account_Transfer_Account]->(:Loan) WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 interest rates of loans that involve account transfers, ordered by interest rate."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Person_Own_Account]->(:Loan) OR (n)-[:Account_Withdraw_Account]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of loans that either do not have a person owning them or are involved in account withdrawals."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.interestRate LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.createTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:143833713099145499",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4802807527613924326",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4759460381200482587",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:123848989752689515",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:217298682020626503",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4889501820440805670",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4866420872350532459",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4894568370021597389",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4890627720347648427",
        "b": "Loan:12666373951980233"
      },
      {
        "a": "Loan:4894849844998307888",
        "b": "Loan:12666373951980233"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 loans with the highest interest rates and the top 10 loans with the earliest creation times."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.balance RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans with different loan amounts, ordered by the balance of the second loan in each pair."
  },
  {
    "query": "MATCH (a:Loan {loanUsage: '276408427129864368'})-[:Account_Withdraw_Account]->(b:Loan) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Loan) WHERE c.loanUsage = '276408427129864368' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of loans where there is a connection involving a specific withdraw and apply relationship with a given loan usage."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.loanAmount = '276408427129864368' WITH a ORDER BY a.loanUsage RETURN collect(a.loanUsage)[0..32] AS vals",
    "answer": [
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures",
      "business ventures"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 loan usages of loans whose loan amount does not match a specified value, ordered by loan usage."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Invest_Company]->(:Loan) OR (a)-[:Person_Own_Account]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count the number of loans that either do not have a relationship where they invest in another company or do have a relationship where they own an account."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Company_Apply_Loan]->(:Loan) OR (a)-[:Person_Apply_Loan]->(:Loan) WITH a ORDER BY a.balance RETURN collect(a.balance)[0..32] AS vals",
    "answer": [
      61.51,
      62.37,
      111.44,
      201.44,
      263.89,
      562.45,
      769.15,
      971.05,
      1364.68,
      1474.58,
      1850.89,
      1859.25,
      2638.41,
      2741.97,
      2831.06,
      3021.97,
      3313.09,
      3690.54,
      3885.13,
      4801.41,
      5296.98,
      5491.24,
      8423.84,
      8930.37,
      9107.76,
      9378.97,
      9554.96,
      11339.17,
      11665.03,
      11785.13,
      12075.02,
      12430.63
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 balances of loans that do not apply for company loans or do apply for person loans, ordered by balance."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-05-03 18:42:43.956",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account levels of accounts that have a relationship applying for loans, ordered by account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Invest_Company]->(:Account) OR (n)-[:Company_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that do not have a relationship investing in a person or do have a relationship where a company owns an account."
  },
  {
    "query": "MATCH (a:Account)-[:Loan_Deposit_Account *2..5]-(b:Account) RETURN count(b) AS cnt",
    "answer": 120024,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that have between two and five loan deposit relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.phonenum LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4744542207434819682",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:248542404435511308",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:4744542207434819682",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:113715890591106030",
        "b": "Account:113715890591106030"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4713861434973357038"
      },
      {
        "a": "Account:250512729272485986",
        "b": "Account:113715890591106030"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of accounts with the top 10 phone numbers, first selecting the top 10 accounts based on their phone numbers, then pairing them with the next top 10 accounts based on their phone numbers."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.lastLoginTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the phone numbers are different, ordered by the second account's last login time."
  },
  {
    "query": "MATCH (a:Account {freqLoginType: '4883309370953172369'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Account) WHERE c.lastLoginTime = '4883309370953172369' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of unique connections where an account with a specific freqLoginType has invested in another account, and that other account has signed in via a specified medium, matching a particular last login timestamp."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.isBlocked = '4883309370953172369' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose block status is not set to the specified string value."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType CONTAINS '4883309370953172369' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 creation times of accounts whose frequency login type does not contain a specified string, ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Company_Own_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that either do not invest in any company or own a company."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 account types of accounts that do not guarantee a person or repay loans, ordered by account type."
  },
  {
    "query": "MATCH (a:Account) RETURN count(a.accountType) AS cnt UNION MATCH (b:Account) RETURN count(b.accountType) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Combine counts of account types from two separate sets of accounts."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.description) AS min_value",
    "answer": "A broom and swept up the room. Then there was still just a moment, and he was weak from hunger, made up for in some way, but he had, after all, and rushed forward in a smart blue uniform with his father.",
    "is_noise_query": true,
    "nlp": "Return the description that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.description) AS max_value",
    "answer": "You had to pull himself off by force; then they quickly finished their meal at home, every other day would be in an empty room like that in such a nice home for the time to get the chest of drawers was.",
    "is_noise_query": true,
    "nlp": "Find the description that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Guarantee_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 473,
    "is_noise_query": true,
    "nlp": "Count companies that have at least one outgoing Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Account_Withdraw_Account]->(:Company) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Return the earliest 32 creation times of companies that have an Account_Withdraw_Account relationship with another company, ordered by creation time."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Account_Repay_Loan]->(:Company) OR (n)-[:Company_Invest_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have an outgoing Account_Repay_Loan relationship or have an incoming Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.companyId LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:180",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:192",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:100",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:178",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:43",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:23",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:64",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:93",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:29",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:237",
        "b": "Company:4398046511515"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 companies by ID, then find the top 10 companies by name, returning both sets."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies ordered by their block status, where neither company is blocked."
  },
  {
    "query": "MATCH (a:Company {createTime: '6597069766929'})-[:Account_Repay_Loan]->(b:Company) WITH b MATCH (b)-[:Medium_SignIn_Account]->(c:Company) WHERE c.city = '6597069766929' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count related companies based on specific relationships and city, returning the total count."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.description = '6597069766929' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies excluding those with a specific description."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.country <> '6597069766929' WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect URLs of companies that match a specific country condition, ordered by URL, returning up to 32 URLs."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Company) OR (a)-[:Person_Own_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies based on specific relationships, excluding those with Person_Guarantee_Person but including those with Person_Own_Account."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Invest_Company]->(:Company) OR (a)-[:Loan_Deposit_Account]->(:Company) WITH a ORDER BY a.description RETURN collect(a.description)[0..32] AS vals",
    "answer": [
      "And learned from the ceiling; it sounded to gregor' s lap who still had not said enough and that' s room and, with look of determination, walked towards gregor and went over to the food- he had often felt.",
      "Another. These earnest gentlemen- all three took their sticks from the door if he were being so insistent, and openly pressed her face into his ear, gregor would think of any other way of transferring gregor.",
      "Be somewhere, for the short time that day, in this case? gregor answered to both sides: i' m seriously in debt to him, uniting herself with him, gregor' s appreciation of the way he had, tugged excitedly.",
      "Become used to this chaos. He had taken his meals with his sister' s fainted, but gregor had had enough of the table she sat quickly down on it- out of bed. And so, she came into the pantry where he wanted.",
      "Being a commercial traveller is arduous but without daring to raise his voice as clear as possible. So, as she had recently acquired, that thing in there, said gregor, he was glad to provide it, but without.",
      "Broke into convulsive tears. Her words, she suddenly remembered what a life that had been to arrange things so that grete had put her hand as introduction, we don' t listen, it' s nothing serious. But then.",
      "Comment, or to throw off the covers; he wanted to be upset, and that his father, though, before, if he had become more obstinate and would reappear a few hours of rest have given me strength. You can get.",
      "Confused. When she did not know that he could, but they have to go and fetch it herself he would. He did not know that nobody likes the travellers. They had the opportunity, or if he had come back from.",
      "Conservatory next year even though it would have gone of his long uniform coat; his sister whispered: gregor? if she didn' t get out of the door again straight away. Gregor even learned, listening to what.",
      "Day had become more obstinate and would reappear a few air holes in it; it sounded to gregor that you grant that i' m getting up early all the time to get himself upright. He was glad to provide a life.",
      "Did so he ran after him, clearer than before, if he had to blow himself up; but they all blew the smoke from their mouth and slowly retreating as if they had had before. Oh, god, he crawled over everything.",
      "Do the heaviest work; everything had to be set free and would finally disappear altogether. He had already finished their meal, the vegetables and the stairs; with his right, and most of all his sister.",
      "Doorway. When gregor turned round he turned his head a little while before and therefore showed an exaggerated courtesy towards the man actually did take long strides into the other hand, so that he could.",
      "Enough sleep. Other times he tried to tickle gregor with his forefinger at gregor' s father into a panic. In order to eat the food- he had to admit to himself that calm consideration was much better than.",
      "Entitled to, even if he happened to be temporarily unable to work, she came into the doorway with a dish filled with warm sunshine, all to have the slightest noise he was already wide open before he could.",
      "Even shabbier despite the efforts of gregor and his mother- it' s gregor. We don' t read the latest contracts i sent in. Gregor even thought of opening the door unless it was sufficiently cooked or whether.",
      "Eventually, though, before, the words: and we' re going to get up. With his head sank down completely, and gregor' s the curse of travelling, of course, or perhaps they were all employees, every other day.",
      "Exchange a tired grin. With his uniform cap between the plates left by the employees at the table and took the time being he must remain calm, he coughed a little by the door if he hurried under the couch.",
      "Foot before she rushed over to the unknown nourishment he had left but she' s new way of saving himself than running; he could see, he took the time of it. It was not until it was even more strongly than.",
      "Furniture made it impossible for her just to move, it was not able to get up, the door of the idea that gregor needed a lot, but wasted no time with that, caused himself no damage. Very soon. Then, to get.",
      "Great pride that he certainly would not feel selfish, that his father looked hostile, and which he leant over to the chief clerk' s elderly mother now have to rush like mad and the sauce; the fresh foods.",
      "Gregor hardly slept at all the more lively as they went, as she opened the door and he was slow and clumsy. Would gregor have missed a train! the lad only ever mentioned as a sign of his head back again.",
      "Had finished eating and lay lethargic in the air with his right there followed a painful silence; in the morning while his mother had pulled open a window, leant far out of it. The bedding was hardly inside.",
      "Heard, as a calm and sensible person, and now they did so he began to be up at the other hand, so, but instead of them, so he became afraid to carry out your business duties in a way, and placed it beside.",
      "Him feel uneasy as he fell down into the habit of crawling up and say to him to let her mother, mother, who would receive him sitting in the lock she said loudly to her mother enter. Gregor' s father as.",
      "Him from where he was already wide open before he could at whatever sacrifice. At that time had been possible. But as if there had been bringing home every month, and, with look of gratitude one time when.",
      "However hard he threw himself onto the floor, even though he had become superfluous which, since she had probably only just gained. They did so he began to move about, he could just understand us, repeated.",
      "Listening, when she had. The three gentlemen before driving gregor out, all three had jobs which were very good and held tightly to the living room slightly open, his eyes open; his sister away, and it.",
      "Ll make the big change. First of all, much more sensible to leave him to use although, here and there was now ten past seven and he would have woken soon afterwards anyway even if it could hardly be recognised.",
      "Palely here and there onto the carpet. Something' s humanly possible to quietly sleep through that furniture- rattling noise? true, he' ll be there in their own chairs; his body than before- perhaps his.",
      "Present, be of some use to him while he called, what is it you want then?, gregor asked himself as he crouched there on the other side. This lasted a very strong jaw; using the jaw, he watched as it is.",
      "Rolled back to their real and natural state. But you women wouldn' t use for the first good news that gregor needed a lot of room to his sister unselfconsciously took a broom and swept up the room on his."
    ],
    "is_noise_query": true,
    "nlp": "Collect descriptions of companies that either do not invest in other companies or have loan deposit accounts, ordered by description, returning up to 32 descriptions."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-15 09:39:18.811",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the login type that appears last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Own_Account]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the top 32 account levels of accounts that have a Company_Own_Account relationship, ordered by their account level."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Account) OR (n)-[:Person_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not sign in via Medium_SignIn_Account or own a Person_Own_Account."
  },
  {
    "query": "MATCH p = (a:Account)-[:Account_Repay_Loan *3..5]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 4.0,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths between 3 to 5 hops along the Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountLevel LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896820169835283571"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:285134151407895618"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896820169835282675"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896820169835284218"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:285415626384607208"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find pairs of accounts where the first set is not blocked and the second set is ordered by account level, limiting both sets to 10 accounts each."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountLevel MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.freqLoginType RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of accounts where the first account is not equal to the second, ordering by the second account's login frequency."
  },
  {
    "query": "MATCH (a:Account {accountType: '285978576338027231'})-[:Person_Apply_Loan]->(b:Account) WITH b MATCH (b)-[:Company_Guarantee_Company]->(c:Account) WHERE c.createTime = '285978576338027231' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count related accounts where a person applies for a loan and is guaranteed by a company with a specific creation time, returning the total count."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.freqLoginType CONTAINS '285978576338027231' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts whose frequent login type does not contain a specific string."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname CONTAINS '285978576338027231' WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Collect up to 32 nicknames of accounts whose nickname does not contain a specific string, ordered by nickname."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not withdraw from another account or guarantee a person, indicating their relationship status."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect account levels of accounts that either do not have an outgoing Person_Invest_Company relationship or have an incoming Person_Apply_Loan relationship, ordered by account level, and limit the result to the top 32."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-01-29 05:12:39.506",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-28 23:57:25.319",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Person_Invest_Company]->(:Medium) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect last login times of mediums that have an outgoing Person_Invest_Company relationship, ordered by last login time, and limit the result to the top 32."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Person_Apply_Loan]->(:Medium) OR (n)-[:Company_Guarantee_Company]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either do not have an incoming Person_Apply_Loan relationship or have an outgoing Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH p = (a:Medium)-[:Medium_SignIn_Account *1..4]-(b:Medium) RETURN avg(length(p)) AS avg_len",
    "answer": 3.9386438336671925,
    "is_noise_query": true,
    "nlp": "Calculate the average length of paths of up to four hops between mediums through the Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.createTime LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1132",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1952",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:697",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1447",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:86",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:80",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:918",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1624",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:884",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:386",
        "b": "Medium:1994"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the 10 most recently created mediums and then find the 10 mediums with the most recent last login time, returning these pairs."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.lastLoginTime MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.mediumType RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count unique pairs of mediums where the first medium's last login time is greater than the second medium's last login time, and the mediums are different, ordered by medium type."
  },
  {
    "query": "MATCH (a:Medium {createTime: '21990232555549'})-[:Person_Apply_Loan]->(b:Medium) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Medium) WHERE c.createTime = '21990232555549' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of mediums that have a Person_Apply_Loan relationship from a specific medium and also have an Account_Transfer_Account relationship to another specific medium, both with a createTime of '21990232555549'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.isBlocked STARTS WITH '21990232555549' WITH a ORDER BY a.riskLevel RETURN collect(a.riskLevel)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect risk levels of non-blocked mediums starting with '21990232555549', ordered by risk level, and limit the result to the top 32."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Medium) OR (a)-[:Loan_Deposit_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have outgoing Loan_Deposit_Account relationships or have such relationships with other Medium nodes."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Medium) OR (a)-[:Person_Invest_Company]->(:Medium) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-01 03:31:14.114",
      "2020-01-02 01:40:45.692",
      "2020-01-02 09:13:22.902",
      "2020-01-02 10:57:27.543",
      "2020-01-03 03:01:42.709",
      "2020-01-03 16:40:53.592",
      "2020-01-04 09:02:19.399",
      "2020-01-04 14:19:16.926",
      "2020-01-04 23:13:40.316",
      "2020-01-05 05:56:56.523",
      "2020-01-05 09:21:18.758",
      "2020-01-05 12:54:01.232",
      "2020-01-06 02:01:08.926",
      "2020-01-06 08:08:47.238",
      "2020-01-06 12:07:11.315",
      "2020-01-06 15:43:59.597",
      "2020-01-06 21:55:21.605",
      "2020-01-06 23:57:38.370",
      "2020-01-07 09:26:01.576",
      "2020-01-08 18:24:54.721",
      "2020-01-09 04:44:05.228",
      "2020-01-09 04:54:45.951",
      "2020-01-09 14:45:24.725",
      "2020-01-09 23:09:46.076",
      "2020-01-10 15:04:13.207",
      "2020-01-12 06:52:34.674",
      "2020-01-13 02:22:10.418",
      "2020-01-13 02:41:13.034",
      "2020-01-13 20:42:02.985",
      "2020-01-14 15:22:32.933",
      "2020-01-14 16:34:48.285",
      "2020-01-14 19:10:19.671"
    ],
    "is_noise_query": true,
    "nlp": "Find accounts that either do not have an Account_Withdraw_Account relationship or have a Person_Invest_Company relationship with another Medium node, ordered by creation time, and return the first 32 creation times."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.createTime) AS min_value",
    "answer": "2020-01-15 09:39:18.811",
    "is_noise_query": true,
    "nlp": "Find the earliest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountType) AS max_value",
    "answer": "trust account",
    "is_noise_query": true,
    "nlp": "Find the account type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.lastLoginTime RETURN collect(a.lastLoginTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find the last 32 login times of accounts that have repaid a loan, ordered by their last login time."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Own_Account]->(:Account) OR (n)-[:Person_Guarantee_Person]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Calculate the number of accounts that do not have a direct Person_Own_Account relationship but may have a Person_Guarantee_Person relationship with another account."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account *2..4]-(b:Account) RETURN count(b) AS cnt",
    "answer": 3184,
    "is_noise_query": true,
    "nlp": "Count pairs of accounts connected through 2 to 4 hops via the Company_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:253327479039591558",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:253327479039591558",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 accounts ordered by email, then for each of these, find the top 10 related accounts ordered by their login frequency type."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.email MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of accounts where the second account was created after the first, both having different emails, and order the pairs by the creation time of the second account."
  },
  {
    "query": "MATCH (a:Account {email: '149744687610069573'})-[:Company_Invest_Company]->(b:Account) WITH b MATCH (b)-[:Person_Apply_Loan]->(c:Account) WHERE c.accountLevel = '149744687610069573' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where an account with a specific email invests in another company, which in turn applies for a loan with an account level matching the original email's account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel = '149744687610069573' WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Find all account types except those with the specific account level '149744687610069573', order them by account type, and return the first 32 account types."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Company_Guarantee_Company]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of accounts that do not have a relationship with another account through either the Person_Invest_Company or Company_Guarantee_Company relationships."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Guarantee_Person]->(:Account) OR (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.nickname RETURN collect(a.nickname)[0..32] AS vals",
    "answer": [
      "Aaron Nutting",
      "Aaron Nutting",
      "Abdul Hirsch",
      "Abdul Hirsch",
      "Abdul Saabatmand",
      "Abdul Saabatmand",
      "Abdul Torigian",
      "Abdul Torigian",
      "Abel Toyn",
      "Abel Toyn",
      "Adalberto Roghair",
      "Adalberto Roghair",
      "Adan Meggerson",
      "Adan Meggerson",
      "Adan Raghunandan",
      "Adelaide Eagy",
      "Adelaide Eagy",
      "Adelaide Kuliga",
      "Adelaide Kuliga",
      "Adina Bramlett",
      "Adina Bramlett",
      "Adolfo Jamgochian",
      "Adolfo Jamgochian",
      "Adolfo Lazo",
      "Adolfo Lazo",
      "Adria Forward",
      "Adria Forward",
      "Adrian Juniel",
      "Adrian Juniel",
      "Adriana Home",
      "Adriana Home",
      "Agustin Cefaratti"
    ],
    "is_noise_query": true,
    "nlp": "Find all nicknames of accounts that do not have a relationship with another account through the Person_Guarantee_Person relationship or do have such a relationship, order them by nickname, and return the first 32 nicknames."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account]-()-[:Medium_SignIn_Account]-(b:Account) WHERE NOT (a)-[:Medium_SignIn_Account]-(b) WITH b ORDER BY b.isBlocked LIMIT 20 RETURN b.isBlocked",
    "answer": [
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      },
      {
        "b.isBlocked": false
      }
    ],
    "is_noise_query": true,
    "nlp": "Find all accounts that are connected through Medium_SignIn_Account relationships but not directly to themselves, order them by their blocked status, limit the results to 20, and return whether they are blocked."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.nickname) AS min_value",
    "answer": "Aaron Nutting",
    "is_noise_query": true,
    "nlp": "Return the nickname that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:25:27.687",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Invest_Company]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Find all blocked statuses of accounts that have a relationship with another account through the Company_Invest_Company relationship, order them by blocked status, and return the first 32 blocked statuses."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Account) OR (n)-[:Person_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Return the count of accounts that do not have a relationship with another account through the Person_Guarantee_Person relationship or do have a relationship through the Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Medium_SignIn_Account *2..3]-(b:Account) RETURN count(b) AS cnt",
    "answer": 26076,
    "is_noise_query": true,
    "nlp": "Return the count of accounts that are connected through Medium_SignIn_Account relationships with a path length between 2 and 3."
  },
  {
    "query": "MATCH p = (a:Account)-[:Account_Repay_Loan *1..4]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.710688986148102,
    "is_noise_query": true,
    "nlp": "Return the average length of paths where accounts are connected through Account_Repay_Loan relationships with a path length between 1 and 4."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.phonenum LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896538694858571939"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896538694858572073"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835282970"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835284135"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407894741"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407894843"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835283081"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:285134151407895701"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4713861434973357038",
        "b": "Account:4896820169835284218"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the ten accounts with the lowest phone numbers, then find the ten non-blocked accounts, and return both sets of accounts."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.lastLoginTime MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.accountLevel RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count the number of unique pairs of accounts where the last login time is ordered and the account levels are different."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4850095323701315097'})-[:Account_Repay_Loan]->(b:Account) WITH b MATCH (b)-[:Company_Own_Account]->(c:Account) WHERE c.freqLoginType = '4850095323701315097' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Find the total count of accounts that have an account level '4850095323701315097', repaid a loan, and are connected to another account through a company ownership relationship, where the connected account's frequent login type matches the given account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum = '4850095323701315097' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts whose phone number does not match '4850095323701315097'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.nickname ENDS WITH '4850095323701315097' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Return the first 32 creation times of accounts whose nickname does not end with '4850095323701315097', ordered by creation time."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts that do not have a Loan Deposit Account relationship but have a Company Apply Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Invest_Company]->(:Account) OR (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Collect the first 32 account types of accounts that do not have a Person Invest Company relationship but have a Company Apply Loan relationship, ordered by account type."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Repay_Loan]-()-[:Account_Repay_Loan]-(b:Account) WHERE NOT (a)-[:Account_Repay_Loan]-(b) WITH b ORDER BY b.email LIMIT 20 RETURN b.email",
    "answer": [
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "anjungcafe.com"
      },
      {
        "b.email": "asiancutes.com"
      },
      {
        "b.email": "asiancutes.com"
      },
      {
        "b.email": "blackvault.com"
      },
      {
        "b.email": "blackvault.com"
      },
      {
        "b.email": "blackvault.com"
      },
      {
        "b.email": "blackvault.com"
      },
      {
        "b.email": "blackvault.com"
      },
      {
        "b.email": "blackvault.com"
      },
      {
        "b.email": "blackvault.com"
      },
      {
        "b.email": "blackvault.com"
      }
    ],
    "is_noise_query": true,
    "nlp": "Return the email addresses of up to 20 accounts that are part of an Account Repay Loan chain but are not directly linked to another account in the same chain, ordered by email."
  },
  {
    "query": "MATCH (a:Loan) RETURN avg(a.balance) AS avg_value",
    "answer": 25806019.535552666,
    "is_noise_query": true,
    "nlp": "Calculate the average balance of all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN min(a.loanAmount) AS min_value",
    "answer": 88778.0,
    "is_noise_query": true,
    "nlp": "Find the minimum loan amount among all loans."
  },
  {
    "query": "MATCH (a:Loan) RETURN max(a.createTime) AS max_value",
    "answer": "2022-11-29 02:41:50.010",
    "is_noise_query": true,
    "nlp": "Find the latest creation time among all loans."
  },
  {
    "query": "MATCH (a:Loan) WHERE (a)-[:Person_Invest_Company]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve the earliest 32 creation times of loans that have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (n:Loan) WHERE NOT (n)-[:Company_Apply_Loan]->(:Loan) OR (n)-[:Person_Guarantee_Person]->(:Loan) RETURN count(n)",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either don't have a Company_Apply_Loan relationship or do have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (n:Loan) WHERE n.loanUsage <> '159314836818231369' OR (n)-[:Medium_SignIn_Account]->(:Loan) RETURN avg(n.loanAmount)",
    "answer": 48819411.184508234,
    "is_noise_query": true,
    "nlp": "Calculate the average loan amount for loans where the usage is not '159314836818231369' or have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanUsage LIMIT 10 MATCH (b:Loan) WITH a, b ORDER BY b.loanUsage LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4701476535998088242"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4711891110136381993"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:79375943432405966"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:82472168176223460"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:70650219154375089"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:29836347531329650"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4663195939165439209"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:66146619527004485"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4658973814514778717"
      },
      {
        "a": "Loan:4701476535998088242",
        "b": "Loan:4714705859903489184"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 loans ordered by loan usage. From these, select another top 10 loans also ordered by loan usage, returning pairs."
  },
  {
    "query": "MATCH (a:Loan) WITH a ORDER BY a.loanAmount MATCH (b:Loan) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 5278506,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct loans where the first is ordered by loan amount and the second by creation time."
  },
  {
    "query": "MATCH (a:Loan {interestRate: '159314836818231369'})-[:Person_Own_Account]->(b:Loan) WITH b MATCH (b)-[:Loan_Deposit_Account]->(c:Loan) WHERE c.loanAmount = '159314836818231369' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where loans with an interest rate of '159314836818231369' have a Person_Own_Account relationship leading to another loan which has a Loan_Deposit_Account relationship with the same loan amount."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT a.balance = '159314836818231369' WITH a ORDER BY a.interestRate RETURN collect(a.interestRate)[0..32] AS vals",
    "answer": [
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001,
      0.001
    ],
    "is_noise_query": true,
    "nlp": "Collect interest rates of loans where the balance is not '159314836818231369', ordered by interest rate, up to 32 entries."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Loan) OR (a)-[:Company_Invest_Company]->(:Loan) RETURN count(a) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Count loans that either don't have a Loan_Deposit_Account relationship or do have a Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Loan) WHERE NOT (a)-[:Person_Apply_Loan]->(:Loan) OR (a)-[:Company_Invest_Company]->(:Loan) WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-02-15 04:08:32.798",
      "2020-03-01 17:27:28.106",
      "2020-03-02 09:52:49.443",
      "2020-03-09 17:05:43.642",
      "2020-03-19 21:33:03.111",
      "2020-03-25 21:38:48.861",
      "2020-03-27 12:33:42.226",
      "2020-03-28 18:07:16.974",
      "2020-04-08 01:40:31.404",
      "2020-04-08 09:26:17.655",
      "2020-04-16 08:40:26.316",
      "2020-04-20 14:10:31.679",
      "2020-05-01 04:43:56.658",
      "2020-05-07 20:31:59.392",
      "2020-05-13 14:46:45.421",
      "2020-05-13 23:09:16.040",
      "2020-05-18 06:30:40.531",
      "2020-05-18 13:27:24.485",
      "2020-05-27 10:04:16.571",
      "2020-05-29 10:06:32.107",
      "2020-05-31 10:52:56.713",
      "2020-06-01 11:47:21.290",
      "2020-06-06 10:22:42.383",
      "2020-06-06 23:47:05.856",
      "2020-06-09 04:23:11.151",
      "2020-06-10 13:30:08.212",
      "2020-06-10 22:03:14.137",
      "2020-06-11 15:20:29.858",
      "2020-06-15 00:52:47.933",
      "2020-06-17 19:21:54.812",
      "2020-06-19 11:59:30.129",
      "2020-06-26 12:40:05.663"
    ],
    "is_noise_query": true,
    "nlp": "Collect creation times of loans that either don't have a Person_Apply_Loan relationship or do have a Company_Invest_Company relationship, ordered by creation time, up to 32 entries."
  },
  {
    "query": "MATCH (a:Loan) RETURN count(a.interestRate) AS cnt UNION MATCH (b:Loan) RETURN count(b.interestRate) AS cnt",
    "answer": 2298,
    "is_noise_query": true,
    "nlp": "Return the count of interest rates from two separate sets of loans, effectively doubling the count."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountLevel) AS min_value",
    "answer": "Basic level",
    "is_noise_query": true,
    "nlp": "Return the minimum account level among all accounts, considering lexicographical order."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.accountType) AS max_value",
    "answer": "trust account",
    "is_noise_query": true,
    "nlp": "Find the maximum account type among all accounts, considering lexicographical order."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Account_Repay_Loan]->(:Account) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect the blocked statuses of accounts that have an Account_Repay_Loan relationship, ordered by whether they are blocked, up to 32 entries."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Person_Own_Account]->(:Account) OR (n)-[:Company_Apply_Loan]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either don't have a Person_Own_Account relationship or do have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH p = (a:Account)-[:Account_Repay_Loan *1..4]-(b:Account) RETURN avg(length(p)) AS avg_len",
    "answer": 3.710688986148102,
    "is_noise_query": true,
    "nlp": "Calculate the average path length between accounts connected by up to 4 Account_Repay_Loan relationships."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.freqLoginType LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.freqLoginType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4898227544718837133"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:286823001268159172"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285697101361317507"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:286260051314737727"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897383119788705189"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4898227544718836111"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285415626384605546"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:285415626384605793"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4897664594765414856"
      },
      {
        "a": "Account:4898227544718837133",
        "b": "Account:4898509019695546810"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 accounts ordered by login frequency type, then from those, select another top 10 accounts also ordered by login frequency type, returning pairs."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.nickname MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.isBlocked RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct accounts where the first is ordered by nickname and the second by blocked status."
  },
  {
    "query": "MATCH (a:Account {accountLevel: '4794081803335893970'})-[:Account_Repay_Loan]->(b:Account) WITH b MATCH (b)-[:Company_Apply_Loan]->(c:Account) WHERE c.accountLevel = '4794081803335893970' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where accounts with a specific account level have an Account_Repay_Loan relationship leading to another account which has a Company_Apply_Loan relationship with the same account level."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.createTime ENDS WITH '4794081803335893970' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts where the creation time does not end with '4794081803335893970'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.phonenum CONTAINS '4794081803335893970' WITH a ORDER BY a.createTime RETURN collect(a.createTime)[0..32] AS vals",
    "answer": [
      "2020-01-15 09:39:18.811",
      "2020-01-17 18:07:52.342",
      "2020-01-22 07:00:59.076",
      "2020-02-04 07:42:39.682",
      "2020-02-04 08:40:09.022",
      "2020-02-23 17:50:09.791",
      "2020-03-13 09:01:08.745",
      "2020-03-14 00:12:20.640",
      "2020-03-14 09:19:58.640",
      "2020-03-16 20:22:47.571",
      "2020-03-17 06:07:41.458",
      "2020-03-23 21:12:42.438",
      "2020-04-01 17:28:37.980",
      "2020-04-03 01:58:09.041",
      "2020-04-05 14:40:15.496",
      "2020-04-08 08:36:39.778",
      "2020-04-11 12:03:31.027",
      "2020-04-11 21:50:13.558",
      "2020-04-12 12:38:11.729",
      "2020-04-16 16:40:37.687",
      "2020-04-18 05:15:51.905",
      "2020-04-18 15:42:10.157",
      "2020-04-22 23:36:21.218",
      "2020-04-26 09:16:17.123",
      "2020-05-03 08:09:37.600",
      "2020-05-08 13:00:41.985",
      "2020-05-11 14:53:39.579",
      "2020-05-11 19:04:47.665",
      "2020-05-12 20:23:31.086",
      "2020-05-16 03:17:45.505",
      "2020-05-17 21:07:38.310",
      "2020-05-20 15:48:09.127"
    ],
    "is_noise_query": true,
    "nlp": "Collect creation times of accounts where the phone number does not contain '4794081803335893970', ordered by creation time, up to 32 entries."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Account) OR (a)-[:Account_Withdraw_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either don't have a Company_Guarantee_Company relationship or do have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Withdraw_Account]->(:Account) OR (a)-[:Person_Invest_Company]->(:Account) WITH a ORDER BY a.accountLevel RETURN collect(a.accountLevel)[0..32] AS vals",
    "answer": [
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level",
      "Basic level"
    ],
    "is_noise_query": true,
    "nlp": "Collect account levels of accounts that either don't have an Account_Withdraw_Account relationship or do have a Person_Invest_Company relationship, ordered by account level, up to 32 entries."
  },
  {
    "query": "MATCH (a:Medium) RETURN min(a.lastLoginTime) AS min_value",
    "answer": "2020-01-29 05:12:39.506",
    "is_noise_query": true,
    "nlp": "Find the earliest last login time among all mediums."
  },
  {
    "query": "MATCH (a:Medium) RETURN max(a.isBlocked) AS max_value",
    "answer": true,
    "is_noise_query": true,
    "nlp": "Find the maximum isBlocked value among all mediums."
  },
  {
    "query": "MATCH (a:Medium) WHERE (a)-[:Loan_Deposit_Account]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect blocked statuses of mediums that have a Loan_Deposit_Account relationship, ordered by blocked status, up to 32 entries."
  },
  {
    "query": "MATCH (n:Medium) WHERE NOT (n)-[:Account_Repay_Loan]->(:Medium) OR (n)-[:Person_Guarantee_Person]->(:Medium) RETURN count(n)",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either don't have an Account_Repay_Loan relationship or do have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.mediumType LIMIT 10 MATCH (b:Medium) WITH a, b ORDER BY b.lastLoginTime LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Medium:1861",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:386",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1728",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:680",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:20",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1897",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1551",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1983",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:249",
        "b": "Medium:1994"
      },
      {
        "a": "Medium:1718",
        "b": "Medium:1994"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 mediums ordered by medium type, and from those, select another top 10 mediums also ordered by last login time, returning pairs."
  },
  {
    "query": "MATCH (a:Medium) WITH a ORDER BY a.isBlocked MATCH (b:Medium) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 3800550,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct mediums where the first is ordered by blocked status and the second by creation time."
  },
  {
    "query": "MATCH (a:Medium {createTime: '43980465112426'})-[:Company_Own_Account]->(b:Medium) WITH b MATCH (b)-[:Company_Own_Account]->(c:Medium) WHERE c.riskLevel = '43980465112426' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where mediums with a specific creation time have a Company_Own_Account relationship leading to another medium which has a Company_Own_Account relationship with the same risk level."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.riskLevel = '43980465112426' RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums where the risk level is not '43980465112426'."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT a.mediumType = '43980465112426' WITH a ORDER BY a.mediumType RETURN collect(a.mediumType)[0..32] AS vals",
    "answer": [
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM",
      "ATM"
    ],
    "is_noise_query": true,
    "nlp": "Collect medium types of mediums where the medium type is not '43980465112426', ordered by medium type, up to 32 entries."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Medium) OR (a)-[:Loan_Deposit_Account]->(:Medium) RETURN count(a) AS cnt",
    "answer": 1950,
    "is_noise_query": true,
    "nlp": "Count mediums that either don't have a Company_Guarantee_Company relationship or do have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Medium) WHERE NOT (a)-[:Company_Guarantee_Company]->(:Medium) OR (a)-[:Person_Guarantee_Person]->(:Medium) WITH a ORDER BY a.isBlocked RETURN collect(a.isBlocked)[0..32] AS vals",
    "answer": [
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false,
      false
    ],
    "is_noise_query": true,
    "nlp": "Collect blocked statuses of mediums that either don't have a Company_Guarantee_Company relationship or do have a Person_Guarantee_Person relationship, ordered by blocked status, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.url) AS min_value",
    "answer": "https://www.abeampedestalled.com",
    "is_noise_query": true,
    "nlp": "Return the URL that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.country) AS max_value",
    "answer": "Zambia",
    "is_noise_query": true,
    "nlp": "Find the country that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company)-[r:Company_Invest_Company]-(b:Company) WHERE r._edge_id CONTAINS '568' RETURN count(a) AS cnt",
    "answer": 42,
    "is_noise_query": true,
    "nlp": "Count companies that have a Company_Invest_Company relationship with an edge ID containing '568'."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Invest_Company]->(:Company) WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect URLs of companies that have a Person_Invest_Company relationship, ordered by URL, up to 32 entries."
  },
  {
    "query": "MATCH (n:Company) WHERE (n)-[:Company_Invest_Company]->(:Company) OR (n)-[:Person_Apply_Loan]->(:Company) RETURN count(n) AS cnt",
    "answer": 918,
    "is_noise_query": true,
    "nlp": "Count companies that either have a Company_Invest_Company relationship or a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Account_Transfer_Account]->(:Company) OR (n)-[:Company_Invest_Company]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either don't have an Account_Transfer_Account relationship or do have a Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.companyName LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:584",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:807",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:43",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:344",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:641",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:538",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:599",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:595",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:237",
        "b": "Company:4398046511515"
      },
      {
        "a": "Company:423",
        "b": "Company:4398046511515"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 companies ordered by their blocked status, then from those, select another top 10 companies also ordered by company name, returning pairs of these companies."
  },
  {
    "query": "MATCH (a:Company), (b:Company) WHERE a.description = b.description AND a <> b WITH a, b ORDER BY a.description, b.description LIMIT 32 RETURN a, b",
    "answer": [
      {
        "a": "Company:12094627906033",
        "b": "Company:14293651161300"
      },
      {
        "a": "Company:14293651161300",
        "b": "Company:12094627906033"
      },
      {
        "a": "Company:1099511628450",
        "b": "Company:12094627906215"
      },
      {
        "a": "Company:12094627906215",
        "b": "Company:1099511628450"
      },
      {
        "a": "Company:6597069767212",
        "b": "Company:6597069766845"
      },
      {
        "a": "Company:6597069766845",
        "b": "Company:6597069767212"
      },
      {
        "a": "Company:29",
        "b": "Company:3298534883391"
      },
      {
        "a": "Company:3298534883391",
        "b": "Company:29"
      },
      {
        "a": "Company:2199023256267",
        "b": "Company:8796093023073"
      },
      {
        "a": "Company:8796093023073",
        "b": "Company:2199023256267"
      },
      {
        "a": "Company:2199023256206",
        "b": "Company:8796093022516"
      },
      {
        "a": "Company:8796093022516",
        "b": "Company:2199023256206"
      },
      {
        "a": "Company:2199023256189",
        "b": "Company:10995116278053"
      },
      {
        "a": "Company:10995116278053",
        "b": "Company:2199023256189"
      },
      {
        "a": "Company:2199023256481",
        "b": "Company:12094627905597"
      },
      {
        "a": "Company:12094627905597",
        "b": "Company:2199023256481"
      }
    ],
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies with identical descriptions, excluding self-pairs, and order them by company description, limiting the result to 32 pairs."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.isBlocked MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.createTime RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies where the first is ordered by blocked status and the second by creation time, ensuring the companies are different."
  },
  {
    "query": "MATCH (a:Company), (b:Company) WHERE a.city = b.city AND a <> b RETURN count(*) AS cnt",
    "answer": 706,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies located in the same city, excluding self-pairs."
  },
  {
    "query": "MATCH (a:Company {country: '568'})-[:Person_Own_Account]->(b:Company) WITH b MATCH (b)-[:Account_Transfer_Account]->(c:Company) WHERE c.url = '568' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where companies from a specific country have a Person_Own_Account relationship leading to another company which has an Account_Transfer_Account relationship with the same URL."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.companyName ENDS WITH '568' WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS vals",
    "answer": [
      "Abernathy PLC",
      "Abshire-Hermann",
      "Abshire-Kirlin",
      "Altenwerth Ltd",
      "Altenwerth-Littel",
      "Anderson PLC",
      "Anderson PLC",
      "Anderson-Tromp",
      "Auer Group",
      "Auer PLC",
      "Auer-Abshire",
      "Auer-Bauch",
      "Auer-Klein",
      "Auer-Leuschke",
      "Aufderhar-Collier",
      "Aufderhar-Kozey",
      "Bahringer-Beer",
      "Bahringer-Daniel",
      "Bahringer-Windler",
      "Bailey-Stehr",
      "Bailey-Stehr",
      "Barrows and Sons",
      "Bartell-Kuhic",
      "Bartoletti Inc",
      "Bartoletti and Sons",
      "Barton PLC",
      "Barton-Langosh",
      "Bashirian-Nolan",
      "Batz and Sons",
      "Batz-Gottlieb",
      "Bauch-Herman",
      "Beatty PLC"
    ],
    "is_noise_query": true,
    "nlp": "Collect company names of companies where the company name does not end with '568', ordered by company name, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Company_Invest_Company]->(:Company) OR (a)-[:Account_Transfer_Account]->(:Company) RETURN count(a) AS cnt",
    "answer": 50,
    "is_noise_query": true,
    "nlp": "Count companies that either don't have a Company_Invest_Company relationship or do have an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Account_Transfer_Account]->(:Company) OR (a)-[:Company_Guarantee_Company]->(:Company) WITH a ORDER BY a.business RETURN collect(a.business)[0..32] AS vals",
    "answer": [
      "Abortion Clinic",
      "Accountant",
      "Accounting Firm",
      "Accounting School",
      "Acoustical Consultant",
      "Acrobatic Diving Pool",
      "Aerobics Instructor",
      "Afghani Restaurant",
      "Aggregate Supplier",
      "Agricultural Association",
      "Aikido School",
      "Air Compressor Supplier",
      "Air Conditioning Repair Service",
      "Air Conditioning Store",
      "Airbrushing Service",
      "Aircraft Rental Service",
      "Airline",
      "Airline",
      "Alcohol Manufacturer",
      "Alcohol Retail Monopoly",
      "Alcoholism Treatment Program",
      "Alternator Supplier",
      "Aluminum Window",
      "Ambulance Service",
      "Amusement Center",
      "Amusement Ride Supplier",
      "Andalusian Restaurant",
      "Anesthesiologist",
      "Anglican Church",
      "Animation Studio",
      "Apartment Building",
      "Apartment Building"
    ],
    "is_noise_query": true,
    "nlp": "Collect business types of companies that either don't have an Account_Transfer_Account relationship or do have a Company_Guarantee_Company relationship, ordered by business type, up to 32 entries."
  },
  {
    "query": "MATCH (a:Company) RETURN count(a.createTime) AS cnt UNION MATCH (b:Company) RETURN count(b.createTime) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Return the count of creation times from a single set of companies, as the union operation duplicates the count."
  },
  {
    "query": "MATCH (a:Company) RETURN min(a.country) AS min_value",
    "answer": "Afghanistan",
    "is_noise_query": true,
    "nlp": "Return the country that comes first alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) RETURN max(a.description) AS max_value",
    "answer": "You had to pull himself off by force; then they quickly finished their meal at home, every other day would be in an empty room like that in such a nice home for the time to get the chest of drawers was.",
    "is_noise_query": true,
    "nlp": "Find the description that comes last alphabetically among all companies."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Company_Invest_Company]->(:Company) RETURN count(a) AS cnt",
    "answer": 918,
    "is_noise_query": true,
    "nlp": "Count companies that have invested in other companies through a Company_Invest_Company relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE (a)-[:Person_Guarantee_Person]->(:Company) WITH a ORDER BY a.companyName RETURN collect(a.companyName)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect company names of companies that are involved in a Person_Guarantee_Person relationship with another company, ordered by company name, up to 32 entries."
  },
  {
    "query": "MATCH (n:Company) WHERE NOT (n)-[:Person_Invest_Company]->(:Company) OR (n)-[:Account_Repay_Loan]->(:Company) RETURN count(n)",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have any outgoing Person_Invest_Company relationships or have at least one incoming Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Company)-[:Company_Invest_Company *2..2]-(b:Company) RETURN count(b) AS cnt",
    "answer": 22180,
    "is_noise_query": true,
    "nlp": "Count companies that are part of a two-step Company_Invest_Company relationship, meaning they are connected through exactly two hops of Company_Invest_Company relationships."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.city LIMIT 10 MATCH (b:Company) WITH a, b ORDER BY b.isBlocked LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Company:5497558139444",
        "b": "Company:538"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:237"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:641"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:599"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:595"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:43"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:344"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:584"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:807"
      },
      {
        "a": "Company:5497558139444",
        "b": "Company:423"
      }
    ],
    "is_noise_query": true,
    "nlp": "Select the top 10 companies ordered by city, then from those, select the top 10 companies ordered by whether they are blocked, returning pairs of these companies."
  },
  {
    "query": "MATCH (a:Company) WITH a ORDER BY a.companyName MATCH (b:Company) WHERE a <> b WITH a, b ORDER BY b.url RETURN count(*) AS pair_count",
    "answer": 936056,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies where the first company is ordered by company name and the second by URL, ensuring both companies are different."
  },
  {
    "query": "MATCH (a:Company), (b:Company) WHERE a.country = b.country AND a <> b RETURN count(*) AS cnt",
    "answer": 50352,
    "is_noise_query": true,
    "nlp": "Count pairs of distinct companies located in the same country."
  },
  {
    "query": "MATCH (a:Company {isBlocked: '7696581395352'})-[:Medium_SignIn_Account]->(b:Company) WITH b MATCH (b)-[:Person_Guarantee_Person]->(c:Company) WHERE c.createTime = '7696581395352' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count instances where companies with a specific blocked status have a Medium_SignIn_Account relationship leading to another company which has a Person_Guarantee_Person relationship with the same creation time."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.companyName ENDS WITH '7696581395352' RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies whose name does not end with '7696581395352'."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT a.createTime STARTS WITH '7696581395352' WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS vals",
    "answer": [
      "https://www.abeampedestalled.com",
      "https://www.abeamspray.io",
      "https://www.abeddishonors.net",
      "https://www.ablyrechristens.io",
      "https://www.abroachthack.edu",
      "https://www.activelyveers.info",
      "https://www.adriftlob.io",
      "https://www.afielddarn.org",
      "https://www.afirewaff.net",
      "https://www.aflutterschlepp.org",
      "https://www.aforetimerecrudesce.com",
      "https://www.aftblent.edu",
      "https://www.againknead.net",
      "https://www.agapedome.io",
      "https://www.agapeflavours.info",
      "https://www.agoneligatures.info",
      "https://www.aheadstore.io",
      "https://www.airilybask.edu",
      "https://www.aleetwins.gov",
      "https://www.allchaperons.org",
      "https://www.alldisputing.io",
      "https://www.aloftequalise.edu",
      "https://www.alongshorebreakwaters.net",
      "https://www.aloudreworks.org",
      "https://www.alsoescalades.io",
      "https://www.alsojee.edu",
      "https://www.alsovacations.gov",
      "https://www.alwaysingest.com",
      "https://www.alwayspouches.com",
      "https://www.alwaysredescend.com",
      "https://www.aneardignify.net",
      "https://www.anesblub.edu"
    ],
    "is_noise_query": true,
    "nlp": "Retrieve up to 32 URLs of companies whose creation time does not start with '7696581395352', ordered by URL."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Loan_Deposit_Account]->(:Company) OR (a)-[:Account_Repay_Loan]->(:Company) RETURN count(a) AS cnt",
    "answer": 968,
    "is_noise_query": true,
    "nlp": "Count companies that either do not have a Loan_Deposit_Account relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Company) WHERE NOT (a)-[:Medium_SignIn_Account]->(:Company) OR (a)-[:Account_Transfer_Account]->(:Company) WITH a ORDER BY a.url RETURN collect(a.url)[0..32] AS vals",
    "answer": [
      "https://www.abeampedestalled.com",
      "https://www.abeamspray.io",
      "https://www.abeddishonors.net",
      "https://www.ablyrechristens.io",
      "https://www.abroachthack.edu",
      "https://www.activelyveers.info",
      "https://www.adriftlob.io",
      "https://www.afielddarn.org",
      "https://www.afirewaff.net",
      "https://www.aflutterschlepp.org",
      "https://www.aforetimerecrudesce.com",
      "https://www.aftblent.edu",
      "https://www.againknead.net",
      "https://www.agapedome.io",
      "https://www.agapeflavours.info",
      "https://www.agoneligatures.info",
      "https://www.aheadstore.io",
      "https://www.airilybask.edu",
      "https://www.aleetwins.gov",
      "https://www.allchaperons.org",
      "https://www.alldisputing.io",
      "https://www.aloftequalise.edu",
      "https://www.alongshorebreakwaters.net",
      "https://www.aloudreworks.org",
      "https://www.alsoescalades.io",
      "https://www.alsojee.edu",
      "https://www.alsovacations.gov",
      "https://www.alwaysingest.com",
      "https://www.alwayspouches.com",
      "https://www.alwaysredescend.com",
      "https://www.aneardignify.net",
      "https://www.anesblub.edu"
    ],
    "is_noise_query": true,
    "nlp": "Retrieve up to 32 URLs of companies that either do not have a Medium_SignIn_Account relationship or have an Account_Transfer_Account relationship, ordered by URL."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.accountType) AS min_value",
    "answer": "brokerage account",
    "is_noise_query": true,
    "nlp": "Return the account type that comes first alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the frequent login type that comes last alphabetically among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Company_Apply_Loan]->(:Account) WITH a ORDER BY a.phonenum RETURN collect(a.phonenum)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Collect phone numbers of accounts that have a Company_Apply_Loan relationship, ordered by phone number, up to 32."
  },
  {
    "query": "MATCH (n:Account) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Account) OR (n)-[:Person_Own_Account]->(:Account) RETURN count(n)",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that either do not have a Medium_SignIn_Account relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (a:Account)-[:Account_Repay_Loan *1..5]-(b:Account) RETURN count(b) AS cnt",
    "answer": 44326,
    "is_noise_query": true,
    "nlp": "Count accounts reachable within 1 to 5 steps via the Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.isBlocked LIMIT 10 MATCH (b:Account) WITH a, b ORDER BY b.accountType LIMIT 10 RETURN a, b",
    "answer": [
      {
        "a": "Account:4896538694858571939",
        "b": "Account:285978576338027459"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4897664594765414427"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:285697101361316562"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4897664594765414705"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4897101644811993938"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:285134151407895802"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896820169835282663"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4897101644811994893"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:4896820169835282792"
      },
      {
        "a": "Account:4896538694858571939",
        "b": "Account:286541526291449090"
      }
    ],
    "is_noise_query": true,
    "nlp": "Find the top 10 non-blocked accounts, then find the top 10 accounts of each type based on account type."
  },
  {
    "query": "MATCH (a:Account) WITH a ORDER BY a.accountType MATCH (b:Account) WHERE a <> b WITH a, b ORDER BY b.email RETURN count(*) AS pair_count",
    "answer": 14512290,
    "is_noise_query": true,
    "nlp": "Count unique pairs of different accounts ordered by email."
  },
  {
    "query": "MATCH (a:Account {nickname: '4853473023421843059'})-[:Person_Guarantee_Person]->(b:Account) WITH b MATCH (b)-[:Company_Own_Account]->(c:Account) WHERE c.freqLoginType = '4853473023421843059' RETURN count(*) AS total_cnt",
    "answer": 0,
    "is_noise_query": true,
    "nlp": "Count the number of accounts related through a Person_Guarantee_Person relationship to another account, which itself has a Company_Own_Account relationship leading to an account with a matching freqLoginType."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.lastLoginTime CONTAINS '4853473023421843059' RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count the number of accounts where the lastLoginTime does not contain '4853473023421843059'."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT a.accountLevel <> '4853473023421843059' WITH a ORDER BY a.email RETURN collect(a.email)[0..32] AS vals",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve the emails of accounts with an accountLevel of '4853473023421843059', ordered by email, up to 32 entries."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Person_Apply_Loan]->(:Account) OR (a)-[:Loan_Deposit_Account]->(:Account) RETURN count(a) AS cnt",
    "answer": 3810,
    "is_noise_query": true,
    "nlp": "Count accounts that do not have a Person_Apply_Loan relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (a:Account) WHERE NOT (a)-[:Account_Transfer_Account]->(:Account) OR (a)-[:Person_Apply_Loan]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS vals",
    "answer": [
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account",
      "brokerage account"
    ],
    "is_noise_query": true,
    "nlp": "Retrieve account types of accounts that either do not have an Account_Transfer_Account relationship or have a Person_Apply_Loan relationship, ordered by account type, up to 32 entries."
  },
  {
    "query": "MATCH (a:Account)-[:Company_Own_Account]-()-[:Company_Own_Account]-(b:Account) WHERE NOT (a)-[:Company_Own_Account]-(b) WITH b ORDER BY b.accountLevel LIMIT 20 RETURN b.accountLevel",
    "answer": [
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      },
      {
        "b.accountLevel": "Basic level"
      }
    ],
    "is_noise_query": true,
    "nlp": "Retrieve account levels of accounts that are indirectly connected through two Company_Own_Account relationships but not directly connected, limiting results to 20."
  },
  {
    "query": "MATCH (a:Account) RETURN min(a.isBlocked) AS min_value",
    "answer": false,
    "is_noise_query": true,
    "nlp": "Find the minimum value of the isBlocked field among all accounts."
  },
  {
    "query": "MATCH (a:Account) RETURN max(a.freqLoginType) AS max_value",
    "answer": "WIFI",
    "is_noise_query": true,
    "nlp": "Find the maximum value of the freqLoginType field, considering alphabetical order, among all accounts."
  },
  {
    "query": "MATCH (a:Account) WHERE (a)-[:Person_Guarantee_Person]->(:Account) WITH a ORDER BY a.accountType RETURN collect(a.accountType)[0..32] AS values",
    "answer": [],
    "is_noise_query": true,
    "nlp": "Retrieve account types of accounts that have a Person_Guarantee_Person relationship, ordered by account type, up to 32 entries."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Entity) OR (n)-[:Company_Guarantee_Company]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Guarantee_Person relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Transfer_Account]->(:Entity) OR (n)-[:Account_Repay_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Transfer_Account relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Transfer_Account]->(:Entity) OR (n)-[:Loan_Deposit_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Transfer_Account relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Entity) OR (n)-[:Person_Guarantee_Person]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Guarantee_Company relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Entity) OR (n)-[:Person_Invest_Company]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Loan_Deposit_Account relationship or have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Entity) OR (n)-[:Person_Apply_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Guarantee_Person relationship or have a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Repay_Loan]->(:Entity) OR (n)-[:Company_Guarantee_Company]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Repay_Loan relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Transfer_Account]->(:Entity) OR (n)-[:Company_Guarantee_Company]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Transfer_Account relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Account_Repay_Loan]->(:Entity) RETURN count(n)",
    "answer": 847,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Withdraw_Account relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Entity) OR (n)-[:Company_Own_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Loan_Deposit_Account relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE (n)-[:Company_Guarantee_Company]->(:Entity) OR (n)-[:Account_Withdraw_Account]->(:Entity) RETURN count(n) AS cnt",
    "answer": 12,
    "is_noise_query": false,
    "nlp": "Count entities that have either a Company_Guarantee_Company or an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Entity) OR (n)-[:Person_Own_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Guarantee_Company relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Person_Guarantee_Person]->(:Entity) RETURN count(n)",
    "answer": 847,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Withdraw_Account relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Apply_Loan]->(:Entity) OR (n)-[:Account_Transfer_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Apply_Loan relationship or have an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Own_Account]->(:Entity) OR (n)-[:Medium_SignIn_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Own_Account relationship or have a Medium_SignIn_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Apply_Loan]->(:Entity) OR (n)-[:Person_Apply_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Apply_Loan relationship or have a Person_Apply_Loan relationship. This statement is redundant and can be simplified to: Count all entities."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Person_Own_Account]->(:Entity) RETURN count(n)",
    "answer": 847,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Withdraw_Account relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE (n)-[:Company_Guarantee_Company]->(:Entity) OR (n)-[:Account_Withdraw_Account]->(:Entity) RETURN count(n) AS cnt",
    "answer": 12,
    "is_noise_query": false,
    "nlp": "Count entities that have either a Company_Guarantee_Company or an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Invest_Company]->(:Entity) OR (n)-[:Person_Invest_Company]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Invest_Company relationship or have a Person_Invest_Company relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Repay_Loan]->(:Entity) OR (n)-[:Account_Repay_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Repay_Loan relationship or have an Account_Repay_Loan relationship. This statement is redundant and can be simplified to: Count all entities."
  },
  {
    "query": "MATCH (n:Entity) WHERE (n)-[:Company_Invest_Company]->(:Entity) OR (n)-[:Account_Withdraw_Account]->(:Entity) RETURN count(n) AS cnt",
    "answer": 12,
    "is_noise_query": false,
    "nlp": "Count entities that have either a Company_Invest_Company or an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Entity) OR (n)-[:Company_Apply_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Guarantee_Company relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Invest_Company]->(:Entity) OR (n)-[:Account_Repay_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Invest_Company relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Entity) OR (n)-[:Person_Guarantee_Person]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Guarantee_Company relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Entity) OR (n)-[:Company_Apply_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Guarantee_Person relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Repay_Loan]->(:Entity) OR (n)-[:Loan_Deposit_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Repay_Loan relationship or have a Loan_Deposit_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Own_Account]->(:Entity) OR (n)-[:Person_Own_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Own_Account relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Entity) OR (n)-[:Account_Repay_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Medium_SignIn_Account relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Account_Withdraw_Account]->(:Entity) RETURN count(n) AS cnt",
    "answer": 12,
    "is_noise_query": false,
    "nlp": "Count entities that have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Invest_Company]->(:Entity) OR (n)-[:Account_Withdraw_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Invest_Company relationship or have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Entity) OR (n)-[:Person_Apply_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Guarantee_Person relationship or have a Person_Apply_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Guarantee_Person]->(:Entity) OR (n)-[:Company_Apply_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Guarantee_Person relationship or have a Company_Apply_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Loan_Deposit_Account]->(:Entity) OR (n)-[:Account_Withdraw_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Loan_Deposit_Account relationship or have an Account_Withdraw_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Medium_SignIn_Account]->(:Entity) OR (n)-[:Person_Guarantee_Person]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Medium_SignIn_Account relationship or have a Person_Guarantee_Person relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Person_Own_Account]->(:Entity) RETURN count(n)",
    "answer": 847,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Withdraw_Account relationship or have a Person_Own_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Company_Guarantee_Company]->(:Entity) OR (n)-[:Company_Own_Account]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Company_Guarantee_Company relationship or have a Company_Own_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Apply_Loan]->(:Entity) OR (n)-[:Account_Repay_Loan]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Apply_Loan relationship or have an Account_Repay_Loan relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Account_Transfer_Account]->(:Entity) RETURN count(n) AS cnt",
    "answer": 12,
    "is_noise_query": false,
    "nlp": "Count entities that have either an Account_Withdraw_Account or an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Account_Transfer_Account]->(:Entity) RETURN count(n)",
    "answer": 847,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Withdraw_Account relationship or have an Account_Transfer_Account relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Person_Own_Account]->(:Entity) OR (n)-[:Company_Guarantee_Company]->(:Entity) RETURN count(n)",
    "answer": 859,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have a Person_Own_Account relationship or have a Company_Guarantee_Company relationship."
  },
  {
    "query": "MATCH (n:Entity) WHERE NOT (n)-[:Account_Withdraw_Account]->(:Entity) OR (n)-[:Person_Invest_Company]->(:Entity) RETURN count(n)",
    "answer": 847,
    "is_noise_query": false,
    "nlp": "Count entities that either do not have an Account_Withdraw_Account relationship or have a Person_Invest_Company relationship."
  }
]